/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "js/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./app/js/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./app/js/controller/index.js":
/*!************************************!*\
  !*** ./app/js/controller/index.js ***!
  \************************************/
/*! exports provided: app */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"app\", function() { return app; });\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../model */ \"./app/js/model/index.js\");\n // import {} from '../view'\n\nvar app = {\n  init: function init() {\n    this.is();\n  },\n  is: function is() {\n    Object(_model__WEBPACK_IMPORTED_MODULE_0__[\"InitSlider\"])();\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvanMvY29udHJvbGxlci9pbmRleC5qcz9kZmM2Il0sIm5hbWVzIjpbImFwcCIsImluaXQiLCJpcyIsIkluaXRTbGlkZXIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtDQUdBOztBQUVBLElBQU1BLEdBQUcsR0FBRztBQUNYQyxNQURXLGtCQUNKO0FBQ04sU0FBS0MsRUFBTDtBQUNBLEdBSFU7QUFJWEEsSUFKVyxnQkFJUDtBQUNIQyw2REFBVTtBQUNWO0FBTlUsQ0FBWiIsImZpbGUiOiIuL2FwcC9qcy9jb250cm9sbGVyL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuXHRJbml0U2xpZGVyXHJcbn0gZnJvbSAnLi4vbW9kZWwnXHJcbi8vIGltcG9ydCB7fSBmcm9tICcuLi92aWV3J1xyXG5cclxuY29uc3QgYXBwID0ge1xyXG5cdGluaXQoKSB7XHJcblx0XHR0aGlzLmlzKClcclxuXHR9LFxyXG5cdGlzKCl7XHJcblx0XHRJbml0U2xpZGVyKClcclxuXHR9XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IHtcclxuXHRhcHBcclxufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./app/js/controller/index.js\n");

/***/ }),

/***/ "./app/js/main.js":
/*!************************!*\
  !*** ./app/js/main.js ***!
  \************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./controller */ \"./app/js/controller/index.js\");\n;\n\n\nif (document.readyState !== 'loading') {\n  _controller__WEBPACK_IMPORTED_MODULE_0__[\"app\"].init();\n} else {\n  document.addEventListener('DOMContentLoaded', function () {\n    _controller__WEBPACK_IMPORTED_MODULE_0__[\"app\"].init();\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvanMvbWFpbi5qcz80M2M0Il0sIm5hbWVzIjpbImRvY3VtZW50IiwicmVhZHlTdGF0ZSIsImFwcCIsImluaXQiLCJhZGRFdmVudExpc3RlbmVyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQzs7QUFFRCxJQUFJQSxRQUFRLENBQUNDLFVBQVQsS0FBd0IsU0FBNUIsRUFBd0M7QUFDcENDLGlEQUFHLENBQUNDLElBQUo7QUFDSCxDQUZELE1BRU87QUFDSEgsVUFBUSxDQUFDSSxnQkFBVCxDQUEwQixrQkFBMUIsRUFBOEMsWUFBWTtBQUN0REYsbURBQUcsQ0FBQ0MsSUFBSjtBQUNILEdBRkQ7QUFHSCIsImZpbGUiOiIuL2FwcC9qcy9tYWluLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiO2ltcG9ydCB7YXBwfSBmcm9tICcuL2NvbnRyb2xsZXInXHJcblxyXG5pZiggZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2xvYWRpbmcnICkge1xyXG4gICAgYXBwLmluaXQoKTtcclxufSBlbHNlIHtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgYXBwLmluaXQoKTtcclxuICAgIH0pO1xyXG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./app/js/main.js\n");

/***/ }),

/***/ "./app/js/model/App/InitSlider.js":
/*!****************************************!*\
  !*** ./app/js/model/App/InitSlider.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _libs_libs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../libs/libs */ \"./app/libs/libs.js\");\n\n\nvar InitSlider = function InitSlider() {\n  new _libs_libs__WEBPACK_IMPORTED_MODULE_0__[\"Splide\"]('.splide', {\n    type: 'loop',\n    // autoplay: true, \n    // interval: 4000,\n    pagination: false,\n    pauseOnHover: true,\n    cover: true\n  }).mount();\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (InitSlider);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvanMvbW9kZWwvQXBwL0luaXRTbGlkZXIuanM/YWNhNyJdLCJuYW1lcyI6WyJJbml0U2xpZGVyIiwiU3BsaWRlIiwidHlwZSIsInBhZ2luYXRpb24iLCJwYXVzZU9uSG92ZXIiLCJjb3ZlciIsIm1vdW50Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7O0FBS0EsSUFBTUEsVUFBVSxHQUFHLFNBQWJBLFVBQWEsR0FBTTtBQUN4QixNQUFJQyxpREFBSixDQUFZLFNBQVosRUFBdUI7QUFDdEJDLFFBQUksRUFBSyxNQURhO0FBRXRCO0FBQ0E7QUFDQUMsY0FBVSxFQUFFLEtBSlU7QUFLdEJDLGdCQUFZLEVBQUUsSUFMUTtBQU10QkMsU0FBSyxFQUFFO0FBTmUsR0FBdkIsRUFPR0MsS0FQSDtBQVFBLENBVEQ7O0FBWWVOLHlFQUFmIiwiZmlsZSI6Ii4vYXBwL2pzL21vZGVsL0FwcC9Jbml0U2xpZGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtTcGxpZGV9IGZyb20gJy4uLy4uLy4uL2xpYnMvbGlicydcclxuXHJcblxyXG5cclxuXHJcbmNvbnN0IEluaXRTbGlkZXIgPSAoKSA9PiB7XHJcblx0bmV3IFNwbGlkZSggJy5zcGxpZGUnLCB7XHJcblx0XHR0eXBlICAgOiAnbG9vcCcsXHJcblx0XHQvLyBhdXRvcGxheTogdHJ1ZSwgXHJcblx0XHQvLyBpbnRlcnZhbDogNDAwMCxcclxuXHRcdHBhZ2luYXRpb246IGZhbHNlLFxyXG5cdFx0cGF1c2VPbkhvdmVyOiB0cnVlLFxyXG5cdFx0Y292ZXI6IHRydWVcclxuXHR9KS5tb3VudCgpO1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgSW5pdFNsaWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./app/js/model/App/InitSlider.js\n");

/***/ }),

/***/ "./app/js/model/index.js":
/*!*******************************!*\
  !*** ./app/js/model/index.js ***!
  \*******************************/
/*! exports provided: InitSlider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _App_InitSlider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App/InitSlider */ \"./app/js/model/App/InitSlider.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"InitSlider\", function() { return _App_InitSlider__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvanMvbW9kZWwvaW5kZXguanM/YzgzZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBIiwiZmlsZSI6Ii4vYXBwL2pzL21vZGVsL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEluaXRTbGlkZXIgZnJvbSAnLi9BcHAvSW5pdFNsaWRlcidcclxuXHJcblxyXG5leHBvcnQge1xyXG5cdEluaXRTbGlkZXJcclxufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./app/js/model/index.js\n");

/***/ }),

/***/ "./app/libs/libs.js":
/*!**************************!*\
  !*** ./app/libs/libs.js ***!
  \**************************/
/*! exports provided: Splide */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _splidejs_splide__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @splidejs/splide */ \"./node_modules/@splidejs/splide/dist/js/splide.esm.js\");\n/* harmony import */ var _splidejs_splide__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_splidejs_splide__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"Splide\", function() { return _splidejs_splide__WEBPACK_IMPORTED_MODULE_0___default.a; });\n// import noUiSlider from 'nouislider'\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbGlicy9saWJzLmpzPzcxYWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBIiwiZmlsZSI6Ii4vYXBwL2xpYnMvbGlicy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGltcG9ydCBub1VpU2xpZGVyIGZyb20gJ25vdWlzbGlkZXInXHJcbmltcG9ydCBTcGxpZGUgZnJvbSAnQHNwbGlkZWpzL3NwbGlkZSdcclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCB7XHJcblx0U3BsaWRlXHJcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./app/libs/libs.js\n");

/***/ }),

/***/ "./node_modules/@splidejs/splide/dist/js/splide.esm.js":
/*!*************************************************************!*\
  !*** ./node_modules/@splidejs/splide/dist/js/splide.esm.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Splide.js\n * Version  : 2.4.20\n * License  : MIT\n * Copyright: 2020 Naotoshi Fujita\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (true) module.exports = factory();else {}\n})(self, function () {\n  return (\n    /******/\n    (() => {\n      // webpackBootstrap\n\n      /******/\n      \"use strict\";\n      /******/\n\n      var __webpack_modules__ = {\n        /***/\n        311:\n        /***/\n        (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n          // ESM COMPAT FLAG\n          __webpack_require__.r(__webpack_exports__); // EXPORTS\n\n\n          __webpack_require__.d(__webpack_exports__, {\n            \"default\": () =>\n            /* binding */\n            module_Splide\n          }); // NAMESPACE OBJECT: ./src/js/constants/states.js\n\n\n          var states_namespaceObject = {};\n\n          __webpack_require__.r(states_namespaceObject);\n\n          __webpack_require__.d(states_namespaceObject, {\n            \"CREATED\": () => CREATED,\n            \"DESTROYED\": () => DESTROYED,\n            \"IDLE\": () => IDLE,\n            \"MOUNTED\": () => MOUNTED,\n            \"MOVING\": () => MOVING\n          });\n\n          ; // CONCATENATED MODULE: ./src/js/core/event.js\n\n          /**\r\n           * The function for providing an Event object simply managing events.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The function for providing an Event object simply managing events.\r\n           */\n\n          /* harmony default export */\n\n          const core_event = function () {\n            /**\r\n             * Store all event data.\r\n             *\r\n             * @type {Array}\r\n             */\n            var data = [];\n            var Event = {\n              /**\r\n               * Subscribe the given event(s).\r\n               *\r\n               * @param {string}   events  - An event name. Use space to separate multiple events.\r\n               *                             Also, namespace is accepted by dot, such as 'resize.{namespace}'.\r\n               * @param {function} handler - A callback function.\r\n               * @param {Element}  elm     - Optional. Native event will be listened to when this arg is provided.\r\n               * @param {Object}   options - Optional. Options for addEventListener.\r\n               */\n              on: function on(events, handler, elm, options) {\n                if (elm === void 0) {\n                  elm = null;\n                }\n\n                if (options === void 0) {\n                  options = {};\n                }\n\n                events.split(' ').forEach(function (event) {\n                  if (elm) {\n                    elm.addEventListener(event, handler, options);\n                  }\n\n                  data.push({\n                    event: event,\n                    handler: handler,\n                    elm: elm,\n                    options: options\n                  });\n                });\n              },\n\n              /**\r\n               * Unsubscribe the given event(s).\r\n               *\r\n               * @param {string}  events - A event name or names split by space.\r\n               * @param {Element} elm    - Optional. removeEventListener() will be called when this arg is provided.\r\n               */\n              off: function off(events, elm) {\n                if (elm === void 0) {\n                  elm = null;\n                }\n\n                events.split(' ').forEach(function (event) {\n                  data = data.filter(function (item) {\n                    if (item && item.event === event && item.elm === elm) {\n                      unsubscribe(item);\n                      return false;\n                    }\n\n                    return true;\n                  });\n                });\n              },\n\n              /**\r\n               * Emit an event.\r\n               * This method is only for custom events.\r\n               *\r\n               * @param {string}  event - An event name.\r\n               * @param {*}       args  - Any number of arguments passed to handlers.\r\n               */\n              emit: function emit(event) {\n                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                  args[_key - 1] = arguments[_key];\n                }\n\n                data.forEach(function (item) {\n                  if (!item.elm && item.event.split('.')[0] === event) {\n                    item.handler.apply(item, args);\n                  }\n                });\n              },\n\n              /**\r\n               * Clear event data.\r\n               */\n              destroy: function destroy() {\n                data.forEach(unsubscribe);\n                data = [];\n              }\n            };\n            /**\r\n             * Remove the registered event listener.\r\n             *\r\n             * @param {Object} item - An object containing event data.\r\n             */\n\n            function unsubscribe(item) {\n              if (item.elm) {\n                item.elm.removeEventListener(item.event, item.handler, item.options);\n              }\n            }\n\n            return Event;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/core/state.js\n\n          /**\r\n           * The function providing a super simple state system.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The function providing a super simple state system.\r\n           *\r\n           * @param {string|number} initialState - Provide the initial state value.\r\n           */\n\n          /* harmony default export */\n\n          const state = function (initialState) {\n            /**\r\n             * Store the current state.\r\n             *\r\n             * @type {string|number}\r\n             */\n            var curr = initialState;\n            return {\n              /**\r\n               * Change state.\r\n               *\r\n               * @param {string|number} state - A new state.\r\n               */\n              set: function set(state) {\n                curr = state;\n              },\n\n              /**\r\n               * Verify if the current state is given one or not.\r\n               *\r\n               * @param {string|number} state - A state name to be verified.\r\n               *\r\n               * @return {boolean} - True if the current state is the given one.\r\n               */\n              is: function is(state) {\n                return state === curr;\n              }\n            };\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/utils/object.js\n\n          function _extends() {\n            _extends = Object.assign || function (target) {\n              for (var i = 1; i < arguments.length; i++) {\n                var source = arguments[i];\n\n                for (var key in source) {\n                  if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                  }\n                }\n              }\n\n              return target;\n            };\n\n            return _extends.apply(this, arguments);\n          }\n          /**\r\n           * Some utility functions related with Object, supporting IE.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n\n          var keys = Object.keys;\n          /**\r\n           * Iterate an object like Array.forEach.\r\n           * IE doesn't support forEach of HTMLCollection.\r\n           *\r\n           * @param {Object}    obj       - An object.\r\n           * @param {function}  callback  - A function handling each value. Arguments are value, property and index.\r\n           */\n\n          function each(obj, callback) {\n            keys(obj).some(function (key, index) {\n              return callback(obj[key], key, index);\n            });\n          }\n          /**\r\n           * Return values of the given object as an array.\r\n           * IE doesn't support Object.values.\r\n           *\r\n           * @param {Object} obj - An object.\r\n           *\r\n           * @return {Array} - An array containing all values of the given object.\r\n           */\n\n\n          function values(obj) {\n            return keys(obj).map(function (key) {\n              return obj[key];\n            });\n          }\n          /**\r\n           * Check if the given subject is object or not.\r\n           *\r\n           * @param {*} subject - A subject to be verified.\r\n           *\r\n           * @return {boolean} - True if object, false otherwise.\r\n           */\n\n\n          function isObject(subject) {\n            return typeof subject === 'object';\n          }\n          /**\r\n           * Merge two objects deeply.\r\n           *\r\n           * @param {Object} to   - An object where \"from\" is merged.\r\n           * @param {Object} from - An object merged to \"to\".\r\n           *\r\n           * @return {Object} - A merged object.\r\n           */\n\n\n          function merge(_ref, from) {\n            var to = _extends({}, _ref);\n\n            each(from, function (value, key) {\n              if (isObject(value)) {\n                if (!isObject(to[key])) {\n                  to[key] = {};\n                }\n\n                to[key] = merge(to[key], value);\n              } else {\n                to[key] = value;\n              }\n            });\n            return to;\n          }\n          /**\r\n           * Assign all properties \"from\" to \"to\" object.\r\n           *\r\n           * @param {Object} to   - An object where properties are assigned.\r\n           * @param {Object} from - An object whose properties are assigned to \"to\".\r\n           *\r\n           * @return {Object} - An assigned object.\r\n           */\n\n\n          function object_assign(to, from) {\n            keys(from).forEach(function (key) {\n              if (!to[key]) {\n                Object.defineProperty(to, key, Object.getOwnPropertyDescriptor(from, key));\n              }\n            });\n            return to;\n          }\n\n          ; // CONCATENATED MODULE: ./src/js/utils/utils.js\n\n          /**\r\n           * A package of some miscellaneous utility functions.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Convert the given value to array.\r\n           *\r\n           * @param {*} value - Any value.\r\n           *\r\n           * @return {*[]} - Array containing the given value.\r\n           */\n\n          function toArray(value) {\n            return Array.isArray(value) ? value : [value];\n          }\n          /**\r\n           * Check if the given value is between min and max.\r\n           * Min will be returned when the value is less than min or max will do when greater than max.\r\n           *\r\n           * @param {number} value - A number to be checked.\r\n           * @param {number} m1    - Minimum or maximum number.\r\n           * @param {number} m2    - Maximum or minimum number.\r\n           *\r\n           * @return {number} - A value itself, min or max.\r\n           */\n\n\n          function between(value, m1, m2) {\n            return Math.min(Math.max(value, m1 > m2 ? m2 : m1), m1 > m2 ? m1 : m2);\n          }\n          /**\r\n           * The sprintf method with minimum functionality.\r\n           *\r\n           * @param {string}       format       - The string format.\r\n           * @param {string|Array} replacements - Replacements accepting multiple arguments.\r\n           *\r\n           * @returns {string} - Converted string.\r\n           */\n\n\n          function sprintf(format, replacements) {\n            var i = 0;\n            return format.replace(/%s/g, function () {\n              return toArray(replacements)[i++];\n            });\n          }\n          /**\r\n           * Append px unit to the given subject if necessary.\r\n           *\r\n           * @param {number|string} value - A value that may not include an unit.\r\n           *\r\n           * @return {string} - If the value is string, return itself.\r\n           *                    If number, do value + \"px\". An empty string, otherwise.\r\n           */\n\n\n          function unit(value) {\n            var type = typeof value;\n\n            if (type === 'number' && value > 0) {\n              return parseFloat(value) + 'px';\n            }\n\n            return type === 'string' ? value : '';\n          }\n          /**\r\n           * Pad start with 0.\r\n           *\r\n           * @param {number} number - A number to be filled with 0.\r\n           *\r\n           * @return {string|number} - Padded number.\r\n           */\n\n\n          function pad(number) {\n            return number < 10 ? '0' + number : number;\n          }\n          /**\r\n           * Convert the given value to pixel.\r\n           *\r\n           * @param {Element}       root  - Root element where a dummy div is appended.\r\n           * @param {string|number} value - CSS value to be converted, such as 10rem.\r\n           *\r\n           * @return {number} - Pixel.\r\n           */\n\n\n          function toPixel(root, value) {\n            if (typeof value === 'string') {\n              var div = create('div', {});\n              applyStyle(div, {\n                position: 'absolute',\n                width: value\n              });\n              append(root, div);\n              value = div.clientWidth;\n              dom_remove(div);\n            }\n\n            return +value || 0;\n          }\n\n          ; // CONCATENATED MODULE: ./src/js/utils/dom.js\n\n          /**\r\n           * Some utility functions related with DOM.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Find the first element matching the given selector.\r\n           * Be aware that all selectors after a space are ignored.\r\n           *\r\n           * @param {Element|Node}  elm       - An ancestor element.\r\n           * @param {string}        selector  - DOMString.\r\n           *\r\n           * @return {Element|null} - A found element or null.\r\n           */\n\n          function find(elm, selector) {\n            return elm ? elm.querySelector(selector.split(' ')[0]) : null;\n          }\n          /**\r\n           * Find a first child having the given tag or class name.\r\n           *\r\n           * @param {Element} parent         - A parent element.\r\n           * @param {string}  tagOrClassName - A tag or class name.\r\n           *\r\n           * @return {Element|undefined} - A found element on success or undefined on failure.\r\n           */\n\n\n          function child(parent, tagOrClassName) {\n            return children(parent, tagOrClassName)[0];\n          }\n          /**\r\n           * Return chile elements that matches the provided tag or class name.\r\n           *\r\n           * @param {Element} parent         - A parent element.\r\n           * @param {string}  tagOrClassName - A tag or class name.\r\n           *\r\n           * @return {Element[]} - Found elements.\r\n           */\n\n\n          function children(parent, tagOrClassName) {\n            if (parent) {\n              return values(parent.children).filter(function (child) {\n                return hasClass(child, tagOrClassName.split(' ')[0]) || child.tagName === tagOrClassName;\n              });\n            }\n\n            return [];\n          }\n          /**\r\n           * Create an element with some optional attributes.\r\n           *\r\n           * @param {string} tag   - A tag name.\r\n           * @param {Object} attrs - An object any attribute pairs of name and value.\r\n           *\r\n           * @return {Element} - A created element.\r\n           */\n\n\n          function create(tag, attrs) {\n            var elm = document.createElement(tag);\n            each(attrs, function (value, key) {\n              return setAttribute(elm, key, value);\n            });\n            return elm;\n          }\n          /**\r\n           * Convert HTML string to DOM node.\r\n           *\r\n           * @param {string} html - HTML string.\r\n           *\r\n           * @return {Node} - A created node.\r\n           */\n\n\n          function domify(html) {\n            var div = create('div', {});\n            div.innerHTML = html;\n            return div.firstChild;\n          }\n          /**\r\n           * Remove a given element from a DOM tree.\r\n           *\r\n           * @param {Element|Element[]} elms - Element(s) to be removed.\r\n           */\n\n\n          function dom_remove(elms) {\n            toArray(elms).forEach(function (elm) {\n              if (elm) {\n                var parent = elm.parentElement;\n                parent && parent.removeChild(elm);\n              }\n            });\n          }\n          /**\r\n           * Append a child to a given element.\r\n           *\r\n           * @param {Element} parent - A parent element.\r\n           * @param {Element} child  - An element to be appended.\r\n           */\n\n\n          function append(parent, child) {\n            if (parent) {\n              parent.appendChild(child);\n            }\n          }\n          /**\r\n           * Insert an element before the reference element.\r\n           *\r\n           * @param {Element|Node} ref - A reference element.\r\n           * @param {Element}      elm - An element to be inserted.\r\n           */\n\n\n          function before(elm, ref) {\n            if (elm && ref) {\n              var parent = ref.parentElement;\n              parent && parent.insertBefore(elm, ref);\n            }\n          }\n          /**\r\n           * Apply styles to the given element.\r\n           *\r\n           * @param {Element} elm     - An element where styles are applied.\r\n           * @param {Object}  styles  - Object containing styles.\r\n           */\n\n\n          function applyStyle(elm, styles) {\n            if (elm) {\n              each(styles, function (value, prop) {\n                if (value !== null) {\n                  elm.style[prop] = value;\n                }\n              });\n            }\n          }\n          /**\r\n           * Add or remove classes to/from the element.\r\n           * This function is for internal usage.\r\n           *\r\n           * @param {Element}         elm     - An element where classes are added.\r\n           * @param {string|string[]} classes - Class names being added.\r\n           * @param {boolean}         remove  - Whether to remove or add classes.\r\n           */\n\n\n          function addOrRemoveClasses(elm, classes, remove) {\n            if (elm) {\n              toArray(classes).forEach(function (name) {\n                if (name) {\n                  elm.classList[remove ? 'remove' : 'add'](name);\n                }\n              });\n            }\n          }\n          /**\r\n           * Add classes to the element.\r\n           *\r\n           * @param {Element}          elm     - An element where classes are added.\r\n           * @param {string|string[]}  classes - Class names being added.\r\n           */\n\n\n          function addClass(elm, classes) {\n            addOrRemoveClasses(elm, classes, false);\n          }\n          /**\r\n           * Remove a class from the element.\r\n           *\r\n           * @param {Element}         elm     - An element where classes are removed.\r\n           * @param {string|string[]} classes - A class name being removed.\r\n           */\n\n\n          function removeClass(elm, classes) {\n            addOrRemoveClasses(elm, classes, true);\n          }\n          /**\r\n           * Verify if the provided element has the class or not.\r\n           *\r\n           * @param {Element} elm       - An element.\r\n           * @param {string}  className - A class name.\r\n           *\r\n           * @return {boolean} - True if the element has the class or false if not.\r\n           */\n\n\n          function hasClass(elm, className) {\n            return !!elm && elm.classList.contains(className);\n          }\n          /**\r\n           * Set attribute to the given element.\r\n           *\r\n           * @param {Element}                 elm   - An element where an attribute is assigned.\r\n           * @param {string}                  name  - Attribute name.\r\n           * @param {string|number|boolean}   value - Attribute value.\r\n           */\n\n\n          function setAttribute(elm, name, value) {\n            if (elm) {\n              elm.setAttribute(name, value);\n            }\n          }\n          /**\r\n           * Get attribute from the given element.\r\n           *\r\n           * @param {Element} elm  - An element where an attribute is assigned.\r\n           * @param {string}  name - Attribute name.\r\n           *\r\n           * @return {string} - The value of the given attribute if available. An empty string if not.\r\n           */\n\n\n          function getAttribute(elm, name) {\n            return elm ? elm.getAttribute(name) : '';\n          }\n          /**\r\n           * Remove attribute from the given element.\r\n           *\r\n           * @param {Element|Element[]} elms  - An element where an attribute is removed.\r\n           * @param {string|string[]}      names - Attribute name.\r\n           */\n\n\n          function removeAttribute(elms, names) {\n            toArray(names).forEach(function (name) {\n              toArray(elms).forEach(function (elm) {\n                return elm && elm.removeAttribute(name);\n              });\n            });\n          }\n          /**\r\n           * Return the Rect object of the provided object.\r\n           *\r\n           * @param {Element} elm - An element.\r\n           *\r\n           * @return {ClientRect|DOMRect} - A rect object.\r\n           */\n\n\n          function getRect(elm) {\n            return elm.getBoundingClientRect();\n          }\n          /**\r\n           * Trigger the given callback after all images contained by the element are loaded.\r\n           *\r\n           * @param {Element}  elm      - Element that may contain images.\r\n           * @param {Function} callback - Callback function fired right after all images are loaded.\r\n           */\n\n\n          function loaded(elm, callback) {\n            var images = elm.querySelectorAll('img');\n            var length = images.length;\n\n            if (length) {\n              var count = 0;\n              each(images, function (img) {\n                img.onload = img.onerror = function () {\n                  if (++count === length) {\n                    callback();\n                  }\n                };\n              });\n            } else {\n              // Trigger the callback immediately if there is no image.\n              callback();\n            }\n          }\n\n          ; // CONCATENATED MODULE: ./src/js/constants/types.js\n\n          /**\r\n           * Export slider types.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Normal slider.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var SLIDE = 'slide';\n          /**\r\n           * Loop after the last slide and before the first one.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var LOOP = 'loop';\n          /**\r\n           * The track doesn't move.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var FADE = 'fade';\n          ; // CONCATENATED MODULE: ./src/js/transitions/slide/index.js\n\n          /**\r\n           * The component for general slide effect transition.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The component for general slide effect transition.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          const slide = function (Splide, Components) {\n            /**\r\n             * Hold the list element.\r\n             *\r\n             * @type {Element}\r\n             */\n            var list;\n            /**\r\n             * Hold the onEnd callback function.\r\n             *\r\n             * @type {function}\r\n             */\n\n            var endCallback;\n            return {\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                list = Components.Elements.list;\n                Splide.on('transitionend', function (e) {\n                  if (e.target === list && endCallback) {\n                    endCallback();\n                  }\n                }, list);\n              },\n\n              /**\r\n               * Start transition.\r\n               *\r\n               * @param {number}   destIndex - Destination slide index that might be clone's.\r\n               * @param {number}   newIndex  - New index.\r\n               * @param {number}   prevIndex - Previous index.\r\n               * @param {Object}   coord     - Destination coordinates.\r\n               * @param {function} done      - Callback function must be invoked when transition is completed.\r\n               */\n              start: function start(destIndex, newIndex, prevIndex, coord, done) {\n                var options = Splide.options;\n                var edgeIndex = Components.Controller.edgeIndex;\n                var speed = options.speed;\n                endCallback = done;\n\n                if (Splide.is(SLIDE)) {\n                  if (prevIndex === 0 && newIndex >= edgeIndex || prevIndex >= edgeIndex && newIndex === 0) {\n                    speed = options.rewindSpeed || speed;\n                  }\n                }\n\n                applyStyle(list, {\n                  transition: \"transform \" + speed + \"ms \" + options.easing,\n                  transform: \"translate(\" + coord.x + \"px,\" + coord.y + \"px)\"\n                });\n              }\n            };\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/transitions/fade/index.js\n\n          /**\r\n           * The component for fade transition.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The component for fade transition.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          const fade = function (Splide, Components) {\n            var Fade = {\n              /**\r\n               * Called when the component is mounted.\r\n               * Apply transition style to the first slide.\r\n               */\n              mount: function mount() {\n                apply(Splide.index);\n              },\n\n              /**\r\n               * Start transition.\r\n               *\r\n               * @param {number}    destIndex - Destination slide index that might be clone's.\r\n               * @param {number}    newIndex  - New index.\r\n               * @param {number}    prevIndex - Previous index.\r\n               * @param {Object}    coord     - Destination coordinates.\r\n               * @param {function}  done      - Callback function must be invoked when transition is completed.\r\n               */\n              start: function start(destIndex, newIndex, prevIndex, coord, done) {\n                var track = Components.Elements.track;\n                applyStyle(track, {\n                  height: unit(track.clientHeight)\n                });\n                apply(newIndex);\n                setTimeout(function () {\n                  done();\n                  applyStyle(track, {\n                    height: ''\n                  });\n                });\n              }\n            };\n            /**\r\n             * Apply transition style to the slide specified by the given index.\r\n             *\r\n             * @param {number} index - A slide index.\r\n             */\n\n            function apply(index) {\n              var options = Splide.options;\n              applyStyle(Components.Elements.slides[index], {\n                transition: \"opacity \" + options.speed + \"ms \" + options.easing\n              });\n            }\n\n            return Fade;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/transitions/index.js\n\n          /**\r\n           * Export transition components.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          ; // CONCATENATED MODULE: ./src/js/core/composer.js\n\n          /**\r\n           * Provide a function for composing components.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Compose components.\r\n           *\r\n           * @param {Splide}   Splide     - Splide instance.\r\n           * @param {Object}   Components - Additional components.\r\n           * @param {function} Transition - Change component for transition.\r\n           *\r\n           * @return {Object} - An object containing all components.\r\n           */\n\n          function compose(Splide, Components, Transition) {\n            var components = {};\n            each(Components, function (Component, name) {\n              components[name] = Component(Splide, components, name.toLowerCase());\n            });\n\n            if (!Transition) {\n              Transition = Splide.is(FADE) ? fade : slide;\n            }\n\n            components.Transition = Transition(Splide, components);\n            return components;\n          }\n\n          ; // CONCATENATED MODULE: ./src/js/utils/error.js\n\n          /**\r\n           * Utility functions for outputting logs.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Prefix of an error massage.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var MESSAGE_PREFIX = '[SPLIDE]';\n          /**\r\n           * Display an error message on the browser console.\r\n           *\r\n           * @param {string} message - An error message.\r\n           */\n\n          function error(message) {\n            console.error(MESSAGE_PREFIX + \" \" + message);\n          }\n          /**\r\n           * Check existence of the given object and throw an error if it doesn't.\r\n           *\r\n           * @throws {Error}\r\n           *\r\n           * @param {*}      subject - A subject to be confirmed.\r\n           * @param {string} message - An error message.\r\n           */\n\n\n          function exist(subject, message) {\n            if (!subject) {\n              throw new Error(message);\n            }\n          }\n\n          ; // CONCATENATED MODULE: ./src/js/constants/classes.js\n\n          /**\r\n           * Export class names.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * A root class name.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var ROOT = 'splide';\n          /**\r\n           * The definition table of all classes for elements.\r\n           * They might be modified by options.\r\n           *\r\n           * @type {Object}\r\n           */\n\n          var ELEMENT_CLASSES = {\n            root: ROOT,\n            slider: ROOT + \"__slider\",\n            track: ROOT + \"__track\",\n            list: ROOT + \"__list\",\n            slide: ROOT + \"__slide\",\n            container: ROOT + \"__slide__container\",\n            arrows: ROOT + \"__arrows\",\n            arrow: ROOT + \"__arrow\",\n            prev: ROOT + \"__arrow--prev\",\n            next: ROOT + \"__arrow--next\",\n            pagination: ROOT + \"__pagination\",\n            page: ROOT + \"__pagination__page\",\n            clone: ROOT + \"__slide--clone\",\n            progress: ROOT + \"__progress\",\n            bar: ROOT + \"__progress__bar\",\n            autoplay: ROOT + \"__autoplay\",\n            play: ROOT + \"__play\",\n            pause: ROOT + \"__pause\",\n            spinner: ROOT + \"__spinner\",\n            sr: ROOT + \"__sr\"\n          };\n          /**\r\n           * Definitions of status classes.\r\n           *\r\n           * @type {Object}\r\n           */\n\n          var STATUS_CLASSES = {\n            active: 'is-active',\n            visible: 'is-visible',\n            loading: 'is-loading'\n          };\n          ; // CONCATENATED MODULE: ./src/js/constants/i18n.js\n\n          /**\r\n           * Export i18n texts as object.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Texts for i18n.\r\n           *\r\n           * @type {Object}\r\n           */\n\n          var I18N = {\n            prev: 'Previous slide',\n            next: 'Next slide',\n            first: 'Go to first slide',\n            last: 'Go to last slide',\n            slideX: 'Go to slide %s',\n            pageX: 'Go to page %s',\n            play: 'Start autoplay',\n            pause: 'Pause autoplay'\n          };\n          ; // CONCATENATED MODULE: ./src/js/constants/defaults.js\n\n          /**\r\n           * Export default options.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          var DEFAULTS = {\n            /**\r\n             * Determine a slider type.\r\n             * - 'slide': Regular slider.\r\n             * - 'loop' : Carousel slider.\r\n             * - 'fade' : Change slides with fade transition. perPage, drag options are ignored.\r\n             *\r\n             * @type {string}\r\n             */\n            type: 'slide',\n\n            /**\r\n             * Whether to rewind a slider before the first slide or after the last one.\r\n             * In \"loop\" mode, this option is ignored.\r\n             *\r\n             * @type {boolean}\r\n             */\n            rewind: false,\n\n            /**\r\n             * Transition speed in milliseconds.\r\n             *\r\n             * @type {number}\r\n             */\n            speed: 400,\n\n            /**\r\n             * Transition speed on rewind in milliseconds.\r\n             *\r\n             * @type {number}\r\n             */\n            rewindSpeed: 0,\n\n            /**\r\n             * Whether to prevent any actions while a slider is transitioning.\r\n             * If false, navigation, drag and swipe work while the slider is running.\r\n             * Even so, it will be forced to wait for transition in some cases in the loop mode to shift a slider.\r\n             *\r\n             * @type {boolean}\r\n             */\n            waitForTransition: true,\n\n            /**\r\n             * Define slider max width.\r\n             *\r\n             * @type {number}\r\n             */\n            width: 0,\n\n            /**\r\n             * Define slider height.\r\n             *\r\n             * @type {number}\r\n             */\n            height: 0,\n\n            /**\r\n             * Fix width of slides. CSS format is allowed such as 10em, 80% or 80vw.\r\n             * perPage number will be ignored when this option is falsy.\r\n             *\r\n             * @type {number|string}\r\n             */\n            fixedWidth: 0,\n\n            /**\r\n             * Fix height of slides. CSS format is allowed such as 10em, 80vh but % unit is not accepted.\r\n             * heightRatio option will be ignored when this option is falsy.\r\n             *\r\n             * @type {number|string}\r\n             */\n            fixedHeight: 0,\n\n            /**\r\n             * Determine height of slides by ratio to a slider width.\r\n             * This will be ignored when the fixedHeight is provided.\r\n             *\r\n             * @type {number}\r\n             */\n            heightRatio: 0,\n\n            /**\r\n             * If true, slide width will be determined by the element width itself.\r\n             * - perPage/perMove should be 1.\r\n             *\r\n             * @type {boolean}\r\n             */\n            autoWidth: false,\n\n            /**\r\n             * If true, slide height will be determined by the element width itself.\r\n             * - perPage/perMove should be 1.\r\n             *\r\n             * @type {boolean}\r\n             */\n            autoHeight: false,\n\n            /**\r\n             * Determine how many slides should be displayed per page.\r\n             *\r\n             * @type {number}\r\n             */\n            perPage: 1,\n\n            /**\r\n             * Determine how many slides should be moved when a slider goes to next or perv.\r\n             *\r\n             * @type {number}\r\n             */\n            perMove: 0,\n\n            /**\r\n             * Determine manually how many clones should be generated on the left and right side.\r\n             * The total number of clones will be twice of this number.\r\n             *\r\n             * @type {number}\r\n             */\n            clones: 0,\n\n            /**\r\n             * Start index.\r\n             *\r\n             * @type {number}\r\n             */\n            start: 0,\n\n            /**\r\n             * Determine which slide should be focused if there are multiple slides in a page.\r\n             * A string \"center\" is acceptable for centering slides.\r\n             *\r\n             * @type {boolean|number|string}\r\n             */\n            focus: false,\n\n            /**\r\n             * Gap between slides. CSS format is allowed such as 1em.\r\n             *\r\n             * @type {number|string}\r\n             */\n            gap: 0,\n\n            /**\r\n             * Set padding-left/right in horizontal mode or padding-top/bottom in vertical one.\r\n             * Give a single value to set a same size for both sides or\r\n             * do an object for different sizes.\r\n             * Also, CSS format is allowed such as 1em.\r\n             *\r\n             * @example\r\n             * - 10: Number\r\n             * - '1em': CSS format.\r\n             * - { left: 0, right: 20 }: Object for different sizes in horizontal mode.\r\n             * - { top: 0, bottom: 20 }: Object for different sizes in vertical mode.\r\n             *\r\n             * @type {number|string|Object}\r\n             */\n            padding: 0,\n\n            /**\r\n             * Whether to append arrows.\r\n             *\r\n             * @type {boolean}\r\n             */\n            arrows: true,\n\n            /**\r\n             * Change the arrow SVG path like 'm7.61 0.807-2.12...'.\r\n             *\r\n             * @type {string}\r\n             */\n            arrowPath: '',\n\n            /**\r\n             * Whether to append pagination(indicator dots) or not.\r\n             *\r\n             * @type {boolean}\r\n             */\n            pagination: true,\n\n            /**\r\n             * Activate autoplay.\r\n             *\r\n             * @type {boolean}\r\n             */\n            autoplay: false,\n\n            /**\r\n             * Autoplay interval in milliseconds.\r\n             *\r\n             * @type {number}\r\n             */\n            interval: 5000,\n\n            /**\r\n             * Whether to stop autoplay when a slider is hovered.\r\n             *\r\n             * @type {boolean}\r\n             */\n            pauseOnHover: true,\n\n            /**\r\n             * Whether to stop autoplay when a slider elements are focused.\r\n             * True is recommended for accessibility.\r\n             *\r\n             * @type {boolean}\r\n             */\n            pauseOnFocus: true,\n\n            /**\r\n             * Whether to reset progress of the autoplay timer when resumed.\r\n             *\r\n             * @type {boolean}\r\n             */\n            resetProgress: true,\n\n            /**\r\n             * Loading images lazily.\r\n             * Image src must be provided by a data-splide-lazy attribute.\r\n             *\r\n             * - false: Do nothing.\r\n             * - 'nearby': Only images around an active slide will be loaded.\r\n             * - 'sequential': All images will be sequentially loaded.\r\n             *\r\n             * @type {boolean|string}\r\n             */\n            lazyLoad: false,\n\n            /**\r\n             * This option works only when a lazyLoad option is \"nearby\".\r\n             * Determine how many pages(not slides) around an active slide should be loaded beforehand.\r\n             *\r\n             * @type {number}\r\n             */\n            preloadPages: 1,\n\n            /**\r\n             * Easing for CSS transition. For example, linear, ease or cubic-bezier().\r\n             *\r\n             * @type {string}\r\n             */\n            easing: 'cubic-bezier(.42,.65,.27,.99)',\n\n            /**\r\n             * Whether to enable keyboard shortcuts\r\n             * - true or 'global': Listen to keydown event of the document.\r\n             * - 'focused': Listen to the keydown event of the slider root element. tabindex=\"0\" will be added to the element.\r\n             * - false: Disable keyboard shortcuts.\r\n             *\r\n             * @type {boolean|string}\r\n             */\n            keyboard: 'global',\n\n            /**\r\n             * Whether to allow mouse drag and touch swipe.\r\n             *\r\n             * @type {boolean}\r\n             */\n            drag: true,\n\n            /**\r\n             * The angle threshold for drag.\r\n             * The slider starts moving only when the drag angle is less than this threshold.\r\n             *\r\n             * @type {number}\r\n             */\n            dragAngleThreshold: 30,\n\n            /**\r\n             * Distance threshold for determining if the action is \"flick\" or \"swipe\".\r\n             * When a drag distance is over this value, the action will be treated as \"swipe\", not \"flick\".\r\n             *\r\n             * @type {number}\r\n             */\n            swipeDistanceThreshold: 150,\n\n            /**\r\n             * Velocity threshold for determining if the action is \"flick\" or \"swipe\".\r\n             * Around 0.5 is recommended.\r\n             *\r\n             * @type {number}\r\n             */\n            flickVelocityThreshold: .6,\n\n            /**\r\n             * Determine power of flick. The larger number this is, the farther a slider runs by flick.\r\n             * Around 500 is recommended.\r\n             *\r\n             * @type {number}\r\n             */\n            flickPower: 600,\n\n            /**\r\n             * Limit a number of pages to move by flick.\r\n             *\r\n             * @type {number}\r\n             */\n            flickMaxPages: 1,\n\n            /**\r\n             * Slider direction.\r\n             * - 'ltr': Left to right.\r\n             * - 'rtl': Right to left.\r\n             * - 'ttb': Top to bottom.\r\n             *\r\n             * @type {string}\r\n             */\n            direction: 'ltr',\n\n            /**\r\n             * Set img src to background-image of its parent element.\r\n             * Images with various sizes can be displayed as same dimension without cropping work.\r\n             * fixedHeight or heightRatio is required.\r\n             *\r\n             * @type {boolean}\r\n             */\n            cover: false,\n\n            /**\r\n             * Whether to enable accessibility(aria and screen reader texts) or not.\r\n             *\r\n             * @type {boolean}\r\n             */\n            accessibility: true,\n\n            /**\r\n             * Whether to add tabindex=\"0\" to visible slides or not.\r\n             *\r\n             * @type {boolean}\r\n             */\n            slideFocus: true,\n\n            /**\r\n             * Determine if a slider is navigation for another.\r\n             * Use \"sync\" API to synchronize two sliders.\r\n             *\r\n             * @type {boolean}\r\n             */\n            isNavigation: false,\n\n            /**\r\n             * Whether to trim spaces before the fist slide or after the last one when \"focus\" is not 0.\r\n             *\r\n             * @type {boolean}\r\n             */\n            trimSpace: true,\n\n            /**\r\n             * The \"is-active\" class is added after transition as default.\r\n             * If true, it will be added before move.\r\n             *\r\n             * @type {boolean}\r\n             */\n            updateOnMove: false,\n\n            /**\r\n             * Throttle duration in milliseconds for the resize event.\r\n             *\r\n             * @type {number}\r\n             */\n            throttle: 100,\n\n            /**\r\n             * Whether to destroy a slider or not.\r\n             *\r\n             * @type {boolean}\r\n             */\n            destroy: false,\n\n            /**\r\n             * Options for specific breakpoints.\r\n             *\r\n             * @example\r\n             * {\r\n             *   1000: {\r\n             *     perPage: 3,\r\n             *     gap: 20\r\n             *   },\r\n             *   600: {\r\n             *     perPage: 1,\r\n             *     gap: 5,\r\n             *   }\r\n             * }\r\n             *\r\n             * @type {boolean|Object}\r\n             */\n            breakpoints: false,\n\n            /**\r\n             * Collection of class names.\r\n             *\r\n             * @see ./classes.js\r\n             *\r\n             * @type {Object}\r\n             */\n            classes: ELEMENT_CLASSES,\n\n            /**\r\n             * Collection of i18n texts.\r\n             *\r\n             * @see ./i18n.js\r\n             *\r\n             * @type {Object}\r\n             */\n            i18n: I18N\n          };\n          ; // CONCATENATED MODULE: ./src/js/constants/states.js\n\n          /**\r\n           * Export state constants.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Splide has been just created.\r\n           *\r\n           * @type {number}\r\n           */\n\n          var CREATED = 1;\n          /**\r\n           * All components have been mounted and initialized.\r\n           *\r\n           * @type {number}\r\n           */\n\n          var MOUNTED = 2;\n          /**\r\n           * Splide is ready for transition.\r\n           *\r\n           * @type {number}\r\n           */\n\n          var IDLE = 3;\n          /**\r\n           * Splide is moving.\r\n           *\r\n           * @type {number}\r\n           */\n\n          var MOVING = 4;\n          /**\r\n           * Splide is moving.\r\n           *\r\n           * @type {number}\r\n           */\n\n          var DESTROYED = 5;\n          ; // CONCATENATED MODULE: ./src/js/splide.js\n\n          function _defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n              var descriptor = props[i];\n              descriptor.enumerable = descriptor.enumerable || false;\n              descriptor.configurable = true;\n              if (\"value\" in descriptor) descriptor.writable = true;\n              Object.defineProperty(target, descriptor.key, descriptor);\n            }\n          }\n\n          function _createClass(Constructor, protoProps, staticProps) {\n            if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) _defineProperties(Constructor, staticProps);\n            return Constructor;\n          }\n          /**\r\n           * The main class for applying Splide to an element.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The main class for applying Splide to an element,\r\n           * providing some APIs to control the behavior.\r\n           */\n\n\n          var Splide = /*#__PURE__*/function () {\n            /**\r\n             * Splide constructor.\r\n             *\r\n             * @throws {Error} When the given root element or selector is invalid.\r\n             *\r\n             * @param {Element|string}  root       - A selector for a root element or an element itself.\r\n             * @param {Object}          options    - Optional. Options to change default behaviour.\r\n             * @param {Object}          Components - Optional. Components.\r\n             */\n            function Splide(root, options, Components) {\n              if (options === void 0) {\n                options = {};\n              }\n\n              if (Components === void 0) {\n                Components = {};\n              }\n\n              this.root = root instanceof Element ? root : document.querySelector(root);\n              exist(this.root, 'An invalid element/selector was given.');\n              this.Components = null;\n              this.Event = core_event();\n              this.State = state(CREATED);\n              this.STATES = states_namespaceObject;\n              this._o = merge(DEFAULTS, options);\n              this._i = 0;\n              this._c = Components;\n              this._e = {}; // Extensions\n\n              this._t = null; // Transition\n            }\n            /**\r\n             * Compose and mount components.\r\n             *\r\n             * @param {Object}   Extensions - Optional. Additional components.\r\n             * @param {function} Transition - Optional. Set a custom transition component.\r\n             *\r\n             * @return {Splide|undefined} - This instance or undefined if an exception occurred.\r\n             */\n\n\n            var _proto = Splide.prototype;\n\n            _proto.mount = function mount(Extensions, Transition) {\n              var _this = this;\n\n              if (Extensions === void 0) {\n                Extensions = this._e;\n              }\n\n              if (Transition === void 0) {\n                Transition = this._t;\n              } // Reset the state.\n\n\n              this.State.set(CREATED);\n              this._e = Extensions;\n              this._t = Transition;\n              this.Components = compose(this, merge(this._c, Extensions), Transition);\n\n              try {\n                each(this.Components, function (component, key) {\n                  var required = component.required;\n\n                  if (required === undefined || required) {\n                    component.mount && component.mount();\n                  } else {\n                    delete _this.Components[key];\n                  }\n                });\n              } catch (e) {\n                error(e.message);\n                return;\n              }\n\n              var State = this.State;\n              State.set(MOUNTED);\n              each(this.Components, function (component) {\n                component.mounted && component.mounted();\n              });\n              this.emit('mounted');\n              State.set(IDLE);\n              this.emit('ready');\n              applyStyle(this.root, {\n                visibility: 'visible'\n              });\n              this.on('move drag', function () {\n                return State.set(MOVING);\n              }).on('moved dragged', function () {\n                return State.set(IDLE);\n              });\n              return this;\n            }\n            /**\r\n             * Set sync target.\r\n             *\r\n             * @param {Splide} splide - A Splide instance.\r\n             *\r\n             * @return {Splide} - This instance.\r\n             */\n            ;\n\n            _proto.sync = function sync(splide) {\n              this.sibling = splide;\n              return this;\n            }\n            /**\r\n             * Register callback fired on the given event(s).\r\n             *\r\n             * @param {string}   events  - An event name. Use space to separate multiple events.\r\n             *                             Also, namespace is accepted by dot, such as 'resize.{namespace}'.\r\n             * @param {function} handler - A callback function.\r\n             * @param {Element}  elm     - Optional. Native event will be listened to when this arg is provided.\r\n             * @param {Object}   options - Optional. Options for addEventListener.\r\n             *\r\n             * @return {Splide} - This instance.\r\n             */\n            ;\n\n            _proto.on = function on(events, handler, elm, options) {\n              if (elm === void 0) {\n                elm = null;\n              }\n\n              if (options === void 0) {\n                options = {};\n              }\n\n              this.Event.on(events, handler, elm, options);\n              return this;\n            }\n            /**\r\n             * Unsubscribe the given event.\r\n             *\r\n             * @param {string}  events - A event name.\r\n             * @param {Element} elm    - Optional. removeEventListener() will be called when this arg is provided.\r\n             *\r\n             * @return {Splide} - This instance.\r\n             */\n            ;\n\n            _proto.off = function off(events, elm) {\n              if (elm === void 0) {\n                elm = null;\n              }\n\n              this.Event.off(events, elm);\n              return this;\n            }\n            /**\r\n             * Emit an event.\r\n             *\r\n             * @param {string} event - An event name.\r\n             * @param {*}      args  - Any number of arguments passed to handlers.\r\n             */\n            ;\n\n            _proto.emit = function emit(event) {\n              var _this$Event;\n\n              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n              }\n\n              (_this$Event = this.Event).emit.apply(_this$Event, [event].concat(args));\n\n              return this;\n            }\n            /**\r\n             * Go to the slide specified by the given control.\r\n             *\r\n             * @param {string|number} control - A control pattern.\r\n             * @param {boolean}       wait    - Optional. Whether to wait for transition.\r\n             */\n            ;\n\n            _proto.go = function go(control, wait) {\n              if (wait === void 0) {\n                wait = this.options.waitForTransition;\n              }\n\n              if (this.State.is(IDLE) || this.State.is(MOVING) && !wait) {\n                this.Components.Controller.go(control, false);\n              }\n\n              return this;\n            }\n            /**\r\n             * Verify whether the slider type is the given one or not.\r\n             *\r\n             * @param {string} type - A slider type.\r\n             *\r\n             * @return {boolean} - True if the slider type is the provided type or false if not.\r\n             */\n            ;\n\n            _proto.is = function is(type) {\n              return type === this._o.type;\n            }\n            /**\r\n             * Insert a slide.\r\n             *\r\n             * @param {Element|string} slide - A slide element to be added.\r\n             * @param {number}         index - A slide will be added at the position.\r\n             */\n            ;\n\n            _proto.add = function add(slide, index) {\n              if (index === void 0) {\n                index = -1;\n              }\n\n              this.Components.Elements.add(slide, index, this.refresh.bind(this));\n              return this;\n            }\n            /**\r\n             * Remove the slide designated by the index.\r\n             *\r\n             * @param {number} index - A slide index.\r\n             */\n            ;\n\n            _proto.remove = function remove(index) {\n              this.Components.Elements.remove(index);\n              this.refresh();\n              return this;\n            }\n            /**\r\n             * Destroy all Slide objects and clones and recreate them again.\r\n             */\n            ;\n\n            _proto.refresh = function refresh() {\n              this.emit('refresh:before').emit('refresh').emit('resize');\n              return this;\n            }\n            /**\r\n             * Destroy the Splide.\r\n             * \"Completely\" boolean is mainly for breakpoints.\r\n             *\r\n             * @param {boolean} completely - Destroy completely.\r\n             */\n            ;\n\n            _proto.destroy = function destroy(completely) {\n              var _this2 = this;\n\n              if (completely === void 0) {\n                completely = true;\n              } // Postpone destroy because it should be done after mount.\n\n\n              if (this.State.is(CREATED)) {\n                this.on('ready', function () {\n                  return _this2.destroy(completely);\n                });\n                return;\n              }\n\n              values(this.Components).reverse().forEach(function (component) {\n                component.destroy && component.destroy(completely);\n              });\n              this.emit('destroy', completely); // Destroy all event handlers, including ones for native events.\n\n              this.Event.destroy();\n              this.State.set(DESTROYED);\n              return this;\n            }\n            /**\r\n             * Return the current slide index.\r\n             *\r\n             * @return {number} - The current slide index.\r\n             // */\n            ;\n\n            _createClass(Splide, [{\n              key: \"index\",\n              get: function get() {\n                return this._i;\n              }\n              /**\r\n               * Set the current slide index.\r\n               *\r\n               * @param {number|string} index - A new index.\r\n               */\n              ,\n              set: function set(index) {\n                this._i = parseInt(index);\n              }\n              /**\r\n               * Return length of slides.\r\n               * This is an alias of Elements.length.\r\n               *\r\n               * @return {number} - A number of slides.\r\n               */\n\n            }, {\n              key: \"length\",\n              get: function get() {\n                return this.Components.Elements.length;\n              }\n              /**\r\n               * Return options.\r\n               *\r\n               * @return {Object} - Options object.\r\n               */\n\n            }, {\n              key: \"options\",\n              get: function get() {\n                return this._o;\n              }\n              /**\r\n               * Set options with merging the given object to the current one.\r\n               *\r\n               * @param {Object} options - New options.\r\n               */\n              ,\n              set: function set(options) {\n                var created = this.State.is(CREATED);\n\n                if (!created) {\n                  this.emit('update');\n                }\n\n                this._o = merge(this._o, options);\n\n                if (!created) {\n                  this.emit('updated', this._o);\n                }\n              }\n              /**\r\n               * Return the class list.\r\n               * This is an alias of Splide.options.classList.\r\n               *\r\n               * @return {Object} - An object containing all class list.\r\n               */\n\n            }, {\n              key: \"classes\",\n              get: function get() {\n                return this._o.classes;\n              }\n              /**\r\n               * Return the i18n strings.\r\n               * This is an alias of Splide.options.i18n.\r\n               *\r\n               * @return {Object} - An object containing all i18n strings.\r\n               */\n\n            }, {\n              key: \"i18n\",\n              get: function get() {\n                return this._o.i18n;\n              }\n            }]);\n\n            return Splide;\n          }();\n\n          ; // CONCATENATED MODULE: ./src/js/components/options/index.js\n\n          /**\r\n           * The component for initializing options.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The component for initializing options.\r\n           *\r\n           * @param {Splide} Splide - A Splide instance.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          const options = function (Splide) {\n            /**\r\n             * Retrieve options from the data attribute.\r\n             * Note that IE10 doesn't support dataset property.\r\n             *\r\n             * @type {string}\r\n             */\n            var options = getAttribute(Splide.root, 'data-splide');\n\n            if (options) {\n              try {\n                Splide.options = JSON.parse(options);\n              } catch (e) {\n                error(e.message);\n              }\n            }\n\n            return {\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                if (Splide.State.is(CREATED)) {\n                  Splide.index = Splide.options.start;\n                }\n              }\n            };\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/constants/directions.js\n\n          /**\r\n           * Export layout modes.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Enumerate slides from left to right.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var LTR = 'ltr';\n          /**\r\n           * Enumerate slides from right to left.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var RTL = 'rtl';\n          /**\r\n           * Enumerate slides in a col.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var TTB = 'ttb';\n          ; // CONCATENATED MODULE: ./src/js/components/elements/slide.js\n\n          /**\r\n           * The sub component for handling each slide.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Events for restoring original styles.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var STYLE_RESTORE_EVENTS = 'update.slide';\n          /**\r\n           * The sub component for handling each slide.\r\n           *\r\n           * @param {Splide}  Splide    - A Splide instance.\r\n           * @param {number}  index     - An unique slide index.\r\n           * @param {number}  realIndex - Clones should pass a real slide index.\r\n           * @param {Element} slide     - A slide element.\r\n           *\r\n           * @return {Object} - The sub component object.\r\n           */\n\n          /* harmony default export */\n\n          const elements_slide = function (Splide, index, realIndex, slide) {\n            /**\r\n             * Whether to update \"is-active\" class before or after transition.\r\n             *\r\n             * @type {boolean}\r\n             */\n            var updateOnMove = Splide.options.updateOnMove;\n            /**\r\n             * Events when the slide status is updated.\r\n             * Append a namespace to remove listeners later.\r\n             *\r\n             * @type {string}\r\n             */\n\n            var STATUS_UPDATE_EVENTS = 'ready.slide updated.slide resized.slide moved.slide' + (updateOnMove ? ' move.slide' : '');\n            /**\r\n             * Slide sub component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Slide = {\n              /**\r\n               * Slide element.\r\n               *\r\n               * @type {Element}\r\n               */\n              slide: slide,\n\n              /**\r\n               * Slide index.\r\n               *\r\n               * @type {number}\r\n               */\n              index: index,\n\n              /**\r\n               * Real index for clones.\r\n               *\r\n               * @type {number}\r\n               */\n              realIndex: realIndex,\n\n              /**\r\n               * Container element if available.\r\n               *\r\n               * @type {Element|undefined}\r\n               */\n              container: child(slide, Splide.classes.container),\n\n              /**\r\n               * Whether this is a cloned slide or not.\r\n               *\r\n               * @type {boolean}\r\n               */\n              isClone: realIndex > -1,\n\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                var _this = this;\n\n                if (!this.isClone) {\n                  slide.id = Splide.root.id + \"-slide\" + pad(index + 1);\n                }\n\n                Splide.on(STATUS_UPDATE_EVENTS, function () {\n                  return _this.update();\n                }).on(STYLE_RESTORE_EVENTS, restoreStyles).on('click', function () {\n                  return Splide.emit('click', _this);\n                }, slide);\n                /*\r\n                 * Add \"is-active\" class to a clone element temporarily\r\n                 * and it will be removed on \"moved\" event.\r\n                 */\n\n                if (updateOnMove) {\n                  Splide.on('move.slide', function (newIndex) {\n                    if (newIndex === realIndex) {\n                      _update(true, false);\n                    }\n                  });\n                } // Make sure the slide is shown.\n\n\n                applyStyle(slide, {\n                  display: ''\n                }); // Hold the original styles.\n\n                this.styles = getAttribute(slide, 'style') || '';\n              },\n\n              /**\r\n               * Destroy.\r\n               */\n              destroy: function destroy() {\n                Splide.off(STATUS_UPDATE_EVENTS).off(STYLE_RESTORE_EVENTS).off('click', slide);\n                removeClass(slide, values(STATUS_CLASSES));\n                restoreStyles();\n                removeAttribute(this.container, 'style');\n              },\n\n              /**\r\n               * Update active and visible status.\r\n               */\n              update: function update() {\n                _update(this.isActive(), false);\n\n                _update(this.isVisible(), true);\n              },\n\n              /**\r\n               * Check whether this slide is active or not.\r\n               *\r\n               * @return {boolean} - True if the slide is active or false if not.\r\n               */\n              isActive: function isActive() {\n                return Splide.index === index;\n              },\n\n              /**\r\n               * Check whether this slide is visible in the viewport or not.\r\n               *\r\n               * @return {boolean} - True if the slide is visible or false if not.\r\n               */\n              isVisible: function isVisible() {\n                var active = this.isActive();\n\n                if (Splide.is(FADE) || active) {\n                  return active;\n                }\n\n                var ceil = Math.ceil;\n                var trackRect = getRect(Splide.Components.Elements.track);\n                var slideRect = getRect(slide);\n\n                if (Splide.options.direction === TTB) {\n                  return trackRect.top <= slideRect.top && slideRect.bottom <= ceil(trackRect.bottom);\n                }\n\n                return trackRect.left <= slideRect.left && slideRect.right <= ceil(trackRect.right);\n              },\n\n              /**\r\n               * Calculate how far this slide is from another slide and\r\n               * return true if the distance is within the given number.\r\n               *\r\n               * @param {number} from   - Index of a target slide.\r\n               * @param {number} within - True if the slide is within this number.\r\n               *\r\n               * @return {boolean} - True if the slide is within the number or false otherwise.\r\n               */\n              isWithin: function isWithin(from, within) {\n                var diff = Math.abs(from - index);\n\n                if (!Splide.is(SLIDE) && !this.isClone) {\n                  diff = Math.min(diff, Splide.length - diff);\n                }\n\n                return diff < within;\n              }\n            };\n            /**\r\n             * Update classes for activity or visibility.\r\n             *\r\n             * @param {boolean} active        - Is active/visible or not.\r\n             * @param {boolean} forVisibility - Toggle classes for activity or visibility.\r\n             */\n\n            function _update(active, forVisibility) {\n              var type = forVisibility ? 'visible' : 'active';\n              var className = STATUS_CLASSES[type];\n\n              if (active) {\n                addClass(slide, className);\n                Splide.emit(\"\" + type, Slide);\n              } else {\n                if (hasClass(slide, className)) {\n                  removeClass(slide, className);\n                  Splide.emit(\"\" + (forVisibility ? 'hidden' : 'inactive'), Slide);\n                }\n              }\n            }\n            /**\r\n             * Restore the original styles.\r\n             */\n\n\n            function restoreStyles() {\n              setAttribute(slide, 'style', Slide.styles);\n            }\n\n            return Slide;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/elements/index.js\n\n          /**\r\n           * The component for main elements.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The property name for UID stored in a window object.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var UID_NAME = 'uid';\n          /**\r\n           * The component for main elements.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          const components_elements = function (Splide, Components) {\n            /**\r\n             * Hold the root element.\r\n             *\r\n             * @type {Element}\r\n             */\n            var root = Splide.root;\n            /**\r\n             * Hold the class list.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var classes = Splide.classes;\n            /**\r\n             * Store Slide objects.\r\n             *\r\n             * @type {Array}\r\n             */\n\n            var Slides = [];\n            /*\r\n             * Assign unique ID to the root element if it doesn't have the one.\r\n             * Note that IE doesn't support padStart() to fill the uid by 0.\r\n             */\n\n            if (!root.id) {\n              window.splide = window.splide || {};\n              var uid = window.splide[UID_NAME] || 0;\n              window.splide[UID_NAME] = ++uid;\n              root.id = \"splide\" + pad(uid);\n            }\n            /**\r\n             * Elements component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n\n            var Elements = {\n              /**\r\n               * Called when the component is mounted.\r\n               * Collect main elements and store them as member properties.\r\n               */\n              mount: function mount() {\n                var _this = this;\n\n                this.init();\n                Splide.on('refresh', function () {\n                  _this.destroy();\n\n                  _this.init();\n                }).on('updated', function () {\n                  removeClass(root, getClasses());\n                  addClass(root, getClasses());\n                });\n              },\n\n              /**\r\n               * Destroy.\r\n               */\n              destroy: function destroy() {\n                Slides.forEach(function (Slide) {\n                  Slide.destroy();\n                });\n                Slides = [];\n                removeClass(root, getClasses());\n              },\n\n              /**\r\n               * Initialization.\r\n               */\n              init: function init() {\n                var _this2 = this;\n\n                collect();\n                addClass(root, getClasses());\n                this.slides.forEach(function (slide, index) {\n                  _this2.register(slide, index, -1);\n                });\n              },\n\n              /**\r\n               * Register a slide to create a Slide object and handle its behavior.\r\n               *\r\n               * @param {Element} slide     - A slide element.\r\n               * @param {number}  index     - A unique index. This can be negative.\r\n               * @param {number}  realIndex - A real index for clones. Set -1 for real slides.\r\n               */\n              register: function register(slide, index, realIndex) {\n                var SlideObject = elements_slide(Splide, index, realIndex, slide);\n                SlideObject.mount();\n                Slides.push(SlideObject);\n              },\n\n              /**\r\n               * Return the Slide object designated by the index.\r\n               * Note that \"find\" is not supported by IE.\r\n               *\r\n               * @return {Object|undefined} - A Slide object if available. Undefined if not.\r\n               */\n              getSlide: function getSlide(index) {\n                return Slides.filter(function (Slide) {\n                  return Slide.index === index;\n                })[0];\n              },\n\n              /**\r\n               * Return all Slide objects.\r\n               *\r\n               * @param {boolean} includeClones - Whether to include cloned slides or not.\r\n               *\r\n               * @return {Object[]} - Slide objects.\r\n               */\n              getSlides: function getSlides(includeClones) {\n                return includeClones ? Slides : Slides.filter(function (Slide) {\n                  return !Slide.isClone;\n                });\n              },\n\n              /**\r\n               * Return Slide objects belonging to the given page.\r\n               *\r\n               * @param {number} page - A page number.\r\n               *\r\n               * @return {Object[]} - An array containing Slide objects.\r\n               */\n              getSlidesByPage: function getSlidesByPage(page) {\n                var idx = Components.Controller.toIndex(page);\n                var options = Splide.options;\n                var max = options.focus !== false ? 1 : options.perPage;\n                return Slides.filter(function (_ref) {\n                  var index = _ref.index;\n                  return idx <= index && index < idx + max;\n                });\n              },\n\n              /**\r\n               * Insert a slide to a slider.\r\n               * Need to refresh Splide after adding a slide.\r\n               *\r\n               * @param {Node|string} slide    - A slide element to be added.\r\n               * @param {number}      index    - A slide will be added at the position.\r\n               * @param {Function}    callback - Called right after the slide is added to the DOM tree.\r\n               */\n              add: function add(slide, index, callback) {\n                if (typeof slide === 'string') {\n                  slide = domify(slide);\n                }\n\n                if (slide instanceof Element) {\n                  var ref = this.slides[index]; // This will be removed in mount() of a Slide component.\n\n                  applyStyle(slide, {\n                    display: 'none'\n                  });\n\n                  if (ref) {\n                    before(slide, ref);\n                    this.slides.splice(index, 0, slide);\n                  } else {\n                    append(this.list, slide);\n                    this.slides.push(slide);\n                  }\n\n                  loaded(slide, function () {\n                    callback && callback(slide);\n                  });\n                }\n              },\n\n              /**\r\n               * Remove a slide from a slider.\r\n               * Need to refresh Splide after removing a slide.\r\n               *\r\n               * @param index - Slide index.\r\n               */\n              remove: function remove(index) {\n                dom_remove(this.slides.splice(index, 1)[0]);\n              },\n\n              /**\r\n               * Trigger the provided callback for each Slide object.\r\n               *\r\n               * @param {Function} callback - A callback function. The first argument will be the Slide object.\r\n               */\n              each: function each(callback) {\n                Slides.forEach(callback);\n              },\n\n              /**\r\n               * Return slides length without clones.\r\n               *\r\n               * @return {number} - Slide length.\r\n               */\n              get length() {\n                return this.slides.length;\n              },\n\n              /**\r\n               * Return \"SlideObjects\" length including clones.\r\n               *\r\n               * @return {number} - Slide length including clones.\r\n               */\n              get total() {\n                return Slides.length;\n              }\n\n            };\n            /**\r\n             * Collect elements.\r\n             */\n\n            function collect() {\n              Elements.slider = child(root, classes.slider);\n              Elements.track = find(root, \".\" + classes.track);\n              Elements.list = child(Elements.track, classes.list);\n              exist(Elements.track && Elements.list, 'Track or list was not found.');\n              Elements.slides = children(Elements.list, classes.slide);\n              var arrows = findParts(classes.arrows);\n              Elements.arrows = {\n                prev: find(arrows, \".\" + classes.prev),\n                next: find(arrows, \".\" + classes.next)\n              };\n              var autoplay = findParts(classes.autoplay);\n              Elements.bar = find(findParts(classes.progress), \".\" + classes.bar);\n              Elements.play = find(autoplay, \".\" + classes.play);\n              Elements.pause = find(autoplay, \".\" + classes.pause);\n              Elements.track.id = Elements.track.id || root.id + \"-track\";\n              Elements.list.id = Elements.list.id || root.id + \"-list\";\n            }\n            /**\r\n             * Return class names for the root element.\r\n             */\n\n\n            function getClasses() {\n              var rootClass = classes.root;\n              var options = Splide.options;\n              return [rootClass + \"--\" + options.type, rootClass + \"--\" + options.direction, options.drag ? rootClass + \"--draggable\" : '', options.isNavigation ? rootClass + \"--nav\" : '', STATUS_CLASSES.active];\n            }\n            /**\r\n             * Find parts only from children of the root or track.\r\n             *\r\n             * @return {Element} - A found element or undefined.\r\n             */\n\n\n            function findParts(className) {\n              return child(root, className) || child(Elements.slider, className);\n            }\n\n            return Elements;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/controller/index.js\n\n          /**\r\n           * The component for controlling the track.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          var floor = Math.floor;\n          /**\r\n           * The component for controlling the track.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          const controller = function (Splide, Components) {\n            /**\r\n             * Store current options.\r\n             *\r\n             * @type {Object}\r\n             */\n            var options;\n            /**\r\n             * True if the slide is LOOP mode.\r\n             *\r\n             * @type {boolean}\r\n             */\n\n            var isLoop;\n            /**\r\n             * Controller component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Controller = {\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                options = Splide.options;\n                isLoop = Splide.is(LOOP);\n                bind();\n              },\n\n              /**\r\n               * Make track run by the given control.\r\n               * - \"+{i}\" : Increment the slide index by i.\r\n               * - \"-{i}\" : Decrement the slide index by i.\r\n               * - \"{i}\"  : Go to the slide whose index is i.\r\n               * - \">\"    : Go to next page.\r\n               * - \"<\"    : Go to prev page.\r\n               * - \">{i}\" : Go to page i.\r\n               *\r\n               * @param {string|number} control  - A control pattern.\r\n               * @param {boolean}       silently - Go to the destination without event emission.\r\n               */\n              go: function go(control, silently) {\n                var destIndex = this.trim(this.parse(control));\n                Components.Track.go(destIndex, this.rewind(destIndex), silently);\n              },\n\n              /**\r\n               * Parse the given control and return the destination index for the track.\r\n               *\r\n               * @param {string} control - A control target pattern.\r\n               *\r\n               * @return {number} - A parsed target.\r\n               */\n              parse: function parse(control) {\n                var index = Splide.index;\n                var matches = String(control).match(/([+\\-<>]+)(\\d+)?/);\n                var indicator = matches ? matches[1] : '';\n                var number = matches ? parseInt(matches[2]) : 0;\n\n                switch (indicator) {\n                  case '+':\n                    index += number || 1;\n                    break;\n\n                  case '-':\n                    index -= number || 1;\n                    break;\n\n                  case '>':\n                  case '<':\n                    index = parsePage(number, index, indicator === '<');\n                    break;\n\n                  default:\n                    index = parseInt(control);\n                }\n\n                return index;\n              },\n\n              /**\r\n               * Compute index from the given page number.\r\n               *\r\n               * @param {number} page - Page number.\r\n               *\r\n               * @return {number} - A computed page number.\r\n               */\n              toIndex: function toIndex(page) {\n                if (hasFocus()) {\n                  return page;\n                }\n\n                var length = Splide.length;\n                var perPage = options.perPage;\n                var index = page * perPage;\n                index = index - (this.pageLength * perPage - length) * floor(index / length); // Adjustment for the last page.\n\n                if (length - perPage <= index && index < length) {\n                  index = length - perPage;\n                }\n\n                return index;\n              },\n\n              /**\r\n               * Compute page number from the given slide index.\r\n               *\r\n               * @param {number} index - Slide index.\r\n               *\r\n               * @return {number} - A computed page number.\r\n               */\n              toPage: function toPage(index) {\n                if (hasFocus()) {\n                  return index;\n                }\n\n                var length = Splide.length;\n                var perPage = options.perPage; // Make the last \"perPage\" number of slides belong to the last page.\n\n                if (length - perPage <= index && index < length) {\n                  return floor((length - 1) / perPage);\n                }\n\n                return floor(index / perPage);\n              },\n\n              /**\r\n               * Trim the given index according to the current mode.\r\n               * Index being returned could be less than 0 or greater than the length in Loop mode.\r\n               *\r\n               * @param {number} index - An index being trimmed.\r\n               *\r\n               * @return {number} - A trimmed index.\r\n               */\n              trim: function trim(index) {\n                if (!isLoop) {\n                  index = options.rewind ? this.rewind(index) : between(index, 0, this.edgeIndex);\n                }\n\n                return index;\n              },\n\n              /**\r\n               * Rewind the given index if it's out of range.\r\n               *\r\n               * @param {number} index - An index.\r\n               *\r\n               * @return {number} - A rewound index.\r\n               */\n              rewind: function rewind(index) {\n                var edge = this.edgeIndex;\n\n                if (isLoop) {\n                  while (index > edge) {\n                    index -= edge + 1;\n                  }\n\n                  while (index < 0) {\n                    index += edge + 1;\n                  }\n                } else {\n                  if (index > edge) {\n                    index = 0;\n                  } else if (index < 0) {\n                    index = edge;\n                  }\n                }\n\n                return index;\n              },\n\n              /**\r\n               * Check if the direction is \"rtl\" or not.\r\n               *\r\n               * @return {boolean} - True if \"rtl\" or false if not.\r\n               */\n              isRtl: function isRtl() {\n                return options.direction === RTL;\n              },\n\n              /**\r\n               * Return the page length.\r\n               *\r\n               * @return {number} - Max page number.\r\n               */\n              get pageLength() {\n                var length = Splide.length;\n                return hasFocus() ? length : Math.ceil(length / options.perPage);\n              },\n\n              /**\r\n               * Return the edge index.\r\n               *\r\n               * @return {number} - Edge index.\r\n               */\n              get edgeIndex() {\n                var length = Splide.length;\n\n                if (!length) {\n                  return 0;\n                }\n\n                if (hasFocus() || options.isNavigation || isLoop) {\n                  return length - 1;\n                }\n\n                return length - options.perPage;\n              },\n\n              /**\r\n               * Return the index of the previous slide.\r\n               *\r\n               * @return {number} - The index of the previous slide if available. -1 otherwise.\r\n               */\n              get prevIndex() {\n                var prev = Splide.index - 1;\n\n                if (isLoop || options.rewind) {\n                  prev = this.rewind(prev);\n                }\n\n                return prev > -1 ? prev : -1;\n              },\n\n              /**\r\n               * Return the index of the next slide.\r\n               *\r\n               * @return {number} - The index of the next slide if available. -1 otherwise.\r\n               */\n              get nextIndex() {\n                var next = Splide.index + 1;\n\n                if (isLoop || options.rewind) {\n                  next = this.rewind(next);\n                }\n\n                return Splide.index < next && next <= this.edgeIndex || next === 0 ? next : -1;\n              }\n\n            };\n            /**\r\n             * Listen to some events.\r\n             */\n\n            function bind() {\n              Splide.on('move', function (newIndex) {\n                Splide.index = newIndex;\n              }).on('updated refresh', function (newOptions) {\n                options = newOptions || options;\n                Splide.index = between(Splide.index, 0, Controller.edgeIndex);\n              });\n            }\n            /**\r\n             * Verify if the focus option is available or not.\r\n             *\r\n             * @return {boolean} - True if a slider has the focus option.\r\n             */\n\n\n            function hasFocus() {\n              return options.focus !== false;\n            }\n            /**\r\n             * Return the next or previous page index computed by the page number and current index.\r\n             *\r\n             * @param {number}  number - Specify the page number.\r\n             * @param {number}  index  - Current index.\r\n             * @param {boolean} prev   - Prev or next.\r\n             *\r\n             * @return {number} - Slide index.\r\n             */\n\n\n            function parsePage(number, index, prev) {\n              if (number > -1) {\n                return Controller.toIndex(number);\n              }\n\n              var perMove = options.perMove;\n              var sign = prev ? -1 : 1;\n\n              if (perMove) {\n                return index + perMove * sign;\n              }\n\n              return Controller.toIndex(Controller.toPage(index) + sign);\n            }\n\n            return Controller;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/track/index.js\n\n          /**\r\n           * The component for moving list in the track.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          var abs = Math.abs;\n          /**\r\n           * The component for moving list in the track.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          const track = function (Splide, Components) {\n            /**\r\n             * Hold the Layout component.\r\n             *\r\n             * @type {Object}\r\n             */\n            var Layout;\n            /**\r\n             * Hold the Layout component.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Elements;\n            /**\r\n             * Store the list element.\r\n             *\r\n             * @type {Element}\r\n             */\n\n            var list;\n            /**\r\n             * Whether the current direction is vertical or not.\r\n             *\r\n             * @type {boolean}\r\n             */\n\n            var isVertical = Splide.options.direction === TTB;\n            /**\r\n             * Whether the slider type is FADE or not.\r\n             *\r\n             * @type {boolean}\r\n             */\n\n            var isFade = Splide.is(FADE);\n            /**\r\n             * Whether the slider direction is RTL or not.\r\n             *\r\n             * @type {boolean}\r\n             */\n\n            var isRTL = Splide.options.direction === RTL;\n            /**\r\n             * This will be true while transitioning from the last index to the first one.\r\n             *\r\n             * @type {boolean}\r\n             */\n\n            var isLoopPending = false;\n            /**\r\n             * Sign for the direction. Only RTL mode uses the positive sign.\r\n             *\r\n             * @type {number}\r\n             */\n\n            var sign = isRTL ? 1 : -1;\n            /**\r\n             * Track component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Track = {\n              /**\r\n               * Make public the sign defined locally.\r\n               *\r\n               * @type {number}\r\n               */\n              sign: sign,\n\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                Elements = Components.Elements;\n                Layout = Components.Layout;\n                list = Elements.list;\n              },\n\n              /**\r\n               * Called after the component is mounted.\r\n               * The resize event must be registered after the Layout's one is done.\r\n               */\n              mounted: function mounted() {\n                var _this = this;\n\n                if (!isFade) {\n                  this.jump(0);\n                  Splide.on('mounted resize updated', function () {\n                    _this.jump(Splide.index);\n                  });\n                }\n              },\n\n              /**\r\n               * Go to the given destination index.\r\n               * After arriving there, the track is jump to the new index without animation, mainly for loop mode.\r\n               *\r\n               * @param {number}  destIndex - A destination index.\r\n               *                              This can be negative or greater than slides length for reaching clones.\r\n               * @param {number}  newIndex  - An actual new index. They are always same in Slide and Rewind mode.\r\n               * @param {boolean} silently  - If true, suppress emitting events.\r\n               */\n              go: function go(destIndex, newIndex, silently) {\n                var newPosition = getTrimmedPosition(destIndex);\n                var prevIndex = Splide.index; // Prevent any actions while transitioning from the last index to the first one for jump.\n\n                if (Splide.State.is(MOVING) && isLoopPending) {\n                  return;\n                }\n\n                isLoopPending = destIndex !== newIndex;\n\n                if (!silently) {\n                  Splide.emit('move', newIndex, prevIndex, destIndex);\n                }\n\n                if (Math.abs(newPosition - this.position) >= 1 || isFade) {\n                  Components.Transition.start(destIndex, newIndex, prevIndex, this.toCoord(newPosition), function () {\n                    onTransitionEnd(destIndex, newIndex, prevIndex, silently);\n                  });\n                } else {\n                  if (destIndex !== prevIndex && Splide.options.trimSpace === 'move') {\n                    Components.Controller.go(destIndex + destIndex - prevIndex, silently);\n                  } else {\n                    onTransitionEnd(destIndex, newIndex, prevIndex, silently);\n                  }\n                }\n              },\n\n              /**\r\n               * Move the track to the specified index.\r\n               *\r\n               * @param {number} index - A destination index where the track jumps.\r\n               */\n              jump: function jump(index) {\n                this.translate(getTrimmedPosition(index));\n              },\n\n              /**\r\n               * Set the list position by CSS translate property.\r\n               *\r\n               * @param {number} position - A new position value.\r\n               */\n              translate: function translate(position) {\n                applyStyle(list, {\n                  transform: \"translate\" + (isVertical ? 'Y' : 'X') + \"(\" + position + \"px)\"\n                });\n              },\n\n              /**\r\n               * Cancel the transition and set the list position.\r\n               * Also, loop the slider if necessary.\r\n               */\n              cancel: function cancel() {\n                if (Splide.is(LOOP)) {\n                  this.shift();\n                } else {\n                  // Ensure the current position.\n                  this.translate(this.position);\n                }\n\n                applyStyle(list, {\n                  transition: ''\n                });\n              },\n\n              /**\r\n               * Shift the slider if it exceeds borders on the edge.\r\n               */\n              shift: function shift() {\n                var position = abs(this.position);\n                var left = abs(this.toPosition(0));\n                var right = abs(this.toPosition(Splide.length));\n                var innerSize = right - left;\n\n                if (position < left) {\n                  position += innerSize;\n                } else if (position > right) {\n                  position -= innerSize;\n                }\n\n                this.translate(sign * position);\n              },\n\n              /**\r\n               * Trim redundant spaces on the left or right edge if necessary.\r\n               *\r\n               * @param {number} position - Position value to be trimmed.\r\n               *\r\n               * @return {number} - Trimmed position.\r\n               */\n              trim: function trim(position) {\n                if (!Splide.options.trimSpace || Splide.is(LOOP)) {\n                  return position;\n                }\n\n                var edge = sign * (Layout.totalSize() - Layout.size - Layout.gap);\n                return between(position, edge, 0);\n              },\n\n              /**\r\n               * Calculate the closest slide index from the given position.\r\n               *\r\n               * @param {number} position - A position converted to an slide index.\r\n               *\r\n               * @return {number} - The closest slide index.\r\n               */\n              toIndex: function toIndex(position) {\n                var _this2 = this;\n\n                var index = 0;\n                var minDistance = Infinity;\n                Elements.getSlides(true).forEach(function (Slide) {\n                  var slideIndex = Slide.index;\n                  var distance = abs(_this2.toPosition(slideIndex) - position);\n\n                  if (distance < minDistance) {\n                    minDistance = distance;\n                    index = slideIndex;\n                  }\n                });\n                return index;\n              },\n\n              /**\r\n               * Return coordinates object by the given position.\r\n               *\r\n               * @param {number} position - A position value.\r\n               *\r\n               * @return {Object} - A coordinates object.\r\n               */\n              toCoord: function toCoord(position) {\n                return {\n                  x: isVertical ? 0 : position,\n                  y: isVertical ? position : 0\n                };\n              },\n\n              /**\r\n               * Calculate the track position by a slide index.\r\n               *\r\n               * @param {number} index - Slide index.\r\n               *\r\n               * @return {Object} - Calculated position.\r\n               */\n              toPosition: function toPosition(index) {\n                var position = Layout.totalSize(index) - Layout.slideSize(index) - Layout.gap;\n                return sign * (position + this.offset(index));\n              },\n\n              /**\r\n               * Return the current offset value, considering direction.\r\n               *\r\n               * @return {number} - Offset amount.\r\n               */\n              offset: function offset(index) {\n                var focus = Splide.options.focus;\n                var slideSize = Layout.slideSize(index);\n\n                if (focus === 'center') {\n                  return -(Layout.size - slideSize) / 2;\n                }\n\n                return -(parseInt(focus) || 0) * (slideSize + Layout.gap);\n              },\n\n              /**\r\n               * Return the current position.\r\n               * This returns the correct position even while transitioning by CSS.\r\n               *\r\n               * @return {number} - Current position.\r\n               */\n              get position() {\n                var prop = isVertical ? 'top' : isRTL ? 'right' : 'left';\n                return getRect(list)[prop] - (getRect(Elements.track)[prop] - Layout.padding[prop] * sign);\n              }\n\n            };\n            /**\r\n             * Called whenever slides arrive at a destination.\r\n             *\r\n             * @param {number}  destIndex - A destination index.\r\n             * @param {number}  newIndex  - A new index.\r\n             * @param {number}  prevIndex - A previous index.\r\n             * @param {boolean} silently  - If true, suppress emitting events.\r\n             */\n\n            function onTransitionEnd(destIndex, newIndex, prevIndex, silently) {\n              applyStyle(list, {\n                transition: ''\n              });\n              isLoopPending = false;\n\n              if (!isFade) {\n                Track.jump(newIndex);\n              }\n\n              if (!silently) {\n                Splide.emit('moved', newIndex, prevIndex, destIndex);\n              }\n            }\n            /**\r\n             * Convert index to the trimmed position.\r\n             *\r\n             * @return {number} - Trimmed position.\r\n             */\n\n\n            function getTrimmedPosition(index) {\n              return Track.trim(Track.toPosition(index));\n            }\n\n            return Track;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/clones/index.js\n\n          /**\r\n           * The component for cloning some slides for \"loop\" mode of the track.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The component for cloning some slides for \"loop\" mode of the track.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          const clones = function (Splide, Components) {\n            /**\r\n             * Store information of all clones.\r\n             *\r\n             * @type {Array}\r\n             */\n            var clones = [];\n            /**\r\n             * Store the current clone count on one side.\r\n             *\r\n             * @type {number}\r\n             */\n\n            var cloneCount = 0;\n            /**\r\n             * Keep Elements component.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Elements = Components.Elements;\n            /**\r\n             * Clones component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Clones = {\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                var _this = this;\n\n                if (Splide.is(LOOP)) {\n                  init();\n                  Splide.on('refresh:before', function () {\n                    _this.destroy();\n                  }).on('refresh', init).on('resize', function () {\n                    if (cloneCount !== getCloneCount()) {\n                      // Destroy before refresh not to collect clones by the Elements component.\n                      _this.destroy();\n\n                      Splide.refresh();\n                    }\n                  });\n                }\n              },\n\n              /**\r\n               * Destroy.\r\n               */\n              destroy: function destroy() {\n                dom_remove(clones);\n                clones = [];\n              },\n\n              /**\r\n               * Return all clones.\r\n               *\r\n               * @return {Element[]} - Cloned elements.\r\n               */\n              get clones() {\n                return clones;\n              },\n\n              /**\r\n               * Return clone length.\r\n               *\r\n               * @return {number} - A length of clones.\r\n               */\n              get length() {\n                return clones.length;\n              }\n\n            };\n            /**\r\n             * Initialization.\r\n             */\n\n            function init() {\n              Clones.destroy();\n              cloneCount = getCloneCount();\n              generateClones(cloneCount);\n            }\n            /**\r\n             * Generate and append/prepend clones.\r\n             *\r\n             * @param {number} count - The half number of clones.\r\n             */\n\n\n            function generateClones(count) {\n              var length = Elements.length,\n                  register = Elements.register;\n\n              if (length) {\n                var slides = Elements.slides;\n\n                while (slides.length < count) {\n                  slides = slides.concat(slides);\n                } // Clones after the last element.\n\n\n                slides.slice(0, count).forEach(function (elm, index) {\n                  var clone = cloneDeeply(elm);\n                  append(Elements.list, clone);\n                  clones.push(clone);\n                  register(clone, index + length, index % length);\n                }); // Clones before the first element.\n\n                slides.slice(-count).forEach(function (elm, index) {\n                  var clone = cloneDeeply(elm);\n                  before(clone, slides[0]);\n                  clones.push(clone);\n                  register(clone, index - count, (length + index - count % length) % length);\n                });\n              }\n            }\n            /**\r\n             * Return half count of clones to be generated.\r\n             * Clone count is determined by:\r\n             * - \"clones\" value in the options.\r\n             * - Number of slides that can be placed in a view in \"fixed\" mode.\r\n             * - Max pages a flick action can move.\r\n             * - Whether the slide length is enough for perPage.\r\n             *\r\n             * @return {number} - Count for clones.\r\n             */\n\n\n            function getCloneCount() {\n              var options = Splide.options;\n\n              if (options.clones) {\n                return options.clones;\n              } // Use the slide length in autoWidth mode because the number cannot be calculated.\n\n\n              var baseCount = options.autoWidth || options.autoHeight ? Elements.length : options.perPage;\n              var dimension = options.direction === TTB ? 'Height' : 'Width';\n              var fixedSize = toPixel(Splide.root, options[\"fixed\" + dimension]);\n\n              if (fixedSize) {\n                // Roughly calculate the count. This needs not to be strict.\n                baseCount = Math.ceil(Elements.track[\"client\" + dimension] / fixedSize);\n              }\n\n              return baseCount * (options.drag ? options.flickMaxPages + 1 : 1);\n            }\n            /**\r\n             * Clone deeply the given element.\r\n             *\r\n             * @param {Element} elm - An element being duplicated.\r\n             *\r\n             * @return {Node} - A cloned node(element).\r\n             */\n\n\n            function cloneDeeply(elm) {\n              var clone = elm.cloneNode(true);\n              addClass(clone, Splide.classes.clone); // ID should not be duplicated.\n\n              removeAttribute(clone, 'id');\n              return clone;\n            }\n\n            return Clones;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/layout/directions/horizontal.js\n\n          /**\r\n           * The resolver component for horizontal layout.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The resolver component for horizontal layout.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           *\r\n           * @return {Object} - The resolver object.\r\n           */\n\n          /* harmony default export */\n\n          const horizontal = function (Splide, Components) {\n            /**\r\n             * Keep the Elements component.\r\n             *\r\n             * @type {string}\r\n             */\n            var Elements = Components.Elements;\n            /**\r\n             * Keep the root element.\r\n             *\r\n             * @type {Element}\r\n             */\n\n            var root = Splide.root;\n            /**\r\n             * Keep the track element.\r\n             *\r\n             * @type {Element}\r\n             */\n\n            var track;\n            /**\r\n             * Keep the latest options.\r\n             *\r\n             * @type {Element}\r\n             */\n\n            var options = Splide.options;\n            return {\n              /**\r\n               * Margin property name.\r\n               *\r\n               * @type {string}\r\n               */\n              margin: 'margin' + (options.direction === RTL ? 'Left' : 'Right'),\n\n              /**\r\n               * Always 0 because the height will be determined by inner contents.\r\n               *\r\n               * @type {number}\r\n               */\n              height: 0,\n\n              /**\r\n               * Initialization.\r\n               */\n              init: function init() {\n                this.resize();\n              },\n\n              /**\r\n               * Resize gap and padding.\r\n               * This must be called on init.\r\n               */\n              resize: function resize() {\n                options = Splide.options;\n                track = Elements.track;\n                this.gap = toPixel(root, options.gap);\n                var padding = options.padding;\n                var left = toPixel(root, padding.left || padding);\n                var right = toPixel(root, padding.right || padding);\n                this.padding = {\n                  left: left,\n                  right: right\n                };\n                applyStyle(track, {\n                  paddingLeft: unit(left),\n                  paddingRight: unit(right)\n                });\n              },\n\n              /**\r\n               * Return total width from the left of the list to the right of the slide specified by the provided index.\r\n               *\r\n               * @param {number} index - Optional. A slide index. If undefined, total width of the slider will be returned.\r\n               *\r\n               * @return {number} - Total width to the right side of the specified slide, or 0 for an invalid index.\r\n               */\n              totalWidth: function totalWidth(index) {\n                if (index === void 0) {\n                  index = Splide.length - 1;\n                }\n\n                var Slide = Elements.getSlide(index);\n                var width = 0;\n\n                if (Slide) {\n                  var slideRect = getRect(Slide.slide);\n                  var listRect = getRect(Elements.list);\n\n                  if (options.direction === RTL) {\n                    width = listRect.right - slideRect.left;\n                  } else {\n                    width = slideRect.right - listRect.left;\n                  }\n\n                  width += this.gap;\n                }\n\n                return width;\n              },\n\n              /**\r\n               * Return the slide width in px.\r\n               *\r\n               * @param {number} index - Slide index.\r\n               *\r\n               * @return {number} - The slide width.\r\n               */\n              slideWidth: function slideWidth(index) {\n                if (options.autoWidth) {\n                  var Slide = Elements.getSlide(index);\n                  return Slide ? Slide.slide.offsetWidth : 0;\n                }\n\n                var width = options.fixedWidth || (this.width + this.gap) / options.perPage - this.gap;\n                return toPixel(root, width);\n              },\n\n              /**\r\n               * Return the slide height in px.\r\n               *\r\n               * @return {number} - The slide height.\r\n               */\n              slideHeight: function slideHeight() {\n                var height = options.height || options.fixedHeight || this.width * options.heightRatio;\n                return toPixel(root, height);\n              },\n\n              /**\r\n               * Return slider width without padding.\r\n               *\r\n               * @return {number} - Current slider width.\r\n               */\n              get width() {\n                return track.clientWidth - this.padding.left - this.padding.right;\n              }\n\n            };\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/layout/directions/vertical.js\n\n          /**\r\n           * The resolver component for vertical layout.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The resolver component for vertical layout.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           *\r\n           * @return {Object} - The resolver object.\r\n           */\n\n          /* harmony default export */\n\n          const vertical = function (Splide, Components) {\n            /**\r\n             * Keep the Elements component.\r\n             *\r\n             * @type {string}\r\n             */\n            var Elements = Components.Elements;\n            /**\r\n             * Keep the root element.\r\n             *\r\n             * @type {Element}\r\n             */\n\n            var root = Splide.root;\n            /**\r\n             * Keep the track element.\r\n             *\r\n             * @type {Element}\r\n             */\n\n            var track;\n            /**\r\n             * Keep the latest options.\r\n             *\r\n             * @type {Element}\r\n             */\n\n            var options;\n            return {\n              /**\r\n               * Margin property name.\r\n               *\r\n               * @type {string}\r\n               */\n              margin: 'marginBottom',\n\n              /**\r\n               * Initialization.\r\n               */\n              init: function init() {\n                this.resize();\n              },\n\n              /**\r\n               * Resize gap and padding.\r\n               * This must be called on init.\r\n               */\n              resize: function resize() {\n                options = Splide.options;\n                track = Elements.track;\n                this.gap = toPixel(root, options.gap);\n                var padding = options.padding;\n                var top = toPixel(root, padding.top || padding);\n                var bottom = toPixel(root, padding.bottom || padding);\n                this.padding = {\n                  top: top,\n                  bottom: bottom\n                };\n                applyStyle(track, {\n                  paddingTop: unit(top),\n                  paddingBottom: unit(bottom)\n                });\n              },\n\n              /**\r\n               * Return total height from the top of the list to the bottom of the slide specified by the provided index.\r\n               *\r\n               * @param {number} index - Optional. A slide index. If undefined, total height of the slider will be returned.\r\n               *\r\n               * @return {number} - Total height to the bottom of the specified slide, or 0 for an invalid index.\r\n               */\n              totalHeight: function totalHeight(index) {\n                if (index === void 0) {\n                  index = Splide.length - 1;\n                }\n\n                var Slide = Elements.getSlide(index);\n\n                if (Slide) {\n                  return getRect(Slide.slide).bottom - getRect(Elements.list).top + this.gap;\n                }\n\n                return 0;\n              },\n\n              /**\r\n               * Return the slide width in px.\r\n               *\r\n               * @return {number} - The slide width.\r\n               */\n              slideWidth: function slideWidth() {\n                return toPixel(root, options.fixedWidth || this.width);\n              },\n\n              /**\r\n               * Return the slide height in px.\r\n               *\r\n               * @param {number} index - Slide index.\r\n               *\r\n               * @return {number} - The slide height.\r\n               */\n              slideHeight: function slideHeight(index) {\n                if (options.autoHeight) {\n                  var Slide = Elements.getSlide(index);\n                  return Slide ? Slide.slide.offsetHeight : 0;\n                }\n\n                var height = options.fixedHeight || (this.height + this.gap) / options.perPage - this.gap;\n                return toPixel(root, height);\n              },\n\n              /**\r\n               * Return slider width without padding.\r\n               *\r\n               * @return {number} - Current slider width.\r\n               */\n              get width() {\n                return track.clientWidth;\n              },\n\n              /**\r\n               * Return slide height without padding.\r\n               *\r\n               * @return {number} - Slider height.\r\n               */\n              get height() {\n                var height = options.height || this.width * options.heightRatio;\n                exist(height, '\"height\" or \"heightRatio\" is missing.');\n                return toPixel(root, height) - this.padding.top - this.padding.bottom;\n              }\n\n            };\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/utils/time.js\n\n          /**\r\n           * A package of utility functions related with time.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Simple throttle function that controls how often the given function is executed.\r\n           *\r\n           * @param {function} func - A function to be throttled.\r\n           * @param {number}   wait - Time in millisecond for interval of execution.\r\n           *\r\n           * @return {Function} - A debounced function.\r\n           */\n\n          function throttle(func, wait) {\n            var timeout; // Declare function by the \"function\" keyword to prevent \"this\" from being inherited.\n\n            return function () {\n              if (!timeout) {\n                timeout = setTimeout(function () {\n                  func();\n                  timeout = null;\n                }, wait);\n              }\n            };\n          }\n          /**\r\n           * Custom setInterval function that provides progress rate as callback.\r\n           *\r\n           * @param {function} callback - A callback function fired every time the interval time passes.\r\n           * @param {number}   interval - Interval duration in milliseconds.\r\n           * @param {function} progress - A callback function fired whenever the progress goes.\r\n           *\r\n           * @return {Object} - An object containing play() and pause() functions.\r\n           */\n\n\n          function createInterval(callback, interval, progress) {\n            var _window = window,\n                requestAnimationFrame = _window.requestAnimationFrame;\n            var start,\n                elapse,\n                rate,\n                _pause = true;\n\n            var step = function step(timestamp) {\n              if (!_pause) {\n                if (!start) {\n                  start = timestamp;\n\n                  if (rate && rate < 1) {\n                    start -= rate * interval;\n                  }\n                }\n\n                elapse = timestamp - start;\n                rate = elapse / interval;\n\n                if (elapse >= interval) {\n                  start = 0;\n                  rate = 1;\n                  callback();\n                }\n\n                if (progress) {\n                  progress(rate);\n                }\n\n                requestAnimationFrame(step);\n              }\n            };\n\n            return {\n              pause: function pause() {\n                _pause = true;\n                start = 0;\n              },\n              play: function play(reset) {\n                start = 0;\n\n                if (reset) {\n                  rate = 0;\n                }\n\n                if (_pause) {\n                  _pause = false;\n                  requestAnimationFrame(step);\n                }\n              }\n            };\n          }\n\n          ; // CONCATENATED MODULE: ./src/js/components/layout/index.js\n\n          /**\r\n           * The component for handing slide layouts and their sizes.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The component for handing slide layouts and their sizes.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          const layout = function (Splide, Components) {\n            /**\r\n             * Keep the Elements component.\r\n             *\r\n             * @type {string}\r\n             */\n            var Elements = Components.Elements;\n            /**\r\n             * Whether the slider is vertical or not.\r\n             *\r\n             * @type {boolean}\r\n             */\n\n            var isVertical = Splide.options.direction === TTB;\n            /**\r\n             * Layout component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Layout = object_assign({\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                bind();\n                init(); // The word \"size\" means width for a horizontal slider and height for a vertical slider.\n\n                this.totalSize = isVertical ? this.totalHeight : this.totalWidth;\n                this.slideSize = isVertical ? this.slideHeight : this.slideWidth;\n              },\n\n              /**\r\n               * Destroy the component.\r\n               */\n              destroy: function destroy() {\n                removeAttribute([Elements.list, Elements.track], 'style');\n              },\n\n              /**\r\n               * Return the slider height on the vertical mode or width on the horizontal mode.\r\n               *\r\n               * @return {number}\r\n               */\n              get size() {\n                return isVertical ? this.height : this.width;\n              }\n\n            }, isVertical ? vertical(Splide, Components) : horizontal(Splide, Components));\n            /**\r\n             * Init slider styles according to options.\r\n             */\n\n            function init() {\n              Layout.init();\n              applyStyle(Splide.root, {\n                maxWidth: unit(Splide.options.width)\n              });\n              Elements.each(function (Slide) {\n                Slide.slide.style[Layout.margin] = unit(Layout.gap);\n              });\n              resize();\n            }\n            /**\r\n             * Listen the resize native event with throttle.\r\n             * Initialize when the component is mounted or options are updated.\r\n             */\n\n\n            function bind() {\n              Splide.on('resize load', throttle(function () {\n                Splide.emit('resize');\n              }, Splide.options.throttle), window).on('resize', resize).on('updated refresh', init);\n            }\n            /**\r\n             * Resize the track and slide elements.\r\n             */\n\n\n            function resize() {\n              var options = Splide.options;\n              Layout.resize();\n              applyStyle(Elements.track, {\n                height: unit(Layout.height)\n              });\n              var slideHeight = options.autoHeight ? null : unit(Layout.slideHeight());\n              Elements.each(function (Slide) {\n                applyStyle(Slide.container, {\n                  height: slideHeight\n                });\n                applyStyle(Slide.slide, {\n                  width: options.autoWidth ? null : unit(Layout.slideWidth(Slide.index)),\n                  height: Slide.container ? null : slideHeight\n                });\n              });\n              Splide.emit('resized');\n            }\n\n            return Layout;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/drag/index.js\n\n          /**\r\n           * The component for supporting mouse drag and swipe.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          var drag_abs = Math.abs;\n          /**\r\n           * If the absolute velocity is greater thant this value,\r\n           * a slider always goes to a different slide after drag, not allowed to stay on a current slide.\r\n           */\n\n          var MIN_VELOCITY = 0.1;\n          /**\r\n           * Adjust how much the track can be pulled on the first or last page.\r\n           * The larger number this is, the farther the track moves.\r\n           * This should be around 5 - 9.\r\n           *\r\n           * @type {number}\r\n           */\n\n          var FRICTION_REDUCER = 7;\n          /**\r\n           * The component supporting mouse drag and swipe.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          const drag = function (Splide, Components) {\n            /**\r\n             * Store the Move component.\r\n             *\r\n             * @type {Object}\r\n             */\n            var Track = Components.Track;\n            /**\r\n             * Store the Controller component.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Controller = Components.Controller;\n            /**\r\n             * Coordinate of the track on starting drag.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var startCoord;\n            /**\r\n             * Analyzed info on starting drag.\r\n             *\r\n             * @type {Object|null}\r\n             */\n\n            var startInfo;\n            /**\r\n             * Analyzed info being updated while dragging/swiping.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var currentInfo;\n            /**\r\n             * Determine whether slides are being dragged or not.\r\n             *\r\n             * @type {boolean}\r\n             */\n\n            var isDragging;\n            /**\r\n             * Whether the slider direction is vertical or not.\r\n             *\r\n             * @type {boolean}\r\n             */\n\n            var isVertical = Splide.options.direction === TTB;\n            /**\r\n             * Axis for the direction.\r\n             *\r\n             * @type {string}\r\n             */\n\n            var axis = isVertical ? 'y' : 'x';\n            /**\r\n             * Drag component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Drag = {\n              /**\r\n               * Whether dragging is disabled or not.\r\n               *\r\n               * @type {boolean}\r\n               */\n              disabled: false,\n\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                var _this = this;\n\n                var Elements = Components.Elements;\n                var track = Elements.track;\n                Splide.on('touchstart mousedown', start, track).on('touchmove mousemove', move, track, {\n                  passive: false\n                }).on('touchend touchcancel mouseleave mouseup dragend', end, track).on('mounted refresh', function () {\n                  // Prevent dragging an image or anchor itself.\n                  each(Elements.list.querySelectorAll('img, a'), function (elm) {\n                    Splide.off('dragstart', elm).on('dragstart', function (e) {\n                      e.preventDefault();\n                    }, elm, {\n                      passive: false\n                    });\n                  });\n                }).on('mounted updated', function () {\n                  _this.disabled = !Splide.options.drag;\n                });\n              }\n            };\n            /**\r\n             * Called when the track starts to be dragged.\r\n             *\r\n             * @param {TouchEvent|MouseEvent} e - TouchEvent or MouseEvent object.\r\n             */\n\n            function start(e) {\n              if (!Drag.disabled && !isDragging) {\n                // These prams are used to evaluate whether the slider should start moving.\n                init(e);\n              }\n            }\n            /**\r\n             * Initialize parameters.\r\n             *\r\n             * @param {TouchEvent|MouseEvent} e - TouchEvent or MouseEvent object.\r\n             */\n\n\n            function init(e) {\n              startCoord = Track.toCoord(Track.position);\n              startInfo = analyze(e, {});\n              currentInfo = startInfo;\n            }\n            /**\r\n             * Called while the track being dragged.\r\n             *\r\n             * @param {TouchEvent|MouseEvent} e - TouchEvent or MouseEvent object.\r\n             */\n\n\n            function move(e) {\n              if (startInfo) {\n                currentInfo = analyze(e, startInfo);\n\n                if (isDragging) {\n                  if (e.cancelable) {\n                    e.preventDefault();\n                  }\n\n                  if (!Splide.is(FADE)) {\n                    var position = startCoord[axis] + currentInfo.offset[axis];\n                    Track.translate(resist(position));\n                  }\n                } else {\n                  if (shouldMove(currentInfo)) {\n                    Splide.emit('drag', startInfo);\n                    isDragging = true;\n                    Track.cancel(); // These params are actual drag data.\n\n                    init(e);\n                  }\n                }\n              }\n            }\n            /**\r\n             * Determine whether to start moving the track or not by drag angle.\r\n             *\r\n             * @param {Object} info - An information object.\r\n             *\r\n             * @return {boolean} - True if the track should be moved or false if not.\r\n             */\n\n\n            function shouldMove(_ref) {\n              var offset = _ref.offset;\n\n              if (Splide.State.is(MOVING) && Splide.options.waitForTransition) {\n                return false;\n              }\n\n              var angle = Math.atan(drag_abs(offset.y) / drag_abs(offset.x)) * 180 / Math.PI;\n\n              if (isVertical) {\n                angle = 90 - angle;\n              }\n\n              return angle < Splide.options.dragAngleThreshold;\n            }\n            /**\r\n             * Resist dragging the track on the first/last page because there is no more.\r\n             *\r\n             * @param {number} position - A position being applied to the track.\r\n             *\r\n             * @return {Object} - Adjusted position.\r\n             */\n\n\n            function resist(position) {\n              if (Splide.is(SLIDE)) {\n                var sign = Track.sign;\n\n                var _start = sign * Track.trim(Track.toPosition(0));\n\n                var _end = sign * Track.trim(Track.toPosition(Controller.edgeIndex));\n\n                position *= sign;\n\n                if (position < _start) {\n                  position = _start - FRICTION_REDUCER * Math.log(_start - position);\n                } else if (position > _end) {\n                  position = _end + FRICTION_REDUCER * Math.log(position - _end);\n                }\n\n                position *= sign;\n              }\n\n              return position;\n            }\n            /**\r\n             * Called when dragging ends.\r\n             */\n\n\n            function end() {\n              startInfo = null;\n\n              if (isDragging) {\n                Splide.emit('dragged', currentInfo);\n                go(currentInfo);\n                isDragging = false;\n              }\n            }\n            /**\r\n             * Go to the slide determined by the analyzed data.\r\n             *\r\n             * @param {Object} info - An info object.\r\n             */\n\n\n            function go(info) {\n              var velocity = info.velocity[axis];\n              var absV = drag_abs(velocity);\n\n              if (absV > 0) {\n                var options = Splide.options;\n                var index = Splide.index;\n                var sign = velocity < 0 ? -1 : 1;\n                var destIndex = index;\n\n                if (!Splide.is(FADE)) {\n                  var destination = Track.position;\n\n                  if (absV > options.flickVelocityThreshold && drag_abs(info.offset[axis]) < options.swipeDistanceThreshold) {\n                    destination += sign * Math.min(absV * options.flickPower, Components.Layout.size * (options.flickMaxPages || 1));\n                  }\n\n                  destIndex = Track.toIndex(destination);\n                }\n                /*\r\n                 * Do not allow the track to go to a previous position if there is enough velocity.\r\n                 * Always use the adjacent index for the fade mode.\r\n                 */\n\n\n                if (destIndex === index && absV > MIN_VELOCITY) {\n                  destIndex = index + sign * Track.sign;\n                }\n\n                if (Splide.is(SLIDE)) {\n                  destIndex = between(destIndex, 0, Controller.edgeIndex);\n                }\n\n                Controller.go(destIndex, options.isNavigation);\n              }\n            }\n            /**\r\n             * Analyze the given event object and return important information for handling swipe behavior.\r\n             *\r\n             * @param {Event}   e          - Touch or Mouse event object.\r\n             * @param {Object}  startInfo  - Information analyzed on start for calculating difference from the current one.\r\n             *\r\n             * @return {Object} - An object containing analyzed information, such as offset, velocity, etc.\r\n             */\n\n\n            function analyze(e, startInfo) {\n              var timeStamp = e.timeStamp,\n                  touches = e.touches;\n\n              var _ref2 = touches ? touches[0] : e,\n                  clientX = _ref2.clientX,\n                  clientY = _ref2.clientY;\n\n              var _ref3 = startInfo.to || {},\n                  _ref3$x = _ref3.x,\n                  fromX = _ref3$x === void 0 ? clientX : _ref3$x,\n                  _ref3$y = _ref3.y,\n                  fromY = _ref3$y === void 0 ? clientY : _ref3$y;\n\n              var startTime = startInfo.time || 0;\n              var offset = {\n                x: clientX - fromX,\n                y: clientY - fromY\n              };\n              var duration = timeStamp - startTime;\n              var velocity = {\n                x: offset.x / duration,\n                y: offset.y / duration\n              };\n              return {\n                to: {\n                  x: clientX,\n                  y: clientY\n                },\n                offset: offset,\n                time: timeStamp,\n                velocity: velocity\n              };\n            }\n\n            return Drag;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/click/index.js\n\n          /**\r\n           * The component for handling a click event.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The component for handling a click event.\r\n           * Click should be disabled during drag/swipe.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          const click = function (Splide, Components) {\n            /**\r\n             * Whether click is disabled or not.\r\n             *\r\n             * @type {boolean}\r\n             */\n            var disabled = false;\n            /**\r\n             * Click component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Click = {\n              /**\r\n               * Mount only when the drag is activated and the slide type is not \"fade\".\r\n               *\r\n               * @type {boolean}\r\n               */\n              required: Splide.options.drag,\n\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                Splide.on('click', onClick, Components.Elements.track, {\n                  capture: true\n                }).on('drag', function () {\n                  disabled = true;\n                }).on('dragged', function () {\n                  // Make sure the flag is released after the click event is fired.\n                  setTimeout(function () {\n                    disabled = false;\n                  });\n                });\n              }\n            };\n            /**\r\n             * Called when a track element is clicked.\r\n             *\r\n             * @param {Event} e - A click event.\r\n             */\n\n            function onClick(e) {\n              if (disabled) {\n                e.preventDefault();\n                e.stopPropagation();\n                e.stopImmediatePropagation();\n              }\n            }\n\n            return Click;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/autoplay/index.js\n\n          /**\r\n           * The component for playing slides automatically.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Set of pause flags.\r\n           */\n\n          var PAUSE_FLAGS = {\n            HOVER: 1,\n            FOCUS: 2,\n            MANUAL: 3\n          };\n          /**\r\n           * The component for playing slides automatically.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           * @param {string} name       - A component name as a lowercase string.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          const autoplay = function (Splide, Components, name) {\n            /**\r\n             * Store pause flags.\r\n             *\r\n             * @type {Array}\r\n             */\n            var flags = [];\n            /**\r\n             * Store an interval object.\r\n             *\r\n             * @type {Object};\r\n             */\n\n            var interval;\n            /**\r\n             * Keep the Elements component.\r\n             *\r\n             * @type {string}\r\n             */\n\n            var Elements = Components.Elements;\n            /**\r\n             * Autoplay component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Autoplay = {\n              /**\r\n               * Required only when the autoplay option is true.\r\n               *\r\n               * @type {boolean}\r\n               */\n              required: Splide.options.autoplay,\n\n              /**\r\n               * Called when the component is mounted.\r\n               * Note that autoplay starts only if there are slides over perPage number.\r\n               */\n              mount: function mount() {\n                var options = Splide.options;\n\n                if (Elements.slides.length > options.perPage) {\n                  interval = createInterval(function () {\n                    Splide.go('>');\n                  }, options.interval, function (rate) {\n                    Splide.emit(name + \":playing\", rate);\n\n                    if (Elements.bar) {\n                      applyStyle(Elements.bar, {\n                        width: rate * 100 + \"%\"\n                      });\n                    }\n                  });\n                  bind();\n                  this.play();\n                }\n              },\n\n              /**\r\n               * Start autoplay.\r\n               *\r\n               * @param {number} flag - A pause flag to be removed.\r\n               */\n              play: function play(flag) {\n                if (flag === void 0) {\n                  flag = 0;\n                }\n\n                flags = flags.filter(function (f) {\n                  return f !== flag;\n                });\n\n                if (!flags.length) {\n                  Splide.emit(name + \":play\");\n                  interval.play(Splide.options.resetProgress);\n                }\n              },\n\n              /**\r\n               * Pause autoplay.\r\n               * Note that Array.includes is not supported by IE.\r\n               *\r\n               * @param {number} flag - A pause flag to be added.\r\n               */\n              pause: function pause(flag) {\n                if (flag === void 0) {\n                  flag = 0;\n                }\n\n                interval.pause();\n\n                if (flags.indexOf(flag) === -1) {\n                  flags.push(flag);\n                }\n\n                if (flags.length === 1) {\n                  Splide.emit(name + \":pause\");\n                }\n              }\n            };\n            /**\r\n             * Listen some events.\r\n             */\n\n            function bind() {\n              var options = Splide.options;\n              var sibling = Splide.sibling;\n              var elms = [Splide.root, sibling ? sibling.root : null];\n\n              if (options.pauseOnHover) {\n                switchOn(elms, 'mouseleave', PAUSE_FLAGS.HOVER, true);\n                switchOn(elms, 'mouseenter', PAUSE_FLAGS.HOVER, false);\n              }\n\n              if (options.pauseOnFocus) {\n                switchOn(elms, 'focusout', PAUSE_FLAGS.FOCUS, true);\n                switchOn(elms, 'focusin', PAUSE_FLAGS.FOCUS, false);\n              }\n\n              if (Elements.play) {\n                Splide.on('click', function () {\n                  // Need to be removed a focus flag at first.\n                  Autoplay.play(PAUSE_FLAGS.FOCUS);\n                  Autoplay.play(PAUSE_FLAGS.MANUAL);\n                }, Elements.play);\n              }\n\n              if (Elements.pause) {\n                switchOn([Elements.pause], 'click', PAUSE_FLAGS.MANUAL, false);\n              }\n\n              Splide.on('move refresh', function () {\n                Autoplay.play();\n              }) // Rewind the timer.\n              .on('destroy', function () {\n                Autoplay.pause();\n              });\n            }\n            /**\r\n             * Play or pause on the given event.\r\n             *\r\n             * @param {Element[]} elms  - Elements.\r\n             * @param {string}    event - An event name or names.\r\n             * @param {number}    flag  - A pause flag defined on the top.\r\n             * @param {boolean}   play  - Determine whether to play or pause.\r\n             */\n\n\n            function switchOn(elms, event, flag, play) {\n              elms.forEach(function (elm) {\n                Splide.on(event, function () {\n                  Autoplay[play ? 'play' : 'pause'](flag);\n                }, elm);\n              });\n            }\n\n            return Autoplay;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/cover/index.js\n\n          /**\r\n           * The component for change an img element to background image of its wrapper.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The component for change an img element to background image of its wrapper.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          const cover = function (Splide, Components) {\n            /**\r\n             * Hold options.\r\n             *\r\n             * @type {Object}\r\n             */\n            var options = Splide.options;\n            /**\r\n             * Cover component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Cover = {\n              /**\r\n               * Required only when \"cover\" option is true.\r\n               *\r\n               * @type {boolean}\r\n               */\n              required: options.cover,\n\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                Splide.on('lazyload:loaded', function (img) {\n                  cover(img, false);\n                });\n                Splide.on('mounted updated refresh', function () {\n                  return apply(false);\n                });\n              },\n\n              /**\r\n               * Destroy.\r\n               */\n              destroy: function destroy() {\n                apply(true);\n              }\n            };\n            /**\r\n             * Apply \"cover\" to all slides.\r\n             *\r\n             * @param {boolean} uncover - If true, \"cover\" will be clear.\r\n             */\n\n            function apply(uncover) {\n              Components.Elements.each(function (Slide) {\n                var img = child(Slide.slide, 'IMG') || child(Slide.container, 'IMG');\n\n                if (img && img.src) {\n                  cover(img, uncover);\n                }\n              });\n            }\n            /**\r\n             * Set background image of the parent element, using source of the given image element.\r\n             *\r\n             * @param {Element} img     - An image element.\r\n             * @param {boolean} uncover - Reset \"cover\".\r\n             */\n\n\n            function cover(img, uncover) {\n              applyStyle(img.parentElement, {\n                background: uncover ? '' : \"center/cover no-repeat url(\\\"\" + img.src + \"\\\")\"\n              });\n              applyStyle(img, {\n                display: uncover ? '' : 'none'\n              });\n            }\n\n            return Cover;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/arrows/path.js\n\n          /**\r\n           * Export vector path for an arrow.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Namespace definition for SVG element.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var XML_NAME_SPACE = 'http://www.w3.org/2000/svg';\n          /**\r\n           * The arrow vector path.\r\n           *\r\n           * @type {number}\r\n           */\n\n          var PATH = 'm15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z';\n          /**\r\n           * SVG width and height.\r\n           *\r\n           * @type {number}\r\n           */\n\n          var SIZE = 40;\n          ; // CONCATENATED MODULE: ./src/js/components/arrows/index.js\n\n          /**\r\n           * The component for appending prev/next arrows.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The component for appending prev/next arrows.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           * @param {string} name       - A component name as a lowercase string.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          const arrows = function (Splide, Components, name) {\n            /**\r\n             * Previous arrow element.\r\n             *\r\n             * @type {Element|undefined}\r\n             */\n            var prev;\n            /**\r\n             * Next arrow element.\r\n             *\r\n             * @type {Element|undefined}\r\n             */\n\n            var next;\n            /**\r\n             * Store the class list.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var classes = Splide.classes;\n            /**\r\n             * Hold the root element.\r\n             *\r\n             * @type {Element}\r\n             */\n\n            var root = Splide.root;\n            /**\r\n             * Whether arrows are created programmatically or not.\r\n             *\r\n             * @type {boolean}\r\n             */\n\n            var created;\n            /**\r\n             * Hold the Elements component.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Elements = Components.Elements;\n            /**\r\n             * Arrows component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Arrows = {\n              /**\r\n               * Required when the arrows option is true.\r\n               *\r\n               * @type {boolean}\r\n               */\n              required: Splide.options.arrows,\n\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                // Attempt to get arrows from HTML source.\n                prev = Elements.arrows.prev;\n                next = Elements.arrows.next; // If arrows were not found in HTML, let's generate them.\n\n                if ((!prev || !next) && Splide.options.arrows) {\n                  prev = createArrow(true);\n                  next = createArrow(false);\n                  created = true;\n                  appendArrows();\n                }\n\n                if (prev && next) {\n                  bind();\n                }\n\n                this.arrows = {\n                  prev: prev,\n                  next: next\n                };\n              },\n\n              /**\r\n               * Called after all components are mounted.\r\n               */\n              mounted: function mounted() {\n                Splide.emit(name + \":mounted\", prev, next);\n              },\n\n              /**\r\n               * Destroy.\r\n               */\n              destroy: function destroy() {\n                removeAttribute([prev, next], 'disabled');\n\n                if (created) {\n                  dom_remove(prev.parentElement);\n                }\n              }\n            };\n            /**\r\n             * Listen to native and custom events.\r\n             */\n\n            function bind() {\n              Splide.on('click', function () {\n                Splide.go('<');\n              }, prev).on('click', function () {\n                Splide.go('>');\n              }, next).on('mounted move updated refresh', updateDisabled);\n            }\n            /**\r\n             * Update a disabled attribute.\r\n             */\n\n\n            function updateDisabled() {\n              var _Components$Controlle = Components.Controller,\n                  prevIndex = _Components$Controlle.prevIndex,\n                  nextIndex = _Components$Controlle.nextIndex;\n              var isEnough = Splide.length > Splide.options.perPage || Splide.is(LOOP);\n              prev.disabled = prevIndex < 0 || !isEnough;\n              next.disabled = nextIndex < 0 || !isEnough;\n              Splide.emit(name + \":updated\", prev, next, prevIndex, nextIndex);\n            }\n            /**\r\n             * Create a wrapper element and append arrows.\r\n             */\n\n\n            function appendArrows() {\n              var wrapper = create('div', {\n                \"class\": classes.arrows\n              });\n              append(wrapper, prev);\n              append(wrapper, next);\n              var slider = Elements.slider;\n              var parent = Splide.options.arrows === 'slider' && slider ? slider : root;\n              before(wrapper, parent.firstElementChild);\n            }\n            /**\r\n             * Create an arrow element.\r\n             *\r\n             * @param {boolean} prev - Determine to create a prev arrow or next arrow.\r\n             *\r\n             * @return {Element} - A created arrow element.\r\n             */\n\n\n            function createArrow(prev) {\n              var arrow = \"<button class=\\\"\" + classes.arrow + \" \" + (prev ? classes.prev : classes.next) + \"\\\" type=\\\"button\\\">\" + (\"<svg xmlns=\\\"\" + XML_NAME_SPACE + \"\\\"\\tviewBox=\\\"0 0 \" + SIZE + \" \" + SIZE + \"\\\"\\twidth=\\\"\" + SIZE + \"\\\"\\theight=\\\"\" + SIZE + \"\\\">\") + (\"<path d=\\\"\" + (Splide.options.arrowPath || PATH) + \"\\\" />\");\n              return domify(arrow);\n            }\n\n            return Arrows;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/pagination/index.js\n\n          /**\r\n           * The component for handling pagination\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The event name for updating some attributes of pagination nodes.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var ATTRIBUTES_UPDATE_EVENT = 'move.page';\n          /**\r\n           * The event name for recreating pagination.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var UPDATE_EVENT = 'updated.page refresh.page';\n          /**\r\n           * The component for handling pagination\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           * @param {string} name       - A component name as a lowercase string.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          const pagination = function (Splide, Components, name) {\n            /**\r\n             * Store all data for pagination.\r\n             * - list: A list element.\r\n             * - items: An array that contains objects(li, button, index, page).\r\n             *\r\n             * @type {Object}\r\n             */\n            var data = {};\n            /**\r\n             * Hold the Elements component.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Elements = Components.Elements;\n            /**\r\n             * Pagination component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Pagination = {\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                var pagination = Splide.options.pagination;\n\n                if (pagination) {\n                  data = createPagination();\n                  var slider = Elements.slider;\n                  var parent = pagination === 'slider' && slider ? slider : Splide.root;\n                  append(parent, data.list);\n                  Splide.on(ATTRIBUTES_UPDATE_EVENT, updateAttributes);\n                }\n\n                Splide.off(UPDATE_EVENT).on(UPDATE_EVENT, function () {\n                  Pagination.destroy();\n\n                  if (Splide.options.pagination) {\n                    Pagination.mount();\n                    Pagination.mounted();\n                  }\n                });\n              },\n\n              /**\r\n               * Called after all components are mounted.\r\n               */\n              mounted: function mounted() {\n                if (Splide.options.pagination) {\n                  var index = Splide.index;\n                  Splide.emit(name + \":mounted\", data, this.getItem(index));\n                  updateAttributes(index, -1);\n                }\n              },\n\n              /**\r\n               * Destroy the pagination.\r\n               * Be aware that node.remove() is not supported by IE.\r\n               */\n              destroy: function destroy() {\n                dom_remove(data.list);\n\n                if (data.items) {\n                  data.items.forEach(function (item) {\n                    Splide.off('click', item.button);\n                  });\n                } // Do not remove UPDATE_EVENT to recreate pagination if needed.\n\n\n                Splide.off(ATTRIBUTES_UPDATE_EVENT);\n                data = {};\n              },\n\n              /**\r\n               * Return an item by index.\r\n               *\r\n               * @param {number} index - A slide index.\r\n               *\r\n               * @return {Object|undefined} - An item object on success or undefined on failure.\r\n               */\n              getItem: function getItem(index) {\n                return data.items[Components.Controller.toPage(index)];\n              },\n\n              /**\r\n               * Return object containing pagination data.\r\n               *\r\n               * @return {Object} - Pagination data including list and items.\r\n               */\n              get data() {\n                return data;\n              }\n\n            };\n            /**\r\n             * Update attributes.\r\n             *\r\n             * @param {number} index     - Active index.\r\n             * @param {number} prevIndex - Prev index.\r\n             */\n\n            function updateAttributes(index, prevIndex) {\n              var prev = Pagination.getItem(prevIndex);\n              var curr = Pagination.getItem(index);\n              var active = STATUS_CLASSES.active;\n\n              if (prev) {\n                removeClass(prev.button, active);\n              }\n\n              if (curr) {\n                addClass(curr.button, active);\n              }\n\n              Splide.emit(name + \":updated\", data, prev, curr);\n            }\n            /**\r\n             * Create a wrapper and button elements.\r\n             *\r\n             * @return {Object} - An object contains all data.\r\n             */\n\n\n            function createPagination() {\n              var options = Splide.options;\n              var classes = Splide.classes;\n              var list = create('ul', {\n                \"class\": classes.pagination\n              });\n              var items = Elements.getSlides(false).filter(function (Slide) {\n                return options.focus !== false || Slide.index % options.perPage === 0;\n              }).map(function (Slide, page) {\n                var li = create('li', {});\n                var button = create('button', {\n                  \"class\": classes.page,\n                  type: 'button'\n                });\n                append(li, button);\n                append(list, li);\n                Splide.on('click', function () {\n                  Splide.go(\">\" + page);\n                }, button);\n                return {\n                  li: li,\n                  button: button,\n                  page: page,\n                  Slides: Elements.getSlidesByPage(page)\n                };\n              });\n              return {\n                list: list,\n                items: items\n              };\n            }\n\n            return Pagination;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/lazyload/index.js\n\n          /**\r\n           * The component for loading slider images lazily.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The name for a data attribute of src.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var SRC_DATA_NAME = 'data-splide-lazy';\n          /**\r\n           * The name for a data attribute of srcset.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var SRCSET_DATA_NAME = 'data-splide-lazy-srcset';\n          /**\r\n           * The component for loading slider images lazily.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           * @param {string} name       - A component name as a lowercase string.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          const lazyload = function (Splide, Components, name) {\n            /**\r\n             * Next index for sequential loading.\r\n             *\r\n             * @type {number}\r\n             */\n            var nextIndex;\n            /**\r\n             * Store objects containing an img element and a Slide object.\r\n             *\r\n             * @type {Object[]}\r\n             */\n\n            var images;\n            /**\r\n             * Store the options.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var options = Splide.options;\n            /**\r\n             * Whether to load images sequentially or not.\r\n             *\r\n             * @type {boolean}\r\n             */\n\n            var isSequential = options.lazyLoad === 'sequential';\n            /**\r\n             * Lazyload component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Lazyload = {\n              /**\r\n               * Mount only when the lazyload option is provided.\r\n               *\r\n               * @type {boolean}\r\n               */\n              required: options.lazyLoad,\n\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                Splide.on('mounted refresh', function () {\n                  init();\n                  Components.Elements.each(function (Slide) {\n                    each(Slide.slide.querySelectorAll(\"[\" + SRC_DATA_NAME + \"], [\" + SRCSET_DATA_NAME + \"]\"), function (img) {\n                      if (!img.src && !img.srcset) {\n                        images.push({\n                          img: img,\n                          Slide: Slide\n                        });\n                        applyStyle(img, {\n                          display: 'none'\n                        });\n                      }\n                    });\n                  });\n\n                  if (isSequential) {\n                    loadNext();\n                  }\n                });\n\n                if (!isSequential) {\n                  Splide.on(\"mounted refresh moved.\" + name, check);\n                }\n              },\n\n              /**\r\n               * Destroy.\r\n               */\n              destroy: init\n            };\n            /**\r\n             * Initialize parameters.\r\n             */\n\n            function init() {\n              images = [];\n              nextIndex = 0;\n            }\n            /**\r\n             * Check how close each image is from the active slide and\r\n             * determine whether to start loading or not, according to the distance.\r\n             *\r\n             * @param {number} index - Current index.\r\n             */\n\n\n            function check(index) {\n              index = isNaN(index) ? Splide.index : index;\n              images = images.filter(function (image) {\n                if (image.Slide.isWithin(index, options.perPage * (options.preloadPages + 1))) {\n                  load(image.img, image.Slide);\n                  return false;\n                }\n\n                return true;\n              }); // Unbind if all images are loaded.\n\n              if (!images[0]) {\n                Splide.off(\"moved.\" + name);\n              }\n            }\n            /**\r\n             * Start loading an image.\r\n             * Creating a clone of the image element since setting src attribute directly to it\r\n             * often occurs 'hitch', blocking some other processes of a browser.\r\n             *\r\n             * @param {Element} img   - An image element.\r\n             * @param {Object}  Slide - A Slide object.\r\n             */\n\n\n            function load(img, Slide) {\n              addClass(Slide.slide, STATUS_CLASSES.loading);\n              var spinner = create('span', {\n                \"class\": Splide.classes.spinner\n              });\n              append(img.parentElement, spinner);\n\n              img.onload = function () {\n                loaded(img, spinner, Slide, false);\n              };\n\n              img.onerror = function () {\n                loaded(img, spinner, Slide, true);\n              };\n\n              setAttribute(img, 'srcset', getAttribute(img, SRCSET_DATA_NAME) || '');\n              setAttribute(img, 'src', getAttribute(img, SRC_DATA_NAME) || '');\n            }\n            /**\r\n             * Start loading a next image in images array.\r\n             */\n\n\n            function loadNext() {\n              if (nextIndex < images.length) {\n                var image = images[nextIndex];\n                load(image.img, image.Slide);\n              }\n\n              nextIndex++;\n            }\n            /**\r\n             * Called just after the image was loaded or loading was aborted by some error.\r\n             *\r\n             * @param {Element} img     - An image element.\r\n             * @param {Element} spinner - A spinner element.\r\n             * @param {Object}  Slide   - A Slide object.\r\n             * @param {boolean} error   - True if the image was loaded successfully or false on error.\r\n             */\n\n\n            function loaded(img, spinner, Slide, error) {\n              removeClass(Slide.slide, STATUS_CLASSES.loading);\n\n              if (!error) {\n                dom_remove(spinner);\n                applyStyle(img, {\n                  display: ''\n                });\n                Splide.emit(name + \":loaded\", img).emit('resize');\n              }\n\n              if (isSequential) {\n                loadNext();\n              }\n            }\n\n            return Lazyload;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/constants/a11y.js\n\n          /**\r\n           * Export aria attribute names.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Attribute name for aria-current.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var ARIA_CURRENRT = 'aria-current';\n          /**\r\n           * Attribute name for aria-control.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var ARIA_CONTROLS = 'aria-controls';\n          /**\r\n           * Attribute name for aria-control.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var ARIA_LABEL = 'aria-label';\n          /**\r\n           * Attribute name for aria-labelledby.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var ARIA_LABELLEDBY = 'aria-labelledby';\n          /**\r\n           * Attribute name for aria-hidden.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var ARIA_HIDDEN = 'aria-hidden';\n          /**\r\n           * Attribute name for tab-index.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var TAB_INDEX = 'tabindex';\n          ; // CONCATENATED MODULE: ./src/js/components/keyboard/index.js\n\n          /**\r\n           * The component for controlling slides via keyboard.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Map a key to a slide control.\r\n           *\r\n           * @type {Object}\r\n           */\n\n          var KEY_MAP = {\n            ltr: {\n              ArrowLeft: '<',\n              ArrowRight: '>',\n              // For IE.\n              Left: '<',\n              Right: '>'\n            },\n            rtl: {\n              ArrowLeft: '>',\n              ArrowRight: '<',\n              // For IE.\n              Left: '>',\n              Right: '<'\n            },\n            ttb: {\n              ArrowUp: '<',\n              ArrowDown: '>',\n              // For IE.\n              Up: '<',\n              Down: '>'\n            }\n          };\n          /**\r\n           * The component for controlling slides via keyboard.\r\n           *\r\n           * @param {Splide} Splide - A Splide instance.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          const keyboard = function (Splide) {\n            /**\r\n             * Hold the target element.\r\n             *\r\n             * @type {Element|Document|undefined}\r\n             */\n            var target;\n            return {\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                Splide.on('mounted updated', function () {\n                  var options = Splide.options;\n                  var root = Splide.root;\n                  var map = KEY_MAP[options.direction];\n                  var keyboard = options.keyboard;\n\n                  if (target) {\n                    Splide.off('keydown', target);\n                    removeAttribute(root, TAB_INDEX);\n                  }\n\n                  if (keyboard) {\n                    if (keyboard === 'focused') {\n                      target = root;\n                      setAttribute(root, TAB_INDEX, 0);\n                    } else {\n                      target = document;\n                    }\n\n                    Splide.on('keydown', function (e) {\n                      if (map[e.key]) {\n                        Splide.go(map[e.key]);\n                      }\n                    }, target);\n                  }\n                });\n              }\n            };\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/a11y/index.js\n\n          /**\r\n           * The component for enhancing accessibility.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The component for enhancing accessibility.\r\n           *\r\n           * @param {Splide} Splide     - A Splide instance.\r\n           * @param {Object} Components - An object containing components.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          const a11y = function (Splide, Components) {\n            /**\r\n             * Hold a i18n object.\r\n             *\r\n             * @type {Object}\r\n             */\n            var i18n = Splide.i18n;\n            /**\r\n             * Hold the Elements component.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Elements = Components.Elements;\n            /**\r\n             * All attributes related with A11y.\r\n             *\r\n             * @type {string[]}\r\n             */\n\n            var allAttributes = [ARIA_HIDDEN, TAB_INDEX, ARIA_CONTROLS, ARIA_LABEL, ARIA_CURRENRT, 'role'];\n            /**\r\n             * A11y component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var A11y = {\n              /**\r\n               * Required only when the accessibility option is true.\r\n               *\r\n               * @type {boolean}\r\n               */\n              required: Splide.options.accessibility,\n\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                Splide.on('visible', function (Slide) {\n                  updateSlide(Slide.slide, true);\n                }).on('hidden', function (Slide) {\n                  updateSlide(Slide.slide, false);\n                }).on('arrows:mounted', initArrows).on('arrows:updated', updateArrows).on('pagination:mounted', initPagination).on('pagination:updated', updatePagination).on('refresh', function () {\n                  removeAttribute(Components.Clones.clones, allAttributes);\n                });\n\n                if (Splide.options.isNavigation) {\n                  Splide.on('navigation:mounted navigation:updated', initNavigation).on('active', function (Slide) {\n                    updateNavigation(Slide, true);\n                  }).on('inactive', function (Slide) {\n                    updateNavigation(Slide, false);\n                  });\n                }\n\n                initAutoplay();\n              },\n\n              /**\r\n               * Destroy.\r\n               */\n              destroy: function destroy() {\n                var Arrows = Components.Arrows;\n                var arrows = Arrows ? Arrows.arrows : {};\n                removeAttribute(Elements.slides.concat([arrows.prev, arrows.next, Elements.play, Elements.pause]), allAttributes);\n              }\n            };\n            /**\r\n             * Update slide attributes when it gets visible or hidden.\r\n             *\r\n             * @param {Element} slide   - A slide element.\r\n             * @param {Boolean} visible - True when the slide gets visible, or false when hidden.\r\n             */\n\n            function updateSlide(slide, visible) {\n              setAttribute(slide, ARIA_HIDDEN, !visible);\n\n              if (Splide.options.slideFocus) {\n                setAttribute(slide, TAB_INDEX, visible ? 0 : -1);\n              }\n            }\n            /**\r\n             * Initialize arrows if they are available.\r\n             * Append screen reader elements and add aria-controls attribute.\r\n             *\r\n             * @param {Element} prev - Previous arrow element.\r\n             * @param {Element} next - Next arrow element.\r\n             */\n\n\n            function initArrows(prev, next) {\n              var controls = Elements.track.id;\n              setAttribute(prev, ARIA_CONTROLS, controls);\n              setAttribute(next, ARIA_CONTROLS, controls);\n            }\n            /**\r\n             * Update arrow attributes.\r\n             *\r\n             * @param {Element} prev      - Previous arrow element.\r\n             * @param {Element} next      - Next arrow element.\r\n             * @param {number}  prevIndex - Previous slide index or -1 when there is no precede slide.\r\n             * @param {number}  nextIndex - Next slide index or -1 when there is no next slide.\r\n             */\n\n\n            function updateArrows(prev, next, prevIndex, nextIndex) {\n              var index = Splide.index;\n              var prevLabel = prevIndex > -1 && index < prevIndex ? i18n.last : i18n.prev;\n              var nextLabel = nextIndex > -1 && index > nextIndex ? i18n.first : i18n.next;\n              setAttribute(prev, ARIA_LABEL, prevLabel);\n              setAttribute(next, ARIA_LABEL, nextLabel);\n            }\n            /**\r\n             * Initialize pagination if it's available.\r\n             * Append a screen reader element and add aria-controls/label attribute to each item.\r\n             *\r\n             * @param {Object} data       - Data object containing all items.\r\n             * @param {Object} activeItem - An initial active item.\r\n             */\n\n\n            function initPagination(data, activeItem) {\n              if (activeItem) {\n                setAttribute(activeItem.button, ARIA_CURRENRT, true);\n              }\n\n              data.items.forEach(function (item) {\n                var options = Splide.options;\n                var text = options.focus === false && options.perPage > 1 ? i18n.pageX : i18n.slideX;\n                var label = sprintf(text, item.page + 1);\n                var button = item.button;\n                var controls = item.Slides.map(function (Slide) {\n                  return Slide.slide.id;\n                });\n                setAttribute(button, ARIA_CONTROLS, controls.join(' '));\n                setAttribute(button, ARIA_LABEL, label);\n              });\n            }\n            /**\r\n             * Update pagination attributes.\r\n             *\r\n             * @param {Object}  data - Data object containing all items.\r\n             * @param {Element} prev - A previous active element.\r\n             * @param {Element} curr - A current active element.\r\n             */\n\n\n            function updatePagination(data, prev, curr) {\n              if (prev) {\n                removeAttribute(prev.button, ARIA_CURRENRT);\n              }\n\n              if (curr) {\n                setAttribute(curr.button, ARIA_CURRENRT, true);\n              }\n            }\n            /**\r\n             * Initialize autoplay buttons.\r\n             */\n\n\n            function initAutoplay() {\n              ['play', 'pause'].forEach(function (name) {\n                var elm = Elements[name];\n\n                if (elm) {\n                  if (!isButton(elm)) {\n                    setAttribute(elm, 'role', 'button');\n                  }\n\n                  setAttribute(elm, ARIA_CONTROLS, Elements.track.id);\n                  setAttribute(elm, ARIA_LABEL, i18n[name]);\n                }\n              });\n            }\n            /**\r\n             * Initialize navigation slider.\r\n             * Add button role, aria-label, aria-controls to slide elements and append screen reader text to them.\r\n             *\r\n             * @param {Splide} main - A main Splide instance.\r\n             */\n\n\n            function initNavigation(main) {\n              Elements.each(function (Slide) {\n                var slide = Slide.slide;\n                var realIndex = Slide.realIndex;\n\n                if (!isButton(slide)) {\n                  setAttribute(slide, 'role', 'button');\n                }\n\n                var slideIndex = realIndex > -1 ? realIndex : Slide.index;\n                var label = sprintf(i18n.slideX, slideIndex + 1);\n                var mainSlide = main.Components.Elements.getSlide(slideIndex);\n                setAttribute(slide, ARIA_LABEL, label);\n\n                if (mainSlide) {\n                  setAttribute(slide, ARIA_CONTROLS, mainSlide.slide.id);\n                }\n              });\n            }\n            /**\r\n             * Update navigation attributes.\r\n             *\r\n             * @param {Object}  Slide  - A target Slide object.\r\n             * @param {boolean} active - True if the slide is active or false if inactive.\r\n             */\n\n\n            function updateNavigation(_ref, active) {\n              var slide = _ref.slide;\n\n              if (active) {\n                setAttribute(slide, ARIA_CURRENRT, true);\n              } else {\n                removeAttribute(slide, ARIA_CURRENRT);\n              }\n            }\n            /**\r\n             * Check if the given element is button or not.\r\n             *\r\n             * @param {Element} elm - An element to be checked.\r\n             *\r\n             * @return {boolean} - True if the given element is button.\r\n             */\n\n\n            function isButton(elm) {\n              return elm.tagName === 'BUTTON';\n            }\n\n            return A11y;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/sync/index.js\n\n          /**\r\n           * The component for synchronizing a slider with another.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * The event name for sync.\r\n           *\r\n           * @type {string}\r\n           */\n\n          var SYNC_EVENT = 'move.sync';\n          /**\r\n           * The event names for click navigation.\r\n           * @type {string}\r\n           */\n\n          var CLICK_EVENTS = 'mouseup touchend';\n          /**\r\n           * The keys for triggering the navigation button.\r\n           *\r\n           * @type {String[]}\r\n           */\n\n          var TRIGGER_KEYS = [' ', 'Enter', 'Spacebar'];\n          /**\r\n           * The component for synchronizing a slider with another.\r\n           *\r\n           * @param {Splide} Splide - A Splide instance.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          const sync = function (Splide) {\n            /**\r\n             * Keep the sibling Splide instance.\r\n             *\r\n             * @type {Splide}\r\n             */\n            var sibling = Splide.sibling;\n            /**\r\n             * Whether the sibling slider is navigation or not.\r\n             *\r\n             * @type {Splide|boolean}\r\n             */\n\n            var isNavigation = sibling && sibling.options.isNavigation;\n            /**\r\n             * Layout component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Sync = {\n              /**\r\n               * Required only when the sub slider is available.\r\n               *\r\n               * @type {boolean}\r\n               */\n              required: !!sibling,\n\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                syncMain();\n                syncSibling();\n\n                if (isNavigation) {\n                  bind();\n                  Splide.on('refresh', function () {\n                    setTimeout(function () {\n                      bind();\n                      sibling.emit('navigation:updated', Splide);\n                    });\n                  });\n                }\n              },\n\n              /**\r\n               * Called after all components are mounted.\r\n               */\n              mounted: function mounted() {\n                if (isNavigation) {\n                  sibling.emit('navigation:mounted', Splide);\n                }\n              }\n            };\n            /**\r\n             * Listen the primary slider event to move secondary one.\r\n             * Must unbind a handler at first to avoid infinite loop.\r\n             */\n\n            function syncMain() {\n              Splide.on(SYNC_EVENT, function (newIndex, prevIndex, destIndex) {\n                sibling.off(SYNC_EVENT).go(sibling.is(LOOP) ? destIndex : newIndex, false);\n                syncSibling();\n              });\n            }\n            /**\r\n             * Listen the secondary slider event to move primary one.\r\n             * Must unbind a handler at first to avoid infinite loop.\r\n             */\n\n\n            function syncSibling() {\n              sibling.on(SYNC_EVENT, function (newIndex, prevIndex, destIndex) {\n                Splide.off(SYNC_EVENT).go(Splide.is(LOOP) ? destIndex : newIndex, false);\n                syncMain();\n              });\n            }\n            /**\r\n             * Listen some events on each slide.\r\n             */\n\n\n            function bind() {\n              sibling.Components.Elements.each(function (_ref) {\n                var slide = _ref.slide,\n                    index = _ref.index;\n                /*\r\n                 * Listen mouseup and touchend events to handle click.\r\n                 */\n\n                Splide.off(CLICK_EVENTS, slide).on(CLICK_EVENTS, function (e) {\n                  // Ignore a middle or right click.\n                  if (!e.button || e.button === 0) {\n                    moveSibling(index);\n                  }\n                }, slide);\n                /*\r\n                 * Subscribe keyup to handle Enter and Space key.\r\n                 * Note that Array.includes is not supported by IE.\r\n                 */\n\n                Splide.off('keyup', slide).on('keyup', function (e) {\n                  if (TRIGGER_KEYS.indexOf(e.key) > -1) {\n                    e.preventDefault();\n                    moveSibling(index);\n                  }\n                }, slide, {\n                  passive: false\n                });\n              });\n            }\n            /**\r\n             * Move the sibling to the given index.\r\n             * Need to check \"IDLE\" status because slides can be moving by Drag component.\r\n             *\r\n             * @param {number} index - Target index.\r\n             */\n\n\n            function moveSibling(index) {\n              if (Splide.State.is(IDLE)) {\n                sibling.go(index);\n              }\n            }\n\n            return Sync;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/breakpoints/index.js\n\n          /**\r\n           * The component for updating options according to a current window width.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Interval time for throttle.\r\n           *\r\n           * @type {number}\r\n           */\n\n          var THROTTLE = 50;\n          /**\r\n           * The component for updating options according to a current window width.\r\n           *\r\n           * @param {Splide} Splide - A Splide instance.\r\n           *\r\n           * @return {Object} - The component object.\r\n           */\n\n          /* harmony default export */\n\n          const breakpoints = function (Splide) {\n            /**\r\n             * Store breakpoints.\r\n             *\r\n             * @type {Object|boolean}\r\n             */\n            var breakpoints = Splide.options.breakpoints;\n            /**\r\n             * The check function whose frequency of call is reduced.\r\n             *\r\n             * @type {Function}\r\n             */\n\n            var throttledCheck = throttle(check, THROTTLE);\n            /**\r\n             * Keep initial options.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var initialOptions;\n            /**\r\n             * An array containing objects of point and MediaQueryList.\r\n             *\r\n             * @type {Object[]}\r\n             */\n\n            var map = [];\n            /**\r\n             * Hold the previous breakpoint.\r\n             *\r\n             * @type {number|undefined}\r\n             */\n\n            var prevPoint;\n            /**\r\n             * Breakpoints component object.\r\n             *\r\n             * @type {Object}\r\n             */\n\n            var Breakpoints = {\n              /**\r\n               * Required only when the breakpoints definition is provided and browser supports matchMedia.\r\n               *\r\n               * @type {boolean}\r\n               */\n              required: breakpoints && matchMedia,\n\n              /**\r\n               * Called when the component is mounted.\r\n               */\n              mount: function mount() {\n                map = Object.keys(breakpoints).sort(function (n, m) {\n                  return +n - +m;\n                }).map(function (point) {\n                  return {\n                    point: point,\n                    mql: matchMedia(\"(max-width:\" + point + \"px)\")\n                  };\n                });\n                /*\r\n                 * To keep monitoring resize event after destruction without \"completely\",\r\n                 * use native addEventListener instead of Splide.on.\r\n                 */\n\n                this.destroy(true);\n                addEventListener('resize', throttledCheck); // Keep initial options to apply them when no breakpoint matches.\n\n                initialOptions = Splide.options;\n                check();\n              },\n\n              /**\r\n               * Destroy.\r\n               *\r\n               * @param {boolean} completely - Whether to destroy Splide completely.\r\n               */\n              destroy: function destroy(completely) {\n                if (completely) {\n                  removeEventListener('resize', throttledCheck);\n                }\n              }\n            };\n            /**\r\n             * Check the breakpoint.\r\n             */\n\n            function check() {\n              var point = getPoint();\n\n              if (point !== prevPoint) {\n                prevPoint = point;\n                var State = Splide.State;\n                var options = breakpoints[point] || initialOptions;\n                var destroy = options.destroy;\n\n                if (destroy) {\n                  Splide.options = initialOptions;\n                  Splide.destroy(destroy === 'completely');\n                } else {\n                  if (State.is(DESTROYED)) {\n                    Splide.mount();\n                  }\n\n                  Splide.options = options;\n                }\n              }\n            }\n            /**\r\n             * Return the breakpoint matching current window width.\r\n             * Note that Array.prototype.find is not supported by IE.\r\n             *\r\n             * @return {number|string} - A breakpoint as number or string. -1 if no point matches.\r\n             */\n\n\n            function getPoint() {\n              var item = map.filter(function (item) {\n                return item.mql.matches;\n              })[0];\n              return item ? item.point : -1;\n            }\n\n            return Breakpoints;\n          };\n\n          ; // CONCATENATED MODULE: ./src/js/components/index.js\n\n          /**\r\n           * Export components.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          var COMPLETE = {\n            Options: options,\n            Breakpoints: breakpoints,\n            Controller: controller,\n            Elements: components_elements,\n            Track: track,\n            Clones: clones,\n            Layout: layout,\n            Drag: drag,\n            Click: click,\n            Autoplay: autoplay,\n            Cover: cover,\n            Arrows: arrows,\n            Pagination: pagination,\n            LazyLoad: lazyload,\n            Keyboard: keyboard,\n            Sync: sync,\n            A11y: a11y\n          };\n          var LIGHT = {\n            Options: options,\n            Controller: controller,\n            Elements: components_elements,\n            Track: track,\n            Clones: clones,\n            Layout: layout,\n            Drag: drag,\n            Click: click,\n            Arrows: arrows,\n            Pagination: pagination,\n            A11y: a11y\n          };\n          ; // CONCATENATED MODULE: ./build/module/module.js\n\n          function _inheritsLoose(subClass, superClass) {\n            subClass.prototype = Object.create(superClass.prototype);\n            subClass.prototype.constructor = subClass;\n            subClass.__proto__ = superClass;\n          }\n          /**\r\n           * Export Splide class for import.\r\n           *\r\n           * @author    Naotoshi Fujita\r\n           * @copyright Naotoshi Fujita. All rights reserved.\r\n           */\n\n          /**\r\n           * Export Splide class for import from other projects.\r\n           */\n\n\n          var module_Splide = /*#__PURE__*/function (_Core) {\n            _inheritsLoose(Splide, _Core);\n\n            function Splide(root, options) {\n              return _Core.call(this, root, options, COMPLETE) || this;\n            }\n\n            return Splide;\n          }(Splide);\n          /***/\n\n        }\n        /******/\n\n      };\n      /************************************************************************/\n\n      /******/\n      // The module cache\n\n      /******/\n\n      var __webpack_module_cache__ = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (__webpack_module_cache__[moduleId]) {\n          /******/\n          return __webpack_module_cache__[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = __webpack_module_cache__[moduleId] = {\n          /******/\n          // no module.id needed\n\n          /******/\n          // no module.loaded needed\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /************************************************************************/\n\n      /******/\n\n      /* webpack/runtime/define property getters */\n\n      /******/\n\n\n      (() => {\n        /******/\n        // define getter functions for harmony exports\n\n        /******/\n        __webpack_require__.d = (exports, definition) => {\n          /******/\n          for (var key in definition) {\n            /******/\n            if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n              /******/\n              Object.defineProperty(exports, key, {\n                enumerable: true,\n                get: definition[key]\n              });\n              /******/\n            }\n            /******/\n\n          }\n          /******/\n\n        };\n        /******/\n\n      })();\n      /******/\n\n      /******/\n\n      /* webpack/runtime/hasOwnProperty shorthand */\n\n      /******/\n\n\n      (() => {\n        /******/\n        __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n        /******/\n\n      })();\n      /******/\n\n      /******/\n\n      /* webpack/runtime/make namespace object */\n\n      /******/\n\n\n      (() => {\n        /******/\n        // define __esModule on exports\n\n        /******/\n        __webpack_require__.r = exports => {\n          /******/\n          if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n            /******/\n            Object.defineProperty(exports, Symbol.toStringTag, {\n              value: 'Module'\n            });\n            /******/\n          }\n          /******/\n\n\n          Object.defineProperty(exports, '__esModule', {\n            value: true\n          });\n          /******/\n        };\n        /******/\n\n      })();\n      /******/\n\n      /************************************************************************/\n\n      /******/\n      // module exports must be returned from runtime so entry inlining is disabled\n\n      /******/\n      // startup\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n\n      return __webpack_require__(311);\n      /******/\n    })()\n  );\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNwbGlkZWpzL3NwbGlkZS9kaXN0L2pzL3NwbGlkZS5lc20uanM/NGEzNSJdLCJuYW1lcyI6WyJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJmYWN0b3J5IiwibW9kdWxlIiwiZXhwb3J0cyIsInNlbGYiLCJfX3dlYnBhY2tfbW9kdWxlc19fIiwiX191bnVzZWRfd2VicGFja19tb2R1bGUiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsInIiLCJkIiwibW9kdWxlX1NwbGlkZSIsInN0YXRlc19uYW1lc3BhY2VPYmplY3QiLCJDUkVBVEVEIiwiREVTVFJPWUVEIiwiSURMRSIsIk1PVU5URUQiLCJNT1ZJTkciLCJjb3JlX2V2ZW50IiwiZGF0YSIsIkV2ZW50Iiwib24iLCJldmVudHMiLCJoYW5kbGVyIiwiZWxtIiwib3B0aW9ucyIsInNwbGl0IiwiZm9yRWFjaCIsImV2ZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInB1c2giLCJvZmYiLCJmaWx0ZXIiLCJpdGVtIiwidW5zdWJzY3JpYmUiLCJlbWl0IiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJhcHBseSIsImRlc3Ryb3kiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic3RhdGUiLCJpbml0aWFsU3RhdGUiLCJjdXJyIiwic2V0IiwiaXMiLCJfZXh0ZW5kcyIsIk9iamVjdCIsImFzc2lnbiIsInRhcmdldCIsImkiLCJzb3VyY2UiLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJrZXlzIiwiZWFjaCIsIm9iaiIsImNhbGxiYWNrIiwic29tZSIsImluZGV4IiwidmFsdWVzIiwibWFwIiwiaXNPYmplY3QiLCJzdWJqZWN0IiwibWVyZ2UiLCJfcmVmIiwiZnJvbSIsInRvIiwidmFsdWUiLCJvYmplY3RfYXNzaWduIiwiZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJ0b0FycmF5IiwiaXNBcnJheSIsImJldHdlZW4iLCJtMSIsIm0yIiwiTWF0aCIsIm1pbiIsIm1heCIsInNwcmludGYiLCJmb3JtYXQiLCJyZXBsYWNlbWVudHMiLCJyZXBsYWNlIiwidW5pdCIsInR5cGUiLCJwYXJzZUZsb2F0IiwicGFkIiwibnVtYmVyIiwidG9QaXhlbCIsImRpdiIsImNyZWF0ZSIsImFwcGx5U3R5bGUiLCJwb3NpdGlvbiIsIndpZHRoIiwiYXBwZW5kIiwiY2xpZW50V2lkdGgiLCJkb21fcmVtb3ZlIiwiZmluZCIsInNlbGVjdG9yIiwicXVlcnlTZWxlY3RvciIsImNoaWxkIiwicGFyZW50IiwidGFnT3JDbGFzc05hbWUiLCJjaGlsZHJlbiIsImhhc0NsYXNzIiwidGFnTmFtZSIsInRhZyIsImF0dHJzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic2V0QXR0cmlidXRlIiwiZG9taWZ5IiwiaHRtbCIsImlubmVySFRNTCIsImZpcnN0Q2hpbGQiLCJlbG1zIiwicGFyZW50RWxlbWVudCIsInJlbW92ZUNoaWxkIiwiYXBwZW5kQ2hpbGQiLCJiZWZvcmUiLCJyZWYiLCJpbnNlcnRCZWZvcmUiLCJzdHlsZXMiLCJwcm9wIiwic3R5bGUiLCJhZGRPclJlbW92ZUNsYXNzZXMiLCJjbGFzc2VzIiwicmVtb3ZlIiwibmFtZSIsImNsYXNzTGlzdCIsImFkZENsYXNzIiwicmVtb3ZlQ2xhc3MiLCJjbGFzc05hbWUiLCJjb250YWlucyIsImdldEF0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsIm5hbWVzIiwiZ2V0UmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImxvYWRlZCIsImltYWdlcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJjb3VudCIsImltZyIsIm9ubG9hZCIsIm9uZXJyb3IiLCJTTElERSIsIkxPT1AiLCJGQURFIiwic2xpZGUiLCJTcGxpZGUiLCJDb21wb25lbnRzIiwibGlzdCIsImVuZENhbGxiYWNrIiwibW91bnQiLCJFbGVtZW50cyIsImUiLCJzdGFydCIsImRlc3RJbmRleCIsIm5ld0luZGV4IiwicHJldkluZGV4IiwiY29vcmQiLCJkb25lIiwiZWRnZUluZGV4IiwiQ29udHJvbGxlciIsInNwZWVkIiwicmV3aW5kU3BlZWQiLCJ0cmFuc2l0aW9uIiwiZWFzaW5nIiwidHJhbnNmb3JtIiwieCIsInkiLCJmYWRlIiwiRmFkZSIsInRyYWNrIiwiaGVpZ2h0IiwiY2xpZW50SGVpZ2h0Iiwic2V0VGltZW91dCIsInNsaWRlcyIsImNvbXBvc2UiLCJUcmFuc2l0aW9uIiwiY29tcG9uZW50cyIsIkNvbXBvbmVudCIsInRvTG93ZXJDYXNlIiwiTUVTU0FHRV9QUkVGSVgiLCJlcnJvciIsIm1lc3NhZ2UiLCJjb25zb2xlIiwiZXhpc3QiLCJFcnJvciIsIlJPT1QiLCJFTEVNRU5UX0NMQVNTRVMiLCJzbGlkZXIiLCJjb250YWluZXIiLCJhcnJvd3MiLCJhcnJvdyIsInByZXYiLCJuZXh0IiwicGFnaW5hdGlvbiIsInBhZ2UiLCJjbG9uZSIsInByb2dyZXNzIiwiYmFyIiwiYXV0b3BsYXkiLCJwbGF5IiwicGF1c2UiLCJzcGlubmVyIiwic3IiLCJTVEFUVVNfQ0xBU1NFUyIsImFjdGl2ZSIsInZpc2libGUiLCJsb2FkaW5nIiwiSTE4TiIsImZpcnN0IiwibGFzdCIsInNsaWRlWCIsInBhZ2VYIiwiREVGQVVMVFMiLCJyZXdpbmQiLCJ3YWl0Rm9yVHJhbnNpdGlvbiIsImZpeGVkV2lkdGgiLCJmaXhlZEhlaWdodCIsImhlaWdodFJhdGlvIiwiYXV0b1dpZHRoIiwiYXV0b0hlaWdodCIsInBlclBhZ2UiLCJwZXJNb3ZlIiwiY2xvbmVzIiwiZm9jdXMiLCJnYXAiLCJwYWRkaW5nIiwiYXJyb3dQYXRoIiwiaW50ZXJ2YWwiLCJwYXVzZU9uSG92ZXIiLCJwYXVzZU9uRm9jdXMiLCJyZXNldFByb2dyZXNzIiwibGF6eUxvYWQiLCJwcmVsb2FkUGFnZXMiLCJrZXlib2FyZCIsImRyYWciLCJkcmFnQW5nbGVUaHJlc2hvbGQiLCJzd2lwZURpc3RhbmNlVGhyZXNob2xkIiwiZmxpY2tWZWxvY2l0eVRocmVzaG9sZCIsImZsaWNrUG93ZXIiLCJmbGlja01heFBhZ2VzIiwiZGlyZWN0aW9uIiwiY292ZXIiLCJhY2Nlc3NpYmlsaXR5Iiwic2xpZGVGb2N1cyIsImlzTmF2aWdhdGlvbiIsInRyaW1TcGFjZSIsInVwZGF0ZU9uTW92ZSIsInRocm90dGxlIiwiYnJlYWtwb2ludHMiLCJpMThuIiwiX2RlZmluZVByb3BlcnRpZXMiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfY3JlYXRlQ2xhc3MiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIkVsZW1lbnQiLCJTdGF0ZSIsIlNUQVRFUyIsIl9vIiwiX2kiLCJfYyIsIl9lIiwiX3QiLCJfcHJvdG8iLCJFeHRlbnNpb25zIiwiX3RoaXMiLCJjb21wb25lbnQiLCJyZXF1aXJlZCIsInVuZGVmaW5lZCIsIm1vdW50ZWQiLCJ2aXNpYmlsaXR5Iiwic3luYyIsInNwbGlkZSIsInNpYmxpbmciLCJfdGhpcyRFdmVudCIsImNvbmNhdCIsImdvIiwiY29udHJvbCIsIndhaXQiLCJhZGQiLCJyZWZyZXNoIiwiYmluZCIsImNvbXBsZXRlbHkiLCJfdGhpczIiLCJyZXZlcnNlIiwiZ2V0IiwicGFyc2VJbnQiLCJjcmVhdGVkIiwiSlNPTiIsInBhcnNlIiwiTFRSIiwiUlRMIiwiVFRCIiwiU1RZTEVfUkVTVE9SRV9FVkVOVFMiLCJlbGVtZW50c19zbGlkZSIsInJlYWxJbmRleCIsIlNUQVRVU19VUERBVEVfRVZFTlRTIiwiU2xpZGUiLCJpc0Nsb25lIiwiaWQiLCJ1cGRhdGUiLCJyZXN0b3JlU3R5bGVzIiwiX3VwZGF0ZSIsImRpc3BsYXkiLCJpc0FjdGl2ZSIsImlzVmlzaWJsZSIsImNlaWwiLCJ0cmFja1JlY3QiLCJzbGlkZVJlY3QiLCJ0b3AiLCJib3R0b20iLCJsZWZ0IiwicmlnaHQiLCJpc1dpdGhpbiIsIndpdGhpbiIsImRpZmYiLCJhYnMiLCJmb3JWaXNpYmlsaXR5IiwiVUlEX05BTUUiLCJjb21wb25lbnRzX2VsZW1lbnRzIiwiU2xpZGVzIiwid2luZG93IiwidWlkIiwiaW5pdCIsImdldENsYXNzZXMiLCJjb2xsZWN0IiwicmVnaXN0ZXIiLCJTbGlkZU9iamVjdCIsImdldFNsaWRlIiwiZ2V0U2xpZGVzIiwiaW5jbHVkZUNsb25lcyIsImdldFNsaWRlc0J5UGFnZSIsImlkeCIsInRvSW5kZXgiLCJzcGxpY2UiLCJ0b3RhbCIsImZpbmRQYXJ0cyIsInJvb3RDbGFzcyIsImZsb29yIiwiY29udHJvbGxlciIsImlzTG9vcCIsInNpbGVudGx5IiwidHJpbSIsIlRyYWNrIiwibWF0Y2hlcyIsIlN0cmluZyIsIm1hdGNoIiwiaW5kaWNhdG9yIiwicGFyc2VQYWdlIiwiaGFzRm9jdXMiLCJwYWdlTGVuZ3RoIiwidG9QYWdlIiwiZWRnZSIsImlzUnRsIiwibmV4dEluZGV4IiwibmV3T3B0aW9ucyIsInNpZ24iLCJMYXlvdXQiLCJpc1ZlcnRpY2FsIiwiaXNGYWRlIiwiaXNSVEwiLCJpc0xvb3BQZW5kaW5nIiwianVtcCIsIm5ld1Bvc2l0aW9uIiwiZ2V0VHJpbW1lZFBvc2l0aW9uIiwidG9Db29yZCIsIm9uVHJhbnNpdGlvbkVuZCIsInRyYW5zbGF0ZSIsImNhbmNlbCIsInNoaWZ0IiwidG9Qb3NpdGlvbiIsImlubmVyU2l6ZSIsInRvdGFsU2l6ZSIsInNpemUiLCJtaW5EaXN0YW5jZSIsIkluZmluaXR5Iiwic2xpZGVJbmRleCIsImRpc3RhbmNlIiwic2xpZGVTaXplIiwib2Zmc2V0IiwiY2xvbmVDb3VudCIsIkNsb25lcyIsImdldENsb25lQ291bnQiLCJnZW5lcmF0ZUNsb25lcyIsInNsaWNlIiwiY2xvbmVEZWVwbHkiLCJiYXNlQ291bnQiLCJkaW1lbnNpb24iLCJmaXhlZFNpemUiLCJjbG9uZU5vZGUiLCJob3Jpem9udGFsIiwibWFyZ2luIiwicmVzaXplIiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nUmlnaHQiLCJ0b3RhbFdpZHRoIiwibGlzdFJlY3QiLCJzbGlkZVdpZHRoIiwib2Zmc2V0V2lkdGgiLCJzbGlkZUhlaWdodCIsInZlcnRpY2FsIiwicGFkZGluZ1RvcCIsInBhZGRpbmdCb3R0b20iLCJ0b3RhbEhlaWdodCIsIm9mZnNldEhlaWdodCIsImZ1bmMiLCJ0aW1lb3V0IiwiY3JlYXRlSW50ZXJ2YWwiLCJfd2luZG93IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZWxhcHNlIiwicmF0ZSIsIl9wYXVzZSIsInN0ZXAiLCJ0aW1lc3RhbXAiLCJyZXNldCIsImxheW91dCIsIm1heFdpZHRoIiwiZHJhZ19hYnMiLCJNSU5fVkVMT0NJVFkiLCJGUklDVElPTl9SRURVQ0VSIiwic3RhcnRDb29yZCIsInN0YXJ0SW5mbyIsImN1cnJlbnRJbmZvIiwiaXNEcmFnZ2luZyIsImF4aXMiLCJEcmFnIiwiZGlzYWJsZWQiLCJtb3ZlIiwicGFzc2l2ZSIsImVuZCIsInByZXZlbnREZWZhdWx0IiwiYW5hbHl6ZSIsImNhbmNlbGFibGUiLCJyZXNpc3QiLCJzaG91bGRNb3ZlIiwiYW5nbGUiLCJhdGFuIiwiUEkiLCJfc3RhcnQiLCJfZW5kIiwibG9nIiwiaW5mbyIsInZlbG9jaXR5IiwiYWJzViIsImRlc3RpbmF0aW9uIiwidGltZVN0YW1wIiwidG91Y2hlcyIsIl9yZWYyIiwiY2xpZW50WCIsImNsaWVudFkiLCJfcmVmMyIsIl9yZWYzJHgiLCJmcm9tWCIsIl9yZWYzJHkiLCJmcm9tWSIsInN0YXJ0VGltZSIsInRpbWUiLCJkdXJhdGlvbiIsImNsaWNrIiwiQ2xpY2siLCJvbkNsaWNrIiwiY2FwdHVyZSIsInN0b3BQcm9wYWdhdGlvbiIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsIlBBVVNFX0ZMQUdTIiwiSE9WRVIiLCJGT0NVUyIsIk1BTlVBTCIsImZsYWdzIiwiQXV0b3BsYXkiLCJmbGFnIiwiZiIsImluZGV4T2YiLCJzd2l0Y2hPbiIsIkNvdmVyIiwidW5jb3ZlciIsInNyYyIsImJhY2tncm91bmQiLCJYTUxfTkFNRV9TUEFDRSIsIlBBVEgiLCJTSVpFIiwiQXJyb3dzIiwiY3JlYXRlQXJyb3ciLCJhcHBlbmRBcnJvd3MiLCJ1cGRhdGVEaXNhYmxlZCIsIl9Db21wb25lbnRzJENvbnRyb2xsZSIsImlzRW5vdWdoIiwid3JhcHBlciIsImZpcnN0RWxlbWVudENoaWxkIiwiQVRUUklCVVRFU19VUERBVEVfRVZFTlQiLCJVUERBVEVfRVZFTlQiLCJQYWdpbmF0aW9uIiwiY3JlYXRlUGFnaW5hdGlvbiIsInVwZGF0ZUF0dHJpYnV0ZXMiLCJnZXRJdGVtIiwiaXRlbXMiLCJidXR0b24iLCJsaSIsIlNSQ19EQVRBX05BTUUiLCJTUkNTRVRfREFUQV9OQU1FIiwibGF6eWxvYWQiLCJpc1NlcXVlbnRpYWwiLCJMYXp5bG9hZCIsInNyY3NldCIsImxvYWROZXh0IiwiY2hlY2siLCJpc05hTiIsImltYWdlIiwibG9hZCIsIkFSSUFfQ1VSUkVOUlQiLCJBUklBX0NPTlRST0xTIiwiQVJJQV9MQUJFTCIsIkFSSUFfTEFCRUxMRURCWSIsIkFSSUFfSElEREVOIiwiVEFCX0lOREVYIiwiS0VZX01BUCIsImx0ciIsIkFycm93TGVmdCIsIkFycm93UmlnaHQiLCJMZWZ0IiwiUmlnaHQiLCJydGwiLCJ0dGIiLCJBcnJvd1VwIiwiQXJyb3dEb3duIiwiVXAiLCJEb3duIiwiYTExeSIsImFsbEF0dHJpYnV0ZXMiLCJBMTF5IiwidXBkYXRlU2xpZGUiLCJpbml0QXJyb3dzIiwidXBkYXRlQXJyb3dzIiwiaW5pdFBhZ2luYXRpb24iLCJ1cGRhdGVQYWdpbmF0aW9uIiwiaW5pdE5hdmlnYXRpb24iLCJ1cGRhdGVOYXZpZ2F0aW9uIiwiaW5pdEF1dG9wbGF5IiwiY29udHJvbHMiLCJwcmV2TGFiZWwiLCJuZXh0TGFiZWwiLCJhY3RpdmVJdGVtIiwidGV4dCIsImxhYmVsIiwiam9pbiIsImlzQnV0dG9uIiwibWFpbiIsIm1haW5TbGlkZSIsIlNZTkNfRVZFTlQiLCJDTElDS19FVkVOVFMiLCJUUklHR0VSX0tFWVMiLCJTeW5jIiwic3luY01haW4iLCJzeW5jU2libGluZyIsIm1vdmVTaWJsaW5nIiwiVEhST1RUTEUiLCJ0aHJvdHRsZWRDaGVjayIsImluaXRpYWxPcHRpb25zIiwicHJldlBvaW50IiwiQnJlYWtwb2ludHMiLCJtYXRjaE1lZGlhIiwic29ydCIsIm4iLCJtIiwicG9pbnQiLCJtcWwiLCJnZXRQb2ludCIsIkNPTVBMRVRFIiwiT3B0aW9ucyIsIkxhenlMb2FkIiwiS2V5Ym9hcmQiLCJMSUdIVCIsIl9pbmhlcml0c0xvb3NlIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY29uc3RydWN0b3IiLCJfX3Byb3RvX18iLCJfQ29yZSIsIl9fd2VicGFja19tb2R1bGVfY2FjaGVfXyIsIm1vZHVsZUlkIiwiZGVmaW5pdGlvbiIsIm8iLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQU1BLENBQUMsU0FBU0EsZ0NBQVQsQ0FBMENDLElBQTFDLEVBQWdEQyxPQUFoRCxFQUF5RDtBQUN6RCxNQUFHLElBQUgsRUFDQ0MsTUFBTSxDQUFDQyxPQUFQLEdBQWlCRixPQUFPLEVBQXhCLENBREQsS0FFSyxFQUtKO0FBQ0QsQ0FURCxFQVNHRyxJQVRILEVBU1MsWUFBVztBQUNwQjtBQUFPO0FBQVMsS0FBQyxNQUFNO0FBQUU7O0FBQ3pCO0FBQVU7QUFDVjs7QUFBVSxVQUFJQyxtQkFBbUIsR0FBSTtBQUVyQztBQUFNO0FBQ047QUFBTyxTQUFDQyx1QkFBRCxFQUEwQkMsbUJBQTFCLEVBQStDQyxtQkFBL0MsS0FBdUU7QUFFOUU7QUFDQUEsNkJBQW1CLENBQUNDLENBQXBCLENBQXNCRixtQkFBdEIsRUFIOEUsQ0FLOUU7OztBQUNBQyw2QkFBbUIsQ0FBQ0UsQ0FBcEIsQ0FBc0JILG1CQUF0QixFQUEyQztBQUN6Qyx1QkFBVztBQUFNO0FBQWNJO0FBRFUsV0FBM0MsRUFOOEUsQ0FVOUU7OztBQUNBLGNBQUlDLHNCQUFzQixHQUFHLEVBQTdCOztBQUNBSiw2QkFBbUIsQ0FBQ0MsQ0FBcEIsQ0FBc0JH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VSxhQUFPbEUsbUJBQW1CLENBQUMsR0FBRCxDQUExQjtBQUNWO0FBQVUsS0Fsd0xNO0FBQWhCO0FBb3dMQyxDQTl3TEQiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNwbGlkZWpzL3NwbGlkZS9kaXN0L2pzL3NwbGlkZS5lc20uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFNwbGlkZS5qc1xuICogVmVyc2lvbiAgOiAyLjQuMjBcbiAqIExpY2Vuc2UgIDogTUlUXG4gKiBDb3B5cmlnaHQ6IDIwMjAgTmFvdG9zaGkgRnVqaXRhXG4gKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIlNwbGlkZVwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJTcGxpZGVcIl0gPSBmYWN0b3J5KCk7XG59KShzZWxmLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoKCkgPT4geyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdFwidXNlIHN0cmljdFwiO1xuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIDMxMTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLy8gRVNNIENPTVBBVCBGTEFHXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4gIFwiZGVmYXVsdFwiOiAoKSA9PiAvKiBiaW5kaW5nICovIG1vZHVsZV9TcGxpZGVcbn0pO1xuXG4vLyBOQU1FU1BBQ0UgT0JKRUNUOiAuL3NyYy9qcy9jb25zdGFudHMvc3RhdGVzLmpzXG52YXIgc3RhdGVzX25hbWVzcGFjZU9iamVjdCA9IHt9O1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKHN0YXRlc19uYW1lc3BhY2VPYmplY3QpO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKHN0YXRlc19uYW1lc3BhY2VPYmplY3QsIHtcbiAgXCJDUkVBVEVEXCI6ICgpID0+IENSRUFURUQsXG4gIFwiREVTVFJPWUVEXCI6ICgpID0+IERFU1RST1lFRCxcbiAgXCJJRExFXCI6ICgpID0+IElETEUsXG4gIFwiTU9VTlRFRFwiOiAoKSA9PiBNT1VOVEVELFxuICBcIk1PVklOR1wiOiAoKSA9PiBNT1ZJTkdcbn0pO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29yZS9ldmVudC5qc1xuLyoqXHJcbiAqIFRoZSBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGFuIEV2ZW50IG9iamVjdCBzaW1wbHkgbWFuYWdpbmcgZXZlbnRzLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cbi8qKlxyXG4gKiBUaGUgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhbiBFdmVudCBvYmplY3Qgc2ltcGx5IG1hbmFnaW5nIGV2ZW50cy5cclxuICovXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvcmVfZXZlbnQgPSAoZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgKiBTdG9yZSBhbGwgZXZlbnQgZGF0YS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtBcnJheX1cclxuICAgKi9cbiAgdmFyIGRhdGEgPSBbXTtcbiAgdmFyIEV2ZW50ID0ge1xuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlIHRoZSBnaXZlbiBldmVudChzKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gICBldmVudHMgIC0gQW4gZXZlbnQgbmFtZS4gVXNlIHNwYWNlIHRvIHNlcGFyYXRlIG11bHRpcGxlIGV2ZW50cy5cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbHNvLCBuYW1lc3BhY2UgaXMgYWNjZXB0ZWQgYnkgZG90LCBzdWNoIGFzICdyZXNpemUue25hbWVzcGFjZX0nLlxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciAtIEEgY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9ICBlbG0gICAgIC0gT3B0aW9uYWwuIE5hdGl2ZSBldmVudCB3aWxsIGJlIGxpc3RlbmVkIHRvIHdoZW4gdGhpcyBhcmcgaXMgcHJvdmlkZWQuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICBvcHRpb25zIC0gT3B0aW9uYWwuIE9wdGlvbnMgZm9yIGFkZEV2ZW50TGlzdGVuZXIuXHJcbiAgICAgKi9cbiAgICBvbjogZnVuY3Rpb24gb24oZXZlbnRzLCBoYW5kbGVyLCBlbG0sIG9wdGlvbnMpIHtcbiAgICAgIGlmIChlbG0gPT09IHZvaWQgMCkge1xuICAgICAgICBlbG0gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgZXZlbnRzLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGVsbSkge1xuICAgICAgICAgIGVsbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEucHVzaCh7XG4gICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICAgICAgZWxtOiBlbG0sXG4gICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFVuc3Vic2NyaWJlIHRoZSBnaXZlbiBldmVudChzKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gIGV2ZW50cyAtIEEgZXZlbnQgbmFtZSBvciBuYW1lcyBzcGxpdCBieSBzcGFjZS5cclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxtICAgIC0gT3B0aW9uYWwuIHJlbW92ZUV2ZW50TGlzdGVuZXIoKSB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoaXMgYXJnIGlzIHByb3ZpZGVkLlxyXG4gICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbiBvZmYoZXZlbnRzLCBlbG0pIHtcbiAgICAgIGlmIChlbG0gPT09IHZvaWQgMCkge1xuICAgICAgICBlbG0gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBldmVudHMuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBkYXRhID0gZGF0YS5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLmV2ZW50ID09PSBldmVudCAmJiBpdGVtLmVsbSA9PT0gZWxtKSB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZShpdGVtKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBFbWl0IGFuIGV2ZW50LlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgb25seSBmb3IgY3VzdG9tIGV2ZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gIGV2ZW50IC0gQW4gZXZlbnQgbmFtZS5cclxuICAgICAqIEBwYXJhbSB7Kn0gICAgICAgYXJncyAgLSBBbnkgbnVtYmVyIG9mIGFyZ3VtZW50cyBwYXNzZWQgdG8gaGFuZGxlcnMuXHJcbiAgICAgKi9cbiAgICBlbWl0OiBmdW5jdGlvbiBlbWl0KGV2ZW50KSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFpdGVtLmVsbSAmJiBpdGVtLmV2ZW50LnNwbGl0KCcuJylbMF0gPT09IGV2ZW50KSB7XG4gICAgICAgICAgaXRlbS5oYW5kbGVyLmFwcGx5KGl0ZW0sIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhciBldmVudCBkYXRhLlxyXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIGRhdGEuZm9yRWFjaCh1bnN1YnNjcmliZSk7XG4gICAgICBkYXRhID0gW107XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBSZW1vdmUgdGhlIHJlZ2lzdGVyZWQgZXZlbnQgbGlzdGVuZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gaXRlbSAtIEFuIG9iamVjdCBjb250YWluaW5nIGV2ZW50IGRhdGEuXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gdW5zdWJzY3JpYmUoaXRlbSkge1xuICAgIGlmIChpdGVtLmVsbSkge1xuICAgICAgaXRlbS5lbG0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihpdGVtLmV2ZW50LCBpdGVtLmhhbmRsZXIsIGl0ZW0ub3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEV2ZW50O1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29yZS9zdGF0ZS5qc1xuLyoqXHJcbiAqIFRoZSBmdW5jdGlvbiBwcm92aWRpbmcgYSBzdXBlciBzaW1wbGUgc3RhdGUgc3lzdGVtLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cbi8qKlxyXG4gKiBUaGUgZnVuY3Rpb24gcHJvdmlkaW5nIGEgc3VwZXIgc2ltcGxlIHN0YXRlIHN5c3RlbS5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBpbml0aWFsU3RhdGUgLSBQcm92aWRlIHRoZSBpbml0aWFsIHN0YXRlIHZhbHVlLlxyXG4gKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3Qgc3RhdGUgPSAoZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAvKipcclxuICAgKiBTdG9yZSB0aGUgY3VycmVudCBzdGF0ZS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtzdHJpbmd8bnVtYmVyfVxyXG4gICAqL1xuICB2YXIgY3VyciA9IGluaXRpYWxTdGF0ZTtcbiAgcmV0dXJuIHtcbiAgICAvKipcclxuICAgICAqIENoYW5nZSBzdGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHN0YXRlIC0gQSBuZXcgc3RhdGUuXHJcbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChzdGF0ZSkge1xuICAgICAgY3VyciA9IHN0YXRlO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFZlcmlmeSBpZiB0aGUgY3VycmVudCBzdGF0ZSBpcyBnaXZlbiBvbmUgb3Igbm90LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gc3RhdGUgLSBBIHN0YXRlIG5hbWUgdG8gYmUgdmVyaWZpZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRoZSBjdXJyZW50IHN0YXRlIGlzIHRoZSBnaXZlbiBvbmUuXHJcbiAgICAgKi9cbiAgICBpczogZnVuY3Rpb24gaXMoc3RhdGUpIHtcbiAgICAgIHJldHVybiBzdGF0ZSA9PT0gY3VycjtcbiAgICB9XG4gIH07XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy91dGlscy9vYmplY3QuanNcbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbi8qKlxyXG4gKiBTb21lIHV0aWxpdHkgZnVuY3Rpb25zIHJlbGF0ZWQgd2l0aCBPYmplY3QsIHN1cHBvcnRpbmcgSUUuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cbnZhciBrZXlzID0gT2JqZWN0LmtleXM7XG4vKipcclxuICogSXRlcmF0ZSBhbiBvYmplY3QgbGlrZSBBcnJheS5mb3JFYWNoLlxyXG4gKiBJRSBkb2Vzbid0IHN1cHBvcnQgZm9yRWFjaCBvZiBIVE1MQ29sbGVjdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9ICAgIG9iaiAgICAgICAtIEFuIG9iamVjdC5cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gIGNhbGxiYWNrICAtIEEgZnVuY3Rpb24gaGFuZGxpbmcgZWFjaCB2YWx1ZS4gQXJndW1lbnRzIGFyZSB2YWx1ZSwgcHJvcGVydHkgYW5kIGluZGV4LlxyXG4gKi9cblxuZnVuY3Rpb24gZWFjaChvYmosIGNhbGxiYWNrKSB7XG4gIGtleXMob2JqKS5zb21lKGZ1bmN0aW9uIChrZXksIGluZGV4KSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG9ialtrZXldLCBrZXksIGluZGV4KTtcbiAgfSk7XG59XG4vKipcclxuICogUmV0dXJuIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gb2JqZWN0IGFzIGFuIGFycmF5LlxyXG4gKiBJRSBkb2Vzbid0IHN1cHBvcnQgT2JqZWN0LnZhbHVlcy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIEFuIG9iamVjdC5cclxuICpcclxuICogQHJldHVybiB7QXJyYXl9IC0gQW4gYXJyYXkgY29udGFpbmluZyBhbGwgdmFsdWVzIG9mIHRoZSBnaXZlbiBvYmplY3QuXHJcbiAqL1xuXG5mdW5jdGlvbiB2YWx1ZXMob2JqKSB7XG4gIHJldHVybiBrZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH0pO1xufVxuLyoqXHJcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBzdWJqZWN0IGlzIG9iamVjdCBvciBub3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gc3ViamVjdCAtIEEgc3ViamVjdCB0byBiZSB2ZXJpZmllZC5cclxuICpcclxuICogQHJldHVybiB7Ym9vbGVhbn0gLSBUcnVlIGlmIG9iamVjdCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZnVuY3Rpb24gaXNPYmplY3Qoc3ViamVjdCkge1xuICByZXR1cm4gdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnO1xufVxuLyoqXHJcbiAqIE1lcmdlIHR3byBvYmplY3RzIGRlZXBseS5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHRvICAgLSBBbiBvYmplY3Qgd2hlcmUgXCJmcm9tXCIgaXMgbWVyZ2VkLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZnJvbSAtIEFuIG9iamVjdCBtZXJnZWQgdG8gXCJ0b1wiLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gQSBtZXJnZWQgb2JqZWN0LlxyXG4gKi9cblxuZnVuY3Rpb24gbWVyZ2UoX3JlZiwgZnJvbSkge1xuICB2YXIgdG8gPSBfZXh0ZW5kcyh7fSwgX3JlZik7XG5cbiAgZWFjaChmcm9tLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIGlmICghaXNPYmplY3QodG9ba2V5XSkpIHtcbiAgICAgICAgdG9ba2V5XSA9IHt9O1xuICAgICAgfVxuXG4gICAgICB0b1trZXldID0gbWVyZ2UodG9ba2V5XSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b1trZXldID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRvO1xufVxuLyoqXHJcbiAqIEFzc2lnbiBhbGwgcHJvcGVydGllcyBcImZyb21cIiB0byBcInRvXCIgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gdG8gICAtIEFuIG9iamVjdCB3aGVyZSBwcm9wZXJ0aWVzIGFyZSBhc3NpZ25lZC5cclxuICogQHBhcmFtIHtPYmplY3R9IGZyb20gLSBBbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgYXNzaWduZWQgdG8gXCJ0b1wiLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gQW4gYXNzaWduZWQgb2JqZWN0LlxyXG4gKi9cblxuZnVuY3Rpb24gb2JqZWN0X2Fzc2lnbih0bywgZnJvbSkge1xuICBrZXlzKGZyb20pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghdG9ba2V5XSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZnJvbSwga2V5KSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRvO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL3V0aWxzL3V0aWxzLmpzXG4vKipcclxuICogQSBwYWNrYWdlIG9mIHNvbWUgbWlzY2VsbGFuZW91cyB1dGlsaXR5IGZ1bmN0aW9ucy5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG4vKipcclxuICogQ29udmVydCB0aGUgZ2l2ZW4gdmFsdWUgdG8gYXJyYXkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBBbnkgdmFsdWUuXHJcbiAqXHJcbiAqIEByZXR1cm4geypbXX0gLSBBcnJheSBjb250YWluaW5nIHRoZSBnaXZlbiB2YWx1ZS5cclxuICovXG5cbmZ1bmN0aW9uIHRvQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xufVxuLyoqXHJcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LlxyXG4gKiBNaW4gd2lsbCBiZSByZXR1cm5lZCB3aGVuIHRoZSB2YWx1ZSBpcyBsZXNzIHRoYW4gbWluIG9yIG1heCB3aWxsIGRvIHdoZW4gZ3JlYXRlciB0aGFuIG1heC5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gQSBudW1iZXIgdG8gYmUgY2hlY2tlZC5cclxuICogQHBhcmFtIHtudW1iZXJ9IG0xICAgIC0gTWluaW11bSBvciBtYXhpbXVtIG51bWJlci5cclxuICogQHBhcmFtIHtudW1iZXJ9IG0yICAgIC0gTWF4aW11bSBvciBtaW5pbXVtIG51bWJlci5cclxuICpcclxuICogQHJldHVybiB7bnVtYmVyfSAtIEEgdmFsdWUgaXRzZWxmLCBtaW4gb3IgbWF4LlxyXG4gKi9cblxuZnVuY3Rpb24gYmV0d2Vlbih2YWx1ZSwgbTEsIG0yKSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbTEgPiBtMiA/IG0yIDogbTEpLCBtMSA+IG0yID8gbTEgOiBtMik7XG59XG4vKipcclxuICogVGhlIHNwcmludGYgbWV0aG9kIHdpdGggbWluaW11bSBmdW5jdGlvbmFsaXR5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgZm9ybWF0ICAgICAgIC0gVGhlIHN0cmluZyBmb3JtYXQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSByZXBsYWNlbWVudHMgLSBSZXBsYWNlbWVudHMgYWNjZXB0aW5nIG11bHRpcGxlIGFyZ3VtZW50cy5cclxuICpcclxuICogQHJldHVybnMge3N0cmluZ30gLSBDb252ZXJ0ZWQgc3RyaW5nLlxyXG4gKi9cblxuZnVuY3Rpb24gc3ByaW50Zihmb3JtYXQsIHJlcGxhY2VtZW50cykge1xuICB2YXIgaSA9IDA7XG4gIHJldHVybiBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0b0FycmF5KHJlcGxhY2VtZW50cylbaSsrXTtcbiAgfSk7XG59XG4vKipcclxuICogQXBwZW5kIHB4IHVuaXQgdG8gdGhlIGdpdmVuIHN1YmplY3QgaWYgbmVjZXNzYXJ5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHZhbHVlIC0gQSB2YWx1ZSB0aGF0IG1heSBub3QgaW5jbHVkZSBhbiB1bml0LlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IC0gSWYgdGhlIHZhbHVlIGlzIHN0cmluZywgcmV0dXJuIGl0c2VsZi5cclxuICogICAgICAgICAgICAgICAgICAgIElmIG51bWJlciwgZG8gdmFsdWUgKyBcInB4XCIuIEFuIGVtcHR5IHN0cmluZywgb3RoZXJ3aXNlLlxyXG4gKi9cblxuZnVuY3Rpb24gdW5pdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuICBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpICsgJ3B4JztcbiAgfVxuXG4gIHJldHVybiB0eXBlID09PSAnc3RyaW5nJyA/IHZhbHVlIDogJyc7XG59XG4vKipcclxuICogUGFkIHN0YXJ0IHdpdGggMC5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciAtIEEgbnVtYmVyIHRvIGJlIGZpbGxlZCB3aXRoIDAuXHJcbiAqXHJcbiAqIEByZXR1cm4ge3N0cmluZ3xudW1iZXJ9IC0gUGFkZGVkIG51bWJlci5cclxuICovXG5cbmZ1bmN0aW9uIHBhZChudW1iZXIpIHtcbiAgcmV0dXJuIG51bWJlciA8IDEwID8gJzAnICsgbnVtYmVyIDogbnVtYmVyO1xufVxuLyoqXHJcbiAqIENvbnZlcnQgdGhlIGdpdmVuIHZhbHVlIHRvIHBpeGVsLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9ICAgICAgIHJvb3QgIC0gUm9vdCBlbGVtZW50IHdoZXJlIGEgZHVtbXkgZGl2IGlzIGFwcGVuZGVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHZhbHVlIC0gQ1NTIHZhbHVlIHRvIGJlIGNvbnZlcnRlZCwgc3VjaCBhcyAxMHJlbS5cclxuICpcclxuICogQHJldHVybiB7bnVtYmVyfSAtIFBpeGVsLlxyXG4gKi9cblxuZnVuY3Rpb24gdG9QaXhlbChyb290LCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhciBkaXYgPSBjcmVhdGUoJ2RpdicsIHt9KTtcbiAgICBhcHBseVN0eWxlKGRpdiwge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB3aWR0aDogdmFsdWVcbiAgICB9KTtcbiAgICBhcHBlbmQocm9vdCwgZGl2KTtcbiAgICB2YWx1ZSA9IGRpdi5jbGllbnRXaWR0aDtcbiAgICBkb21fcmVtb3ZlKGRpdik7XG4gIH1cblxuICByZXR1cm4gK3ZhbHVlIHx8IDA7XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvdXRpbHMvZG9tLmpzXG4vKipcclxuICogU29tZSB1dGlsaXR5IGZ1bmN0aW9ucyByZWxhdGVkIHdpdGggRE9NLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cblxuLyoqXHJcbiAqIEZpbmQgdGhlIGZpcnN0IGVsZW1lbnQgbWF0Y2hpbmcgdGhlIGdpdmVuIHNlbGVjdG9yLlxyXG4gKiBCZSBhd2FyZSB0aGF0IGFsbCBzZWxlY3RvcnMgYWZ0ZXIgYSBzcGFjZSBhcmUgaWdub3JlZC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fE5vZGV9ICBlbG0gICAgICAgLSBBbiBhbmNlc3RvciBlbGVtZW50LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgIHNlbGVjdG9yICAtIERPTVN0cmluZy5cclxuICpcclxuICogQHJldHVybiB7RWxlbWVudHxudWxsfSAtIEEgZm91bmQgZWxlbWVudCBvciBudWxsLlxyXG4gKi9cblxuZnVuY3Rpb24gZmluZChlbG0sIHNlbGVjdG9yKSB7XG4gIHJldHVybiBlbG0gPyBlbG0ucXVlcnlTZWxlY3RvcihzZWxlY3Rvci5zcGxpdCgnICcpWzBdKSA6IG51bGw7XG59XG4vKipcclxuICogRmluZCBhIGZpcnN0IGNoaWxkIGhhdmluZyB0aGUgZ2l2ZW4gdGFnIG9yIGNsYXNzIG5hbWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50ICAgICAgICAgLSBBIHBhcmVudCBlbGVtZW50LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gIHRhZ09yQ2xhc3NOYW1lIC0gQSB0YWcgb3IgY2xhc3MgbmFtZS5cclxuICpcclxuICogQHJldHVybiB7RWxlbWVudHx1bmRlZmluZWR9IC0gQSBmb3VuZCBlbGVtZW50IG9uIHN1Y2Nlc3Mgb3IgdW5kZWZpbmVkIG9uIGZhaWx1cmUuXHJcbiAqL1xuXG5mdW5jdGlvbiBjaGlsZChwYXJlbnQsIHRhZ09yQ2xhc3NOYW1lKSB7XG4gIHJldHVybiBjaGlsZHJlbihwYXJlbnQsIHRhZ09yQ2xhc3NOYW1lKVswXTtcbn1cbi8qKlxyXG4gKiBSZXR1cm4gY2hpbGUgZWxlbWVudHMgdGhhdCBtYXRjaGVzIHRoZSBwcm92aWRlZCB0YWcgb3IgY2xhc3MgbmFtZS5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnQgICAgICAgICAtIEEgcGFyZW50IGVsZW1lbnQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSAgdGFnT3JDbGFzc05hbWUgLSBBIHRhZyBvciBjbGFzcyBuYW1lLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtFbGVtZW50W119IC0gRm91bmQgZWxlbWVudHMuXHJcbiAqL1xuXG5mdW5jdGlvbiBjaGlsZHJlbihwYXJlbnQsIHRhZ09yQ2xhc3NOYW1lKSB7XG4gIGlmIChwYXJlbnQpIHtcbiAgICByZXR1cm4gdmFsdWVzKHBhcmVudC5jaGlsZHJlbikuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgcmV0dXJuIGhhc0NsYXNzKGNoaWxkLCB0YWdPckNsYXNzTmFtZS5zcGxpdCgnICcpWzBdKSB8fCBjaGlsZC50YWdOYW1lID09PSB0YWdPckNsYXNzTmFtZTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBbXTtcbn1cbi8qKlxyXG4gKiBDcmVhdGUgYW4gZWxlbWVudCB3aXRoIHNvbWUgb3B0aW9uYWwgYXR0cmlidXRlcy5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyAgIC0gQSB0YWcgbmFtZS5cclxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJzIC0gQW4gb2JqZWN0IGFueSBhdHRyaWJ1dGUgcGFpcnMgb2YgbmFtZSBhbmQgdmFsdWUuXHJcbiAqXHJcbiAqIEByZXR1cm4ge0VsZW1lbnR9IC0gQSBjcmVhdGVkIGVsZW1lbnQuXHJcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGUodGFnLCBhdHRycykge1xuICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBlYWNoKGF0dHJzLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgIHJldHVybiBzZXRBdHRyaWJ1dGUoZWxtLCBrZXksIHZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiBlbG07XG59XG4vKipcclxuICogQ29udmVydCBIVE1MIHN0cmluZyB0byBET00gbm9kZS5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWwgLSBIVE1MIHN0cmluZy5cclxuICpcclxuICogQHJldHVybiB7Tm9kZX0gLSBBIGNyZWF0ZWQgbm9kZS5cclxuICovXG5cbmZ1bmN0aW9uIGRvbWlmeShodG1sKSB7XG4gIHZhciBkaXYgPSBjcmVhdGUoJ2RpdicsIHt9KTtcbiAgZGl2LmlubmVySFRNTCA9IGh0bWw7XG4gIHJldHVybiBkaXYuZmlyc3RDaGlsZDtcbn1cbi8qKlxyXG4gKiBSZW1vdmUgYSBnaXZlbiBlbGVtZW50IGZyb20gYSBET00gdHJlZS5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fEVsZW1lbnRbXX0gZWxtcyAtIEVsZW1lbnQocykgdG8gYmUgcmVtb3ZlZC5cclxuICovXG5cbmZ1bmN0aW9uIGRvbV9yZW1vdmUoZWxtcykge1xuICB0b0FycmF5KGVsbXMpLmZvckVhY2goZnVuY3Rpb24gKGVsbSkge1xuICAgIGlmIChlbG0pIHtcbiAgICAgIHZhciBwYXJlbnQgPSBlbG0ucGFyZW50RWxlbWVudDtcbiAgICAgIHBhcmVudCAmJiBwYXJlbnQucmVtb3ZlQ2hpbGQoZWxtKTtcbiAgICB9XG4gIH0pO1xufVxuLyoqXHJcbiAqIEFwcGVuZCBhIGNoaWxkIHRvIGEgZ2l2ZW4gZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnQgLSBBIHBhcmVudCBlbGVtZW50LlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNoaWxkICAtIEFuIGVsZW1lbnQgdG8gYmUgYXBwZW5kZWQuXHJcbiAqL1xuXG5mdW5jdGlvbiBhcHBlbmQocGFyZW50LCBjaGlsZCkge1xuICBpZiAocGFyZW50KSB7XG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgfVxufVxuLyoqXHJcbiAqIEluc2VydCBhbiBlbGVtZW50IGJlZm9yZSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudHxOb2RlfSByZWYgLSBBIHJlZmVyZW5jZSBlbGVtZW50LlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9ICAgICAgZWxtIC0gQW4gZWxlbWVudCB0byBiZSBpbnNlcnRlZC5cclxuICovXG5cbmZ1bmN0aW9uIGJlZm9yZShlbG0sIHJlZikge1xuICBpZiAoZWxtICYmIHJlZikge1xuICAgIHZhciBwYXJlbnQgPSByZWYucGFyZW50RWxlbWVudDtcbiAgICBwYXJlbnQgJiYgcGFyZW50Lmluc2VydEJlZm9yZShlbG0sIHJlZik7XG4gIH1cbn1cbi8qKlxyXG4gKiBBcHBseSBzdHlsZXMgdG8gdGhlIGdpdmVuIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxtICAgICAtIEFuIGVsZW1lbnQgd2hlcmUgc3R5bGVzIGFyZSBhcHBsaWVkLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gIHN0eWxlcyAgLSBPYmplY3QgY29udGFpbmluZyBzdHlsZXMuXHJcbiAqL1xuXG5mdW5jdGlvbiBhcHBseVN0eWxlKGVsbSwgc3R5bGVzKSB7XG4gIGlmIChlbG0pIHtcbiAgICBlYWNoKHN0eWxlcywgZnVuY3Rpb24gKHZhbHVlLCBwcm9wKSB7XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgZWxtLnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbi8qKlxyXG4gKiBBZGQgb3IgcmVtb3ZlIGNsYXNzZXMgdG8vZnJvbSB0aGUgZWxlbWVudC5cclxuICogVGhpcyBmdW5jdGlvbiBpcyBmb3IgaW50ZXJuYWwgdXNhZ2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gICAgICAgICBlbG0gICAgIC0gQW4gZWxlbWVudCB3aGVyZSBjbGFzc2VzIGFyZSBhZGRlZC5cclxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGNsYXNzZXMgLSBDbGFzcyBuYW1lcyBiZWluZyBhZGRlZC5cclxuICogQHBhcmFtIHtib29sZWFufSAgICAgICAgIHJlbW92ZSAgLSBXaGV0aGVyIHRvIHJlbW92ZSBvciBhZGQgY2xhc3Nlcy5cclxuICovXG5cbmZ1bmN0aW9uIGFkZE9yUmVtb3ZlQ2xhc3NlcyhlbG0sIGNsYXNzZXMsIHJlbW92ZSkge1xuICBpZiAoZWxtKSB7XG4gICAgdG9BcnJheShjbGFzc2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICBlbG0uY2xhc3NMaXN0W3JlbW92ZSA/ICdyZW1vdmUnIDogJ2FkZCddKG5hbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4vKipcclxuICogQWRkIGNsYXNzZXMgdG8gdGhlIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gICAgICAgICAgZWxtICAgICAtIEFuIGVsZW1lbnQgd2hlcmUgY2xhc3NlcyBhcmUgYWRkZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSAgY2xhc3NlcyAtIENsYXNzIG5hbWVzIGJlaW5nIGFkZGVkLlxyXG4gKi9cblxuXG5mdW5jdGlvbiBhZGRDbGFzcyhlbG0sIGNsYXNzZXMpIHtcbiAgYWRkT3JSZW1vdmVDbGFzc2VzKGVsbSwgY2xhc3NlcywgZmFsc2UpO1xufVxuLyoqXHJcbiAqIFJlbW92ZSBhIGNsYXNzIGZyb20gdGhlIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gICAgICAgICBlbG0gICAgIC0gQW4gZWxlbWVudCB3aGVyZSBjbGFzc2VzIGFyZSByZW1vdmVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gY2xhc3NlcyAtIEEgY2xhc3MgbmFtZSBiZWluZyByZW1vdmVkLlxyXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxtLCBjbGFzc2VzKSB7XG4gIGFkZE9yUmVtb3ZlQ2xhc3NlcyhlbG0sIGNsYXNzZXMsIHRydWUpO1xufVxuLyoqXHJcbiAqIFZlcmlmeSBpZiB0aGUgcHJvdmlkZWQgZWxlbWVudCBoYXMgdGhlIGNsYXNzIG9yIG5vdC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSBlbG0gICAgICAgLSBBbiBlbGVtZW50LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gIGNsYXNzTmFtZSAtIEEgY2xhc3MgbmFtZS5cclxuICpcclxuICogQHJldHVybiB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRoZSBlbGVtZW50IGhhcyB0aGUgY2xhc3Mgb3IgZmFsc2UgaWYgbm90LlxyXG4gKi9cblxuZnVuY3Rpb24gaGFzQ2xhc3MoZWxtLCBjbGFzc05hbWUpIHtcbiAgcmV0dXJuICEhZWxtICYmIGVsbS5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKTtcbn1cbi8qKlxyXG4gKiBTZXQgYXR0cmlidXRlIHRvIHRoZSBnaXZlbiBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9ICAgICAgICAgICAgICAgICBlbG0gICAtIEFuIGVsZW1lbnQgd2hlcmUgYW4gYXR0cmlidXRlIGlzIGFzc2lnbmVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgICBuYW1lICAtIEF0dHJpYnV0ZSBuYW1lLlxyXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8Ym9vbGVhbn0gICB2YWx1ZSAtIEF0dHJpYnV0ZSB2YWx1ZS5cclxuICovXG5cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZShlbG0sIG5hbWUsIHZhbHVlKSB7XG4gIGlmIChlbG0pIHtcbiAgICBlbG0uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgfVxufVxuLyoqXHJcbiAqIEdldCBhdHRyaWJ1dGUgZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSBlbG0gIC0gQW4gZWxlbWVudCB3aGVyZSBhbiBhdHRyaWJ1dGUgaXMgYXNzaWduZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSAgbmFtZSAtIEF0dHJpYnV0ZSBuYW1lLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IC0gVGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBhdHRyaWJ1dGUgaWYgYXZhaWxhYmxlLiBBbiBlbXB0eSBzdHJpbmcgaWYgbm90LlxyXG4gKi9cblxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlKGVsbSwgbmFtZSkge1xuICByZXR1cm4gZWxtID8gZWxtLmdldEF0dHJpYnV0ZShuYW1lKSA6ICcnO1xufVxuLyoqXHJcbiAqIFJlbW92ZSBhdHRyaWJ1dGUgZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fEVsZW1lbnRbXX0gZWxtcyAgLSBBbiBlbGVtZW50IHdoZXJlIGFuIGF0dHJpYnV0ZSBpcyByZW1vdmVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gICAgICBuYW1lcyAtIEF0dHJpYnV0ZSBuYW1lLlxyXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlQXR0cmlidXRlKGVsbXMsIG5hbWVzKSB7XG4gIHRvQXJyYXkobmFtZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0b0FycmF5KGVsbXMpLmZvckVhY2goZnVuY3Rpb24gKGVsbSkge1xuICAgICAgcmV0dXJuIGVsbSAmJiBlbG0ucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH0pO1xuICB9KTtcbn1cbi8qKlxyXG4gKiBSZXR1cm4gdGhlIFJlY3Qgb2JqZWN0IG9mIHRoZSBwcm92aWRlZCBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxtIC0gQW4gZWxlbWVudC5cclxuICpcclxuICogQHJldHVybiB7Q2xpZW50UmVjdHxET01SZWN0fSAtIEEgcmVjdCBvYmplY3QuXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRSZWN0KGVsbSkge1xuICByZXR1cm4gZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuLyoqXHJcbiAqIFRyaWdnZXIgdGhlIGdpdmVuIGNhbGxiYWNrIGFmdGVyIGFsbCBpbWFnZXMgY29udGFpbmVkIGJ5IHRoZSBlbGVtZW50IGFyZSBsb2FkZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gIGVsbSAgICAgIC0gRWxlbWVudCB0aGF0IG1heSBjb250YWluIGltYWdlcy5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayBmdW5jdGlvbiBmaXJlZCByaWdodCBhZnRlciBhbGwgaW1hZ2VzIGFyZSBsb2FkZWQuXHJcbiAqL1xuXG5mdW5jdGlvbiBsb2FkZWQoZWxtLCBjYWxsYmFjaykge1xuICB2YXIgaW1hZ2VzID0gZWxtLnF1ZXJ5U2VsZWN0b3JBbGwoJ2ltZycpO1xuICB2YXIgbGVuZ3RoID0gaW1hZ2VzLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoKSB7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICBlYWNoKGltYWdlcywgZnVuY3Rpb24gKGltZykge1xuICAgICAgaW1nLm9ubG9hZCA9IGltZy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoKytjb3VudCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUcmlnZ2VyIHRoZSBjYWxsYmFjayBpbW1lZGlhdGVseSBpZiB0aGVyZSBpcyBubyBpbWFnZS5cbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29uc3RhbnRzL3R5cGVzLmpzXG4vKipcclxuICogRXhwb3J0IHNsaWRlciB0eXBlcy5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG4vKipcclxuICogTm9ybWFsIHNsaWRlci5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXG52YXIgU0xJREUgPSAnc2xpZGUnO1xuLyoqXHJcbiAqIExvb3AgYWZ0ZXIgdGhlIGxhc3Qgc2xpZGUgYW5kIGJlZm9yZSB0aGUgZmlyc3Qgb25lLlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cblxudmFyIExPT1AgPSAnbG9vcCc7XG4vKipcclxuICogVGhlIHRyYWNrIGRvZXNuJ3QgbW92ZS5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXG5cbnZhciBGQURFID0gJ2ZhZGUnO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL3RyYW5zaXRpb25zL3NsaWRlL2luZGV4LmpzXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgZ2VuZXJhbCBzbGlkZSBlZmZlY3QgdHJhbnNpdGlvbi5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG5cbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBnZW5lcmFsIHNsaWRlIGVmZmVjdCB0cmFuc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NwbGlkZX0gU3BsaWRlICAgICAtIEEgU3BsaWRlIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gQ29tcG9uZW50cyAtIEFuIG9iamVjdCBjb250YWluaW5nIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBUaGUgY29tcG9uZW50IG9iamVjdC5cclxuICovXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3Qgc2xpZGUgPSAoZnVuY3Rpb24gKFNwbGlkZSwgQ29tcG9uZW50cykge1xuICAvKipcclxuICAgKiBIb2xkIHRoZSBsaXN0IGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7RWxlbWVudH1cclxuICAgKi9cbiAgdmFyIGxpc3Q7XG4gIC8qKlxyXG4gICAqIEhvbGQgdGhlIG9uRW5kIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Z1bmN0aW9ufVxyXG4gICAqL1xuXG4gIHZhciBlbmRDYWxsYmFjaztcbiAgcmV0dXJuIHtcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cclxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIGxpc3QgPSBDb21wb25lbnRzLkVsZW1lbnRzLmxpc3Q7XG4gICAgICBTcGxpZGUub24oJ3RyYW5zaXRpb25lbmQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGxpc3QgJiYgZW5kQ2FsbGJhY2spIHtcbiAgICAgICAgICBlbmRDYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9LCBsaXN0KTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydCB0cmFuc2l0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSAgIGRlc3RJbmRleCAtIERlc3RpbmF0aW9uIHNsaWRlIGluZGV4IHRoYXQgbWlnaHQgYmUgY2xvbmUncy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSAgIG5ld0luZGV4ICAtIE5ldyBpbmRleC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSAgIHByZXZJbmRleCAtIFByZXZpb3VzIGluZGV4LlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgY29vcmQgICAgIC0gRGVzdGluYXRpb24gY29vcmRpbmF0ZXMuXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBkb25lICAgICAgLSBDYWxsYmFjayBmdW5jdGlvbiBtdXN0IGJlIGludm9rZWQgd2hlbiB0cmFuc2l0aW9uIGlzIGNvbXBsZXRlZC5cclxuICAgICAqL1xuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydChkZXN0SW5kZXgsIG5ld0luZGV4LCBwcmV2SW5kZXgsIGNvb3JkLCBkb25lKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IFNwbGlkZS5vcHRpb25zO1xuICAgICAgdmFyIGVkZ2VJbmRleCA9IENvbXBvbmVudHMuQ29udHJvbGxlci5lZGdlSW5kZXg7XG4gICAgICB2YXIgc3BlZWQgPSBvcHRpb25zLnNwZWVkO1xuICAgICAgZW5kQ2FsbGJhY2sgPSBkb25lO1xuXG4gICAgICBpZiAoU3BsaWRlLmlzKFNMSURFKSkge1xuICAgICAgICBpZiAocHJldkluZGV4ID09PSAwICYmIG5ld0luZGV4ID49IGVkZ2VJbmRleCB8fCBwcmV2SW5kZXggPj0gZWRnZUluZGV4ICYmIG5ld0luZGV4ID09PSAwKSB7XG4gICAgICAgICAgc3BlZWQgPSBvcHRpb25zLnJld2luZFNwZWVkIHx8IHNwZWVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFwcGx5U3R5bGUobGlzdCwge1xuICAgICAgICB0cmFuc2l0aW9uOiBcInRyYW5zZm9ybSBcIiArIHNwZWVkICsgXCJtcyBcIiArIG9wdGlvbnMuZWFzaW5nLFxuICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiICsgY29vcmQueCArIFwicHgsXCIgKyBjb29yZC55ICsgXCJweClcIlxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvdHJhbnNpdGlvbnMvZmFkZS9pbmRleC5qc1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGZhZGUgdHJhbnNpdGlvbi5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG5cbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBmYWRlIHRyYW5zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3BsaWRlfSBTcGxpZGUgICAgIC0gQSBTcGxpZGUgaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBDb21wb25lbnRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgY29tcG9uZW50cy5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAtIFRoZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gKi9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBmYWRlID0gKGZ1bmN0aW9uIChTcGxpZGUsIENvbXBvbmVudHMpIHtcbiAgdmFyIEZhZGUgPSB7XG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXHJcbiAgICAgKiBBcHBseSB0cmFuc2l0aW9uIHN0eWxlIHRvIHRoZSBmaXJzdCBzbGlkZS5cclxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIGFwcGx5KFNwbGlkZS5pbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogU3RhcnQgdHJhbnNpdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gICAgZGVzdEluZGV4IC0gRGVzdGluYXRpb24gc2xpZGUgaW5kZXggdGhhdCBtaWdodCBiZSBjbG9uZSdzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9ICAgIG5ld0luZGV4ICAtIE5ldyBpbmRleC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSAgICBwcmV2SW5kZXggLSBQcmV2aW91cyBpbmRleC5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgICBjb29yZCAgICAgLSBEZXN0aW5hdGlvbiBjb29yZGluYXRlcy5cclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259ICBkb25lICAgICAgLSBDYWxsYmFjayBmdW5jdGlvbiBtdXN0IGJlIGludm9rZWQgd2hlbiB0cmFuc2l0aW9uIGlzIGNvbXBsZXRlZC5cclxuICAgICAqL1xuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydChkZXN0SW5kZXgsIG5ld0luZGV4LCBwcmV2SW5kZXgsIGNvb3JkLCBkb25lKSB7XG4gICAgICB2YXIgdHJhY2sgPSBDb21wb25lbnRzLkVsZW1lbnRzLnRyYWNrO1xuICAgICAgYXBwbHlTdHlsZSh0cmFjaywge1xuICAgICAgICBoZWlnaHQ6IHVuaXQodHJhY2suY2xpZW50SGVpZ2h0KVxuICAgICAgfSk7XG4gICAgICBhcHBseShuZXdJbmRleCk7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICBhcHBseVN0eWxlKHRyYWNrLCB7XG4gICAgICAgICAgaGVpZ2h0OiAnJ1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogQXBwbHkgdHJhbnNpdGlvbiBzdHlsZSB0byB0aGUgc2xpZGUgc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiBpbmRleC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIEEgc2xpZGUgaW5kZXguXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gYXBwbHkoaW5kZXgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IFNwbGlkZS5vcHRpb25zO1xuICAgIGFwcGx5U3R5bGUoQ29tcG9uZW50cy5FbGVtZW50cy5zbGlkZXNbaW5kZXhdLCB7XG4gICAgICB0cmFuc2l0aW9uOiBcIm9wYWNpdHkgXCIgKyBvcHRpb25zLnNwZWVkICsgXCJtcyBcIiArIG9wdGlvbnMuZWFzaW5nXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gRmFkZTtcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL3RyYW5zaXRpb25zL2luZGV4LmpzXG4vKipcclxuICogRXhwb3J0IHRyYW5zaXRpb24gY29tcG9uZW50cy5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb3JlL2NvbXBvc2VyLmpzXG4vKipcclxuICogUHJvdmlkZSBhIGZ1bmN0aW9uIGZvciBjb21wb3NpbmcgY29tcG9uZW50cy5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG5cblxuLyoqXHJcbiAqIENvbXBvc2UgY29tcG9uZW50cy5cclxuICpcclxuICogQHBhcmFtIHtTcGxpZGV9ICAgU3BsaWRlICAgICAtIFNwbGlkZSBpbnN0YW5jZS5cclxuICogQHBhcmFtIHtPYmplY3R9ICAgQ29tcG9uZW50cyAtIEFkZGl0aW9uYWwgY29tcG9uZW50cy5cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gVHJhbnNpdGlvbiAtIENoYW5nZSBjb21wb25lbnQgZm9yIHRyYW5zaXRpb24uXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBBbiBvYmplY3QgY29udGFpbmluZyBhbGwgY29tcG9uZW50cy5cclxuICovXG5cbmZ1bmN0aW9uIGNvbXBvc2UoU3BsaWRlLCBDb21wb25lbnRzLCBUcmFuc2l0aW9uKSB7XG4gIHZhciBjb21wb25lbnRzID0ge307XG4gIGVhY2goQ29tcG9uZW50cywgZnVuY3Rpb24gKENvbXBvbmVudCwgbmFtZSkge1xuICAgIGNvbXBvbmVudHNbbmFtZV0gPSBDb21wb25lbnQoU3BsaWRlLCBjb21wb25lbnRzLCBuYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9KTtcblxuICBpZiAoIVRyYW5zaXRpb24pIHtcbiAgICBUcmFuc2l0aW9uID0gU3BsaWRlLmlzKEZBREUpID8gZmFkZSA6IHNsaWRlO1xuICB9XG5cbiAgY29tcG9uZW50cy5UcmFuc2l0aW9uID0gVHJhbnNpdGlvbihTcGxpZGUsIGNvbXBvbmVudHMpO1xuICByZXR1cm4gY29tcG9uZW50cztcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy91dGlscy9lcnJvci5qc1xuLyoqXHJcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBvdXRwdXR0aW5nIGxvZ3MuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuLyoqXHJcbiAqIFByZWZpeCBvZiBhbiBlcnJvciBtYXNzYWdlLlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cbnZhciBNRVNTQUdFX1BSRUZJWCA9ICdbU1BMSURFXSc7XG4vKipcclxuICogRGlzcGxheSBhbiBlcnJvciBtZXNzYWdlIG9uIHRoZSBicm93c2VyIGNvbnNvbGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gQW4gZXJyb3IgbWVzc2FnZS5cclxuICovXG5cbmZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UpIHtcbiAgY29uc29sZS5lcnJvcihNRVNTQUdFX1BSRUZJWCArIFwiIFwiICsgbWVzc2FnZSk7XG59XG4vKipcclxuICogQ2hlY2sgZXhpc3RlbmNlIG9mIHRoZSBnaXZlbiBvYmplY3QgYW5kIHRocm93IGFuIGVycm9yIGlmIGl0IGRvZXNuJ3QuXHJcbiAqXHJcbiAqIEB0aHJvd3Mge0Vycm9yfVxyXG4gKlxyXG4gKiBAcGFyYW0geyp9ICAgICAgc3ViamVjdCAtIEEgc3ViamVjdCB0byBiZSBjb25maXJtZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gQW4gZXJyb3IgbWVzc2FnZS5cclxuICovXG5cbmZ1bmN0aW9uIGV4aXN0KHN1YmplY3QsIG1lc3NhZ2UpIHtcbiAgaWYgKCFzdWJqZWN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29uc3RhbnRzL2NsYXNzZXMuanNcbi8qKlxyXG4gKiBFeHBvcnQgY2xhc3MgbmFtZXMuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuLyoqXHJcbiAqIEEgcm9vdCBjbGFzcyBuYW1lLlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cbnZhciBST09UID0gJ3NwbGlkZSc7XG4vKipcclxuICogVGhlIGRlZmluaXRpb24gdGFibGUgb2YgYWxsIGNsYXNzZXMgZm9yIGVsZW1lbnRzLlxyXG4gKiBUaGV5IG1pZ2h0IGJlIG1vZGlmaWVkIGJ5IG9wdGlvbnMuXHJcbiAqXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqL1xuXG52YXIgRUxFTUVOVF9DTEFTU0VTID0ge1xuICByb290OiBST09ULFxuICBzbGlkZXI6IFJPT1QgKyBcIl9fc2xpZGVyXCIsXG4gIHRyYWNrOiBST09UICsgXCJfX3RyYWNrXCIsXG4gIGxpc3Q6IFJPT1QgKyBcIl9fbGlzdFwiLFxuICBzbGlkZTogUk9PVCArIFwiX19zbGlkZVwiLFxuICBjb250YWluZXI6IFJPT1QgKyBcIl9fc2xpZGVfX2NvbnRhaW5lclwiLFxuICBhcnJvd3M6IFJPT1QgKyBcIl9fYXJyb3dzXCIsXG4gIGFycm93OiBST09UICsgXCJfX2Fycm93XCIsXG4gIHByZXY6IFJPT1QgKyBcIl9fYXJyb3ctLXByZXZcIixcbiAgbmV4dDogUk9PVCArIFwiX19hcnJvdy0tbmV4dFwiLFxuICBwYWdpbmF0aW9uOiBST09UICsgXCJfX3BhZ2luYXRpb25cIixcbiAgcGFnZTogUk9PVCArIFwiX19wYWdpbmF0aW9uX19wYWdlXCIsXG4gIGNsb25lOiBST09UICsgXCJfX3NsaWRlLS1jbG9uZVwiLFxuICBwcm9ncmVzczogUk9PVCArIFwiX19wcm9ncmVzc1wiLFxuICBiYXI6IFJPT1QgKyBcIl9fcHJvZ3Jlc3NfX2JhclwiLFxuICBhdXRvcGxheTogUk9PVCArIFwiX19hdXRvcGxheVwiLFxuICBwbGF5OiBST09UICsgXCJfX3BsYXlcIixcbiAgcGF1c2U6IFJPT1QgKyBcIl9fcGF1c2VcIixcbiAgc3Bpbm5lcjogUk9PVCArIFwiX19zcGlubmVyXCIsXG4gIHNyOiBST09UICsgXCJfX3NyXCJcbn07XG4vKipcclxuICogRGVmaW5pdGlvbnMgb2Ygc3RhdHVzIGNsYXNzZXMuXHJcbiAqXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqL1xuXG52YXIgU1RBVFVTX0NMQVNTRVMgPSB7XG4gIGFjdGl2ZTogJ2lzLWFjdGl2ZScsXG4gIHZpc2libGU6ICdpcy12aXNpYmxlJyxcbiAgbG9hZGluZzogJ2lzLWxvYWRpbmcnXG59O1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbnN0YW50cy9pMThuLmpzXG4vKipcclxuICogRXhwb3J0IGkxOG4gdGV4dHMgYXMgb2JqZWN0LlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cbi8qKlxyXG4gKiBUZXh0cyBmb3IgaTE4bi5cclxuICpcclxuICogQHR5cGUge09iamVjdH1cclxuICovXG52YXIgSTE4TiA9IHtcbiAgcHJldjogJ1ByZXZpb3VzIHNsaWRlJyxcbiAgbmV4dDogJ05leHQgc2xpZGUnLFxuICBmaXJzdDogJ0dvIHRvIGZpcnN0IHNsaWRlJyxcbiAgbGFzdDogJ0dvIHRvIGxhc3Qgc2xpZGUnLFxuICBzbGlkZVg6ICdHbyB0byBzbGlkZSAlcycsXG4gIHBhZ2VYOiAnR28gdG8gcGFnZSAlcycsXG4gIHBsYXk6ICdTdGFydCBhdXRvcGxheScsXG4gIHBhdXNlOiAnUGF1c2UgYXV0b3BsYXknXG59O1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbnN0YW50cy9kZWZhdWx0cy5qc1xuLyoqXHJcbiAqIEV4cG9ydCBkZWZhdWx0IG9wdGlvbnMuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuXG52YXIgREVGQVVMVFMgPSB7XG4gIC8qKlxyXG4gICAqIERldGVybWluZSBhIHNsaWRlciB0eXBlLlxyXG4gICAqIC0gJ3NsaWRlJzogUmVndWxhciBzbGlkZXIuXHJcbiAgICogLSAnbG9vcCcgOiBDYXJvdXNlbCBzbGlkZXIuXHJcbiAgICogLSAnZmFkZScgOiBDaGFuZ2Ugc2xpZGVzIHdpdGggZmFkZSB0cmFuc2l0aW9uLiBwZXJQYWdlLCBkcmFnIG9wdGlvbnMgYXJlIGlnbm9yZWQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAqL1xuICB0eXBlOiAnc2xpZGUnLFxuXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdG8gcmV3aW5kIGEgc2xpZGVyIGJlZm9yZSB0aGUgZmlyc3Qgc2xpZGUgb3IgYWZ0ZXIgdGhlIGxhc3Qgb25lLlxyXG4gICAqIEluIFwibG9vcFwiIG1vZGUsIHRoaXMgb3B0aW9uIGlzIGlnbm9yZWQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cbiAgcmV3aW5kOiBmYWxzZSxcblxuICAvKipcclxuICAgKiBUcmFuc2l0aW9uIHNwZWVkIGluIG1pbGxpc2Vjb25kcy5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXG4gIHNwZWVkOiA0MDAsXG5cbiAgLyoqXHJcbiAgICogVHJhbnNpdGlvbiBzcGVlZCBvbiByZXdpbmQgaW4gbWlsbGlzZWNvbmRzLlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cbiAgcmV3aW5kU3BlZWQ6IDAsXG5cbiAgLyoqXHJcbiAgICogV2hldGhlciB0byBwcmV2ZW50IGFueSBhY3Rpb25zIHdoaWxlIGEgc2xpZGVyIGlzIHRyYW5zaXRpb25pbmcuXHJcbiAgICogSWYgZmFsc2UsIG5hdmlnYXRpb24sIGRyYWcgYW5kIHN3aXBlIHdvcmsgd2hpbGUgdGhlIHNsaWRlciBpcyBydW5uaW5nLlxyXG4gICAqIEV2ZW4gc28sIGl0IHdpbGwgYmUgZm9yY2VkIHRvIHdhaXQgZm9yIHRyYW5zaXRpb24gaW4gc29tZSBjYXNlcyBpbiB0aGUgbG9vcCBtb2RlIHRvIHNoaWZ0IGEgc2xpZGVyLlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG4gIHdhaXRGb3JUcmFuc2l0aW9uOiB0cnVlLFxuXG4gIC8qKlxyXG4gICAqIERlZmluZSBzbGlkZXIgbWF4IHdpZHRoLlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cbiAgd2lkdGg6IDAsXG5cbiAgLyoqXHJcbiAgICogRGVmaW5lIHNsaWRlciBoZWlnaHQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xuICBoZWlnaHQ6IDAsXG5cbiAgLyoqXHJcbiAgICogRml4IHdpZHRoIG9mIHNsaWRlcy4gQ1NTIGZvcm1hdCBpcyBhbGxvd2VkIHN1Y2ggYXMgMTBlbSwgODAlIG9yIDgwdncuXHJcbiAgICogcGVyUGFnZSBudW1iZXIgd2lsbCBiZSBpZ25vcmVkIHdoZW4gdGhpcyBvcHRpb24gaXMgZmFsc3kuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfHN0cmluZ31cclxuICAgKi9cbiAgZml4ZWRXaWR0aDogMCxcblxuICAvKipcclxuICAgKiBGaXggaGVpZ2h0IG9mIHNsaWRlcy4gQ1NTIGZvcm1hdCBpcyBhbGxvd2VkIHN1Y2ggYXMgMTBlbSwgODB2aCBidXQgJSB1bml0IGlzIG5vdCBhY2NlcHRlZC5cclxuICAgKiBoZWlnaHRSYXRpbyBvcHRpb24gd2lsbCBiZSBpZ25vcmVkIHdoZW4gdGhpcyBvcHRpb24gaXMgZmFsc3kuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfHN0cmluZ31cclxuICAgKi9cbiAgZml4ZWRIZWlnaHQ6IDAsXG5cbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lIGhlaWdodCBvZiBzbGlkZXMgYnkgcmF0aW8gdG8gYSBzbGlkZXIgd2lkdGguXHJcbiAgICogVGhpcyB3aWxsIGJlIGlnbm9yZWQgd2hlbiB0aGUgZml4ZWRIZWlnaHQgaXMgcHJvdmlkZWQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xuICBoZWlnaHRSYXRpbzogMCxcblxuICAvKipcclxuICAgKiBJZiB0cnVlLCBzbGlkZSB3aWR0aCB3aWxsIGJlIGRldGVybWluZWQgYnkgdGhlIGVsZW1lbnQgd2lkdGggaXRzZWxmLlxyXG4gICAqIC0gcGVyUGFnZS9wZXJNb3ZlIHNob3VsZCBiZSAxLlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG4gIGF1dG9XaWR0aDogZmFsc2UsXG5cbiAgLyoqXHJcbiAgICogSWYgdHJ1ZSwgc2xpZGUgaGVpZ2h0IHdpbGwgYmUgZGV0ZXJtaW5lZCBieSB0aGUgZWxlbWVudCB3aWR0aCBpdHNlbGYuXHJcbiAgICogLSBwZXJQYWdlL3Blck1vdmUgc2hvdWxkIGJlIDEuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cbiAgYXV0b0hlaWdodDogZmFsc2UsXG5cbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lIGhvdyBtYW55IHNsaWRlcyBzaG91bGQgYmUgZGlzcGxheWVkIHBlciBwYWdlLlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cbiAgcGVyUGFnZTogMSxcblxuICAvKipcclxuICAgKiBEZXRlcm1pbmUgaG93IG1hbnkgc2xpZGVzIHNob3VsZCBiZSBtb3ZlZCB3aGVuIGEgc2xpZGVyIGdvZXMgdG8gbmV4dCBvciBwZXJ2LlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cbiAgcGVyTW92ZTogMCxcblxuICAvKipcclxuICAgKiBEZXRlcm1pbmUgbWFudWFsbHkgaG93IG1hbnkgY2xvbmVzIHNob3VsZCBiZSBnZW5lcmF0ZWQgb24gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGUuXHJcbiAgICogVGhlIHRvdGFsIG51bWJlciBvZiBjbG9uZXMgd2lsbCBiZSB0d2ljZSBvZiB0aGlzIG51bWJlci5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXG4gIGNsb25lczogMCxcblxuICAvKipcclxuICAgKiBTdGFydCBpbmRleC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXG4gIHN0YXJ0OiAwLFxuXG4gIC8qKlxyXG4gICAqIERldGVybWluZSB3aGljaCBzbGlkZSBzaG91bGQgYmUgZm9jdXNlZCBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgc2xpZGVzIGluIGEgcGFnZS5cclxuICAgKiBBIHN0cmluZyBcImNlbnRlclwiIGlzIGFjY2VwdGFibGUgZm9yIGNlbnRlcmluZyBzbGlkZXMuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbnxudW1iZXJ8c3RyaW5nfVxyXG4gICAqL1xuICBmb2N1czogZmFsc2UsXG5cbiAgLyoqXHJcbiAgICogR2FwIGJldHdlZW4gc2xpZGVzLiBDU1MgZm9ybWF0IGlzIGFsbG93ZWQgc3VjaCBhcyAxZW0uXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfHN0cmluZ31cclxuICAgKi9cbiAgZ2FwOiAwLFxuXG4gIC8qKlxyXG4gICAqIFNldCBwYWRkaW5nLWxlZnQvcmlnaHQgaW4gaG9yaXpvbnRhbCBtb2RlIG9yIHBhZGRpbmctdG9wL2JvdHRvbSBpbiB2ZXJ0aWNhbCBvbmUuXHJcbiAgICogR2l2ZSBhIHNpbmdsZSB2YWx1ZSB0byBzZXQgYSBzYW1lIHNpemUgZm9yIGJvdGggc2lkZXMgb3JcclxuICAgKiBkbyBhbiBvYmplY3QgZm9yIGRpZmZlcmVudCBzaXplcy5cclxuICAgKiBBbHNvLCBDU1MgZm9ybWF0IGlzIGFsbG93ZWQgc3VjaCBhcyAxZW0uXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIC0gMTA6IE51bWJlclxyXG4gICAqIC0gJzFlbSc6IENTUyBmb3JtYXQuXHJcbiAgICogLSB7IGxlZnQ6IDAsIHJpZ2h0OiAyMCB9OiBPYmplY3QgZm9yIGRpZmZlcmVudCBzaXplcyBpbiBob3Jpem9udGFsIG1vZGUuXHJcbiAgICogLSB7IHRvcDogMCwgYm90dG9tOiAyMCB9OiBPYmplY3QgZm9yIGRpZmZlcmVudCBzaXplcyBpbiB2ZXJ0aWNhbCBtb2RlLlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcnxzdHJpbmd8T2JqZWN0fVxyXG4gICAqL1xuICBwYWRkaW5nOiAwLFxuXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdG8gYXBwZW5kIGFycm93cy5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuICBhcnJvd3M6IHRydWUsXG5cbiAgLyoqXHJcbiAgICogQ2hhbmdlIHRoZSBhcnJvdyBTVkcgcGF0aCBsaWtlICdtNy42MSAwLjgwNy0yLjEyLi4uJy5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICovXG4gIGFycm93UGF0aDogJycsXG5cbiAgLyoqXHJcbiAgICogV2hldGhlciB0byBhcHBlbmQgcGFnaW5hdGlvbihpbmRpY2F0b3IgZG90cykgb3Igbm90LlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG4gIHBhZ2luYXRpb246IHRydWUsXG5cbiAgLyoqXHJcbiAgICogQWN0aXZhdGUgYXV0b3BsYXkuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cbiAgYXV0b3BsYXk6IGZhbHNlLFxuXG4gIC8qKlxyXG4gICAqIEF1dG9wbGF5IGludGVydmFsIGluIG1pbGxpc2Vjb25kcy5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXG4gIGludGVydmFsOiA1MDAwLFxuXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdG8gc3RvcCBhdXRvcGxheSB3aGVuIGEgc2xpZGVyIGlzIGhvdmVyZWQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cbiAgcGF1c2VPbkhvdmVyOiB0cnVlLFxuXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdG8gc3RvcCBhdXRvcGxheSB3aGVuIGEgc2xpZGVyIGVsZW1lbnRzIGFyZSBmb2N1c2VkLlxyXG4gICAqIFRydWUgaXMgcmVjb21tZW5kZWQgZm9yIGFjY2Vzc2liaWxpdHkuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cbiAgcGF1c2VPbkZvY3VzOiB0cnVlLFxuXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdG8gcmVzZXQgcHJvZ3Jlc3Mgb2YgdGhlIGF1dG9wbGF5IHRpbWVyIHdoZW4gcmVzdW1lZC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuICByZXNldFByb2dyZXNzOiB0cnVlLFxuXG4gIC8qKlxyXG4gICAqIExvYWRpbmcgaW1hZ2VzIGxhemlseS5cclxuICAgKiBJbWFnZSBzcmMgbXVzdCBiZSBwcm92aWRlZCBieSBhIGRhdGEtc3BsaWRlLWxhenkgYXR0cmlidXRlLlxyXG4gICAqXHJcbiAgICogLSBmYWxzZTogRG8gbm90aGluZy5cclxuICAgKiAtICduZWFyYnknOiBPbmx5IGltYWdlcyBhcm91bmQgYW4gYWN0aXZlIHNsaWRlIHdpbGwgYmUgbG9hZGVkLlxyXG4gICAqIC0gJ3NlcXVlbnRpYWwnOiBBbGwgaW1hZ2VzIHdpbGwgYmUgc2VxdWVudGlhbGx5IGxvYWRlZC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufHN0cmluZ31cclxuICAgKi9cbiAgbGF6eUxvYWQ6IGZhbHNlLFxuXG4gIC8qKlxyXG4gICAqIFRoaXMgb3B0aW9uIHdvcmtzIG9ubHkgd2hlbiBhIGxhenlMb2FkIG9wdGlvbiBpcyBcIm5lYXJieVwiLlxyXG4gICAqIERldGVybWluZSBob3cgbWFueSBwYWdlcyhub3Qgc2xpZGVzKSBhcm91bmQgYW4gYWN0aXZlIHNsaWRlIHNob3VsZCBiZSBsb2FkZWQgYmVmb3JlaGFuZC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXG4gIHByZWxvYWRQYWdlczogMSxcblxuICAvKipcclxuICAgKiBFYXNpbmcgZm9yIENTUyB0cmFuc2l0aW9uLiBGb3IgZXhhbXBsZSwgbGluZWFyLCBlYXNlIG9yIGN1YmljLWJlemllcigpLlxyXG4gICAqXHJcbiAgICogQHR5cGUge3N0cmluZ31cclxuICAgKi9cbiAgZWFzaW5nOiAnY3ViaWMtYmV6aWVyKC40MiwuNjUsLjI3LC45OSknLFxuXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGtleWJvYXJkIHNob3J0Y3V0c1xyXG4gICAqIC0gdHJ1ZSBvciAnZ2xvYmFsJzogTGlzdGVuIHRvIGtleWRvd24gZXZlbnQgb2YgdGhlIGRvY3VtZW50LlxyXG4gICAqIC0gJ2ZvY3VzZWQnOiBMaXN0ZW4gdG8gdGhlIGtleWRvd24gZXZlbnQgb2YgdGhlIHNsaWRlciByb290IGVsZW1lbnQuIHRhYmluZGV4PVwiMFwiIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGVsZW1lbnQuXHJcbiAgICogLSBmYWxzZTogRGlzYWJsZSBrZXlib2FyZCBzaG9ydGN1dHMuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbnxzdHJpbmd9XHJcbiAgICovXG4gIGtleWJvYXJkOiAnZ2xvYmFsJyxcblxuICAvKipcclxuICAgKiBXaGV0aGVyIHRvIGFsbG93IG1vdXNlIGRyYWcgYW5kIHRvdWNoIHN3aXBlLlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG4gIGRyYWc6IHRydWUsXG5cbiAgLyoqXHJcbiAgICogVGhlIGFuZ2xlIHRocmVzaG9sZCBmb3IgZHJhZy5cclxuICAgKiBUaGUgc2xpZGVyIHN0YXJ0cyBtb3Zpbmcgb25seSB3aGVuIHRoZSBkcmFnIGFuZ2xlIGlzIGxlc3MgdGhhbiB0aGlzIHRocmVzaG9sZC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXG4gIGRyYWdBbmdsZVRocmVzaG9sZDogMzAsXG5cbiAgLyoqXHJcbiAgICogRGlzdGFuY2UgdGhyZXNob2xkIGZvciBkZXRlcm1pbmluZyBpZiB0aGUgYWN0aW9uIGlzIFwiZmxpY2tcIiBvciBcInN3aXBlXCIuXHJcbiAgICogV2hlbiBhIGRyYWcgZGlzdGFuY2UgaXMgb3ZlciB0aGlzIHZhbHVlLCB0aGUgYWN0aW9uIHdpbGwgYmUgdHJlYXRlZCBhcyBcInN3aXBlXCIsIG5vdCBcImZsaWNrXCIuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xuICBzd2lwZURpc3RhbmNlVGhyZXNob2xkOiAxNTAsXG5cbiAgLyoqXHJcbiAgICogVmVsb2NpdHkgdGhyZXNob2xkIGZvciBkZXRlcm1pbmluZyBpZiB0aGUgYWN0aW9uIGlzIFwiZmxpY2tcIiBvciBcInN3aXBlXCIuXHJcbiAgICogQXJvdW5kIDAuNSBpcyByZWNvbW1lbmRlZC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXG4gIGZsaWNrVmVsb2NpdHlUaHJlc2hvbGQ6IC42LFxuXG4gIC8qKlxyXG4gICAqIERldGVybWluZSBwb3dlciBvZiBmbGljay4gVGhlIGxhcmdlciBudW1iZXIgdGhpcyBpcywgdGhlIGZhcnRoZXIgYSBzbGlkZXIgcnVucyBieSBmbGljay5cclxuICAgKiBBcm91bmQgNTAwIGlzIHJlY29tbWVuZGVkLlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cbiAgZmxpY2tQb3dlcjogNjAwLFxuXG4gIC8qKlxyXG4gICAqIExpbWl0IGEgbnVtYmVyIG9mIHBhZ2VzIHRvIG1vdmUgYnkgZmxpY2suXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xuICBmbGlja01heFBhZ2VzOiAxLFxuXG4gIC8qKlxyXG4gICAqIFNsaWRlciBkaXJlY3Rpb24uXHJcbiAgICogLSAnbHRyJzogTGVmdCB0byByaWdodC5cclxuICAgKiAtICdydGwnOiBSaWdodCB0byBsZWZ0LlxyXG4gICAqIC0gJ3R0Yic6IFRvcCB0byBib3R0b20uXHJcbiAgICpcclxuICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAqL1xuICBkaXJlY3Rpb246ICdsdHInLFxuXG4gIC8qKlxyXG4gICAqIFNldCBpbWcgc3JjIHRvIGJhY2tncm91bmQtaW1hZ2Ugb2YgaXRzIHBhcmVudCBlbGVtZW50LlxyXG4gICAqIEltYWdlcyB3aXRoIHZhcmlvdXMgc2l6ZXMgY2FuIGJlIGRpc3BsYXllZCBhcyBzYW1lIGRpbWVuc2lvbiB3aXRob3V0IGNyb3BwaW5nIHdvcmsuXHJcbiAgICogZml4ZWRIZWlnaHQgb3IgaGVpZ2h0UmF0aW8gaXMgcmVxdWlyZWQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cbiAgY292ZXI6IGZhbHNlLFxuXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGFjY2Vzc2liaWxpdHkoYXJpYSBhbmQgc2NyZWVuIHJlYWRlciB0ZXh0cykgb3Igbm90LlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG4gIGFjY2Vzc2liaWxpdHk6IHRydWUsXG5cbiAgLyoqXHJcbiAgICogV2hldGhlciB0byBhZGQgdGFiaW5kZXg9XCIwXCIgdG8gdmlzaWJsZSBzbGlkZXMgb3Igbm90LlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG4gIHNsaWRlRm9jdXM6IHRydWUsXG5cbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lIGlmIGEgc2xpZGVyIGlzIG5hdmlnYXRpb24gZm9yIGFub3RoZXIuXHJcbiAgICogVXNlIFwic3luY1wiIEFQSSB0byBzeW5jaHJvbml6ZSB0d28gc2xpZGVycy5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuICBpc05hdmlnYXRpb246IGZhbHNlLFxuXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdG8gdHJpbSBzcGFjZXMgYmVmb3JlIHRoZSBmaXN0IHNsaWRlIG9yIGFmdGVyIHRoZSBsYXN0IG9uZSB3aGVuIFwiZm9jdXNcIiBpcyBub3QgMC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuICB0cmltU3BhY2U6IHRydWUsXG5cbiAgLyoqXHJcbiAgICogVGhlIFwiaXMtYWN0aXZlXCIgY2xhc3MgaXMgYWRkZWQgYWZ0ZXIgdHJhbnNpdGlvbiBhcyBkZWZhdWx0LlxyXG4gICAqIElmIHRydWUsIGl0IHdpbGwgYmUgYWRkZWQgYmVmb3JlIG1vdmUuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cbiAgdXBkYXRlT25Nb3ZlOiBmYWxzZSxcblxuICAvKipcclxuICAgKiBUaHJvdHRsZSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSByZXNpemUgZXZlbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xuICB0aHJvdHRsZTogMTAwLFxuXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdG8gZGVzdHJveSBhIHNsaWRlciBvciBub3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cbiAgZGVzdHJveTogZmFsc2UsXG5cbiAgLyoqXHJcbiAgICogT3B0aW9ucyBmb3Igc3BlY2lmaWMgYnJlYWtwb2ludHMuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZVxyXG4gICAqIHtcclxuICAgKiAgIDEwMDA6IHtcclxuICAgKiAgICAgcGVyUGFnZTogMyxcclxuICAgKiAgICAgZ2FwOiAyMFxyXG4gICAqICAgfSxcclxuICAgKiAgIDYwMDoge1xyXG4gICAqICAgICBwZXJQYWdlOiAxLFxyXG4gICAqICAgICBnYXA6IDUsXHJcbiAgICogICB9XHJcbiAgICogfVxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW58T2JqZWN0fVxyXG4gICAqL1xuICBicmVha3BvaW50czogZmFsc2UsXG5cbiAgLyoqXHJcbiAgICogQ29sbGVjdGlvbiBvZiBjbGFzcyBuYW1lcy5cclxuICAgKlxyXG4gICAqIEBzZWUgLi9jbGFzc2VzLmpzXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuICBjbGFzc2VzOiBFTEVNRU5UX0NMQVNTRVMsXG5cbiAgLyoqXHJcbiAgICogQ29sbGVjdGlvbiBvZiBpMThuIHRleHRzLlxyXG4gICAqXHJcbiAgICogQHNlZSAuL2kxOG4uanNcclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG4gIGkxOG46IEkxOE5cbn07XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29uc3RhbnRzL3N0YXRlcy5qc1xuLyoqXHJcbiAqIEV4cG9ydCBzdGF0ZSBjb25zdGFudHMuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuLyoqXHJcbiAqIFNwbGlkZSBoYXMgYmVlbiBqdXN0IGNyZWF0ZWQuXHJcbiAqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqL1xudmFyIENSRUFURUQgPSAxO1xuLyoqXHJcbiAqIEFsbCBjb21wb25lbnRzIGhhdmUgYmVlbiBtb3VudGVkIGFuZCBpbml0aWFsaXplZC5cclxuICpcclxuICogQHR5cGUge251bWJlcn1cclxuICovXG5cbnZhciBNT1VOVEVEID0gMjtcbi8qKlxyXG4gKiBTcGxpZGUgaXMgcmVhZHkgZm9yIHRyYW5zaXRpb24uXHJcbiAqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqL1xuXG52YXIgSURMRSA9IDM7XG4vKipcclxuICogU3BsaWRlIGlzIG1vdmluZy5cclxuICpcclxuICogQHR5cGUge251bWJlcn1cclxuICovXG5cbnZhciBNT1ZJTkcgPSA0O1xuLyoqXHJcbiAqIFNwbGlkZSBpcyBtb3ZpbmcuXHJcbiAqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqL1xuXG52YXIgREVTVFJPWUVEID0gNTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9zcGxpZGUuanNcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuLyoqXHJcbiAqIFRoZSBtYWluIGNsYXNzIGZvciBhcHBseWluZyBTcGxpZGUgdG8gYW4gZWxlbWVudC5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG5cblxuXG5cblxuXG5cbi8qKlxyXG4gKiBUaGUgbWFpbiBjbGFzcyBmb3IgYXBwbHlpbmcgU3BsaWRlIHRvIGFuIGVsZW1lbnQsXHJcbiAqIHByb3ZpZGluZyBzb21lIEFQSXMgdG8gY29udHJvbCB0aGUgYmVoYXZpb3IuXHJcbiAqL1xuXG52YXIgU3BsaWRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXHJcbiAgICogU3BsaWRlIGNvbnN0cnVjdG9yLlxyXG4gICAqXHJcbiAgICogQHRocm93cyB7RXJyb3J9IFdoZW4gdGhlIGdpdmVuIHJvb3QgZWxlbWVudCBvciBzZWxlY3RvciBpcyBpbnZhbGlkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fHN0cmluZ30gIHJvb3QgICAgICAgLSBBIHNlbGVjdG9yIGZvciBhIHJvb3QgZWxlbWVudCBvciBhbiBlbGVtZW50IGl0c2VsZi5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgb3B0aW9ucyAgICAtIE9wdGlvbmFsLiBPcHRpb25zIHRvIGNoYW5nZSBkZWZhdWx0IGJlaGF2aW91ci5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gICAgICAgICAgQ29tcG9uZW50cyAtIE9wdGlvbmFsLiBDb21wb25lbnRzLlxyXG4gICAqL1xuICBmdW5jdGlvbiBTcGxpZGUocm9vdCwgb3B0aW9ucywgQ29tcG9uZW50cykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoQ29tcG9uZW50cyA9PT0gdm9pZCAwKSB7XG4gICAgICBDb21wb25lbnRzID0ge307XG4gICAgfVxuXG4gICAgdGhpcy5yb290ID0gcm9vdCBpbnN0YW5jZW9mIEVsZW1lbnQgPyByb290IDogZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihyb290KTtcbiAgICBleGlzdCh0aGlzLnJvb3QsICdBbiBpbnZhbGlkIGVsZW1lbnQvc2VsZWN0b3Igd2FzIGdpdmVuLicpO1xuICAgIHRoaXMuQ29tcG9uZW50cyA9IG51bGw7XG4gICAgdGhpcy5FdmVudCA9IGNvcmVfZXZlbnQoKTtcbiAgICB0aGlzLlN0YXRlID0gc3RhdGUoQ1JFQVRFRCk7XG4gICAgdGhpcy5TVEFURVMgPSBzdGF0ZXNfbmFtZXNwYWNlT2JqZWN0O1xuICAgIHRoaXMuX28gPSBtZXJnZShERUZBVUxUUywgb3B0aW9ucyk7XG4gICAgdGhpcy5faSA9IDA7XG4gICAgdGhpcy5fYyA9IENvbXBvbmVudHM7XG4gICAgdGhpcy5fZSA9IHt9OyAvLyBFeHRlbnNpb25zXG5cbiAgICB0aGlzLl90ID0gbnVsbDsgLy8gVHJhbnNpdGlvblxuICB9XG4gIC8qKlxyXG4gICAqIENvbXBvc2UgYW5kIG1vdW50IGNvbXBvbmVudHMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gICBFeHRlbnNpb25zIC0gT3B0aW9uYWwuIEFkZGl0aW9uYWwgY29tcG9uZW50cy5cclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBUcmFuc2l0aW9uIC0gT3B0aW9uYWwuIFNldCBhIGN1c3RvbSB0cmFuc2l0aW9uIGNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1NwbGlkZXx1bmRlZmluZWR9IC0gVGhpcyBpbnN0YW5jZSBvciB1bmRlZmluZWQgaWYgYW4gZXhjZXB0aW9uIG9jY3VycmVkLlxyXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFNwbGlkZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLm1vdW50ID0gZnVuY3Rpb24gbW91bnQoRXh0ZW5zaW9ucywgVHJhbnNpdGlvbikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoRXh0ZW5zaW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBFeHRlbnNpb25zID0gdGhpcy5fZTtcbiAgICB9XG5cbiAgICBpZiAoVHJhbnNpdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICBUcmFuc2l0aW9uID0gdGhpcy5fdDtcbiAgICB9XG5cbiAgICAvLyBSZXNldCB0aGUgc3RhdGUuXG4gICAgdGhpcy5TdGF0ZS5zZXQoQ1JFQVRFRCk7XG4gICAgdGhpcy5fZSA9IEV4dGVuc2lvbnM7XG4gICAgdGhpcy5fdCA9IFRyYW5zaXRpb247XG4gICAgdGhpcy5Db21wb25lbnRzID0gY29tcG9zZSh0aGlzLCBtZXJnZSh0aGlzLl9jLCBFeHRlbnNpb25zKSwgVHJhbnNpdGlvbik7XG5cbiAgICB0cnkge1xuICAgICAgZWFjaCh0aGlzLkNvbXBvbmVudHMsIGZ1bmN0aW9uIChjb21wb25lbnQsIGtleSkge1xuICAgICAgICB2YXIgcmVxdWlyZWQgPSBjb21wb25lbnQucmVxdWlyZWQ7XG5cbiAgICAgICAgaWYgKHJlcXVpcmVkID09PSB1bmRlZmluZWQgfHwgcmVxdWlyZWQpIHtcbiAgICAgICAgICBjb21wb25lbnQubW91bnQgJiYgY29tcG9uZW50Lm1vdW50KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIF90aGlzLkNvbXBvbmVudHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgU3RhdGUgPSB0aGlzLlN0YXRlO1xuICAgIFN0YXRlLnNldChNT1VOVEVEKTtcbiAgICBlYWNoKHRoaXMuQ29tcG9uZW50cywgZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgY29tcG9uZW50Lm1vdW50ZWQgJiYgY29tcG9uZW50Lm1vdW50ZWQoKTtcbiAgICB9KTtcbiAgICB0aGlzLmVtaXQoJ21vdW50ZWQnKTtcbiAgICBTdGF0ZS5zZXQoSURMRSk7XG4gICAgdGhpcy5lbWl0KCdyZWFkeScpO1xuICAgIGFwcGx5U3R5bGUodGhpcy5yb290LCB7XG4gICAgICB2aXNpYmlsaXR5OiAndmlzaWJsZSdcbiAgICB9KTtcbiAgICB0aGlzLm9uKCdtb3ZlIGRyYWcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gU3RhdGUuc2V0KE1PVklORyk7XG4gICAgfSkub24oJ21vdmVkIGRyYWdnZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gU3RhdGUuc2V0KElETEUpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxyXG4gICAqIFNldCBzeW5jIHRhcmdldC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3BsaWRlfSBzcGxpZGUgLSBBIFNwbGlkZSBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1NwbGlkZX0gLSBUaGlzIGluc3RhbmNlLlxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnN5bmMgPSBmdW5jdGlvbiBzeW5jKHNwbGlkZSkge1xuICAgIHRoaXMuc2libGluZyA9IHNwbGlkZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBSZWdpc3RlciBjYWxsYmFjayBmaXJlZCBvbiB0aGUgZ2l2ZW4gZXZlbnQocykuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gICBldmVudHMgIC0gQW4gZXZlbnQgbmFtZS4gVXNlIHNwYWNlIHRvIHNlcGFyYXRlIG11bHRpcGxlIGV2ZW50cy5cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQWxzbywgbmFtZXNwYWNlIGlzIGFjY2VwdGVkIGJ5IGRvdCwgc3VjaCBhcyAncmVzaXplLntuYW1lc3BhY2V9Jy5cclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gQSBjYWxsYmFjayBmdW5jdGlvbi5cclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9ICBlbG0gICAgIC0gT3B0aW9uYWwuIE5hdGl2ZSBldmVudCB3aWxsIGJlIGxpc3RlbmVkIHRvIHdoZW4gdGhpcyBhcmcgaXMgcHJvdmlkZWQuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9ICAgb3B0aW9ucyAtIE9wdGlvbmFsLiBPcHRpb25zIGZvciBhZGRFdmVudExpc3RlbmVyLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7U3BsaWRlfSAtIFRoaXMgaW5zdGFuY2UuXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8ub24gPSBmdW5jdGlvbiBvbihldmVudHMsIGhhbmRsZXIsIGVsbSwgb3B0aW9ucykge1xuICAgIGlmIChlbG0gPT09IHZvaWQgMCkge1xuICAgICAgZWxtID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdGhpcy5FdmVudC5vbihldmVudHMsIGhhbmRsZXIsIGVsbSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXHJcbiAgICogVW5zdWJzY3JpYmUgdGhlIGdpdmVuIGV2ZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9ICBldmVudHMgLSBBIGV2ZW50IG5hbWUuXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbG0gICAgLSBPcHRpb25hbC4gcmVtb3ZlRXZlbnRMaXN0ZW5lcigpIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhpcyBhcmcgaXMgcHJvdmlkZWQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtTcGxpZGV9IC0gVGhpcyBpbnN0YW5jZS5cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vZmYgPSBmdW5jdGlvbiBvZmYoZXZlbnRzLCBlbG0pIHtcbiAgICBpZiAoZWxtID09PSB2b2lkIDApIHtcbiAgICAgIGVsbSA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5FdmVudC5vZmYoZXZlbnRzLCBlbG0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxyXG4gICAqIEVtaXQgYW4gZXZlbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgLSBBbiBldmVudCBuYW1lLlxyXG4gICAqIEBwYXJhbSB7Kn0gICAgICBhcmdzICAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHBhc3NlZCB0byBoYW5kbGVycy5cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCkge1xuICAgIHZhciBfdGhpcyRFdmVudDtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIChfdGhpcyRFdmVudCA9IHRoaXMuRXZlbnQpLmVtaXQuYXBwbHkoX3RoaXMkRXZlbnQsIFtldmVudF0uY29uY2F0KGFyZ3MpKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxyXG4gICAqIEdvIHRvIHRoZSBzbGlkZSBzcGVjaWZpZWQgYnkgdGhlIGdpdmVuIGNvbnRyb2wuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGNvbnRyb2wgLSBBIGNvbnRyb2wgcGF0dGVybi5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgIHdhaXQgICAgLSBPcHRpb25hbC4gV2hldGhlciB0byB3YWl0IGZvciB0cmFuc2l0aW9uLlxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdvID0gZnVuY3Rpb24gZ28oY29udHJvbCwgd2FpdCkge1xuICAgIGlmICh3YWl0ID09PSB2b2lkIDApIHtcbiAgICAgIHdhaXQgPSB0aGlzLm9wdGlvbnMud2FpdEZvclRyYW5zaXRpb247XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuU3RhdGUuaXMoSURMRSkgfHwgdGhpcy5TdGF0ZS5pcyhNT1ZJTkcpICYmICF3YWl0KSB7XG4gICAgICB0aGlzLkNvbXBvbmVudHMuQ29udHJvbGxlci5nbyhjb250cm9sLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXHJcbiAgICogVmVyaWZ5IHdoZXRoZXIgdGhlIHNsaWRlciB0eXBlIGlzIHRoZSBnaXZlbiBvbmUgb3Igbm90LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBBIHNsaWRlciB0eXBlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRoZSBzbGlkZXIgdHlwZSBpcyB0aGUgcHJvdmlkZWQgdHlwZSBvciBmYWxzZSBpZiBub3QuXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8uaXMgPSBmdW5jdGlvbiBpcyh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUgPT09IHRoaXMuX28udHlwZTtcbiAgfVxuICAvKipcclxuICAgKiBJbnNlcnQgYSBzbGlkZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudHxzdHJpbmd9IHNsaWRlIC0gQSBzbGlkZSBlbGVtZW50IHRvIGJlIGFkZGVkLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgICAgICAgIGluZGV4IC0gQSBzbGlkZSB3aWxsIGJlIGFkZGVkIGF0IHRoZSBwb3NpdGlvbi5cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQoc2xpZGUsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHtcbiAgICAgIGluZGV4ID0gLTE7XG4gICAgfVxuXG4gICAgdGhpcy5Db21wb25lbnRzLkVsZW1lbnRzLmFkZChzbGlkZSwgaW5kZXgsIHRoaXMucmVmcmVzaC5iaW5kKHRoaXMpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBSZW1vdmUgdGhlIHNsaWRlIGRlc2lnbmF0ZWQgYnkgdGhlIGluZGV4LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gQSBzbGlkZSBpbmRleC5cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoaW5kZXgpIHtcbiAgICB0aGlzLkNvbXBvbmVudHMuRWxlbWVudHMucmVtb3ZlKGluZGV4KTtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBEZXN0cm95IGFsbCBTbGlkZSBvYmplY3RzIGFuZCBjbG9uZXMgYW5kIHJlY3JlYXRlIHRoZW0gYWdhaW4uXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVmcmVzaCA9IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgdGhpcy5lbWl0KCdyZWZyZXNoOmJlZm9yZScpLmVtaXQoJ3JlZnJlc2gnKS5lbWl0KCdyZXNpemUnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBEZXN0cm95IHRoZSBTcGxpZGUuXHJcbiAgICogXCJDb21wbGV0ZWx5XCIgYm9vbGVhbiBpcyBtYWlubHkgZm9yIGJyZWFrcG9pbnRzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBjb21wbGV0ZWx5IC0gRGVzdHJveSBjb21wbGV0ZWx5LlxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KGNvbXBsZXRlbHkpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIGlmIChjb21wbGV0ZWx5ID09PSB2b2lkIDApIHtcbiAgICAgIGNvbXBsZXRlbHkgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIFBvc3Rwb25lIGRlc3Ryb3kgYmVjYXVzZSBpdCBzaG91bGQgYmUgZG9uZSBhZnRlciBtb3VudC5cbiAgICBpZiAodGhpcy5TdGF0ZS5pcyhDUkVBVEVEKSkge1xuICAgICAgdGhpcy5vbigncmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuZGVzdHJveShjb21wbGV0ZWx5KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhbHVlcyh0aGlzLkNvbXBvbmVudHMpLnJldmVyc2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgIGNvbXBvbmVudC5kZXN0cm95ICYmIGNvbXBvbmVudC5kZXN0cm95KGNvbXBsZXRlbHkpO1xuICAgIH0pO1xuICAgIHRoaXMuZW1pdCgnZGVzdHJveScsIGNvbXBsZXRlbHkpOyAvLyBEZXN0cm95IGFsbCBldmVudCBoYW5kbGVycywgaW5jbHVkaW5nIG9uZXMgZm9yIG5hdGl2ZSBldmVudHMuXG5cbiAgICB0aGlzLkV2ZW50LmRlc3Ryb3koKTtcbiAgICB0aGlzLlN0YXRlLnNldChERVNUUk9ZRUQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgY3VycmVudCBzbGlkZSBpbmRleC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgY3VycmVudCBzbGlkZSBpbmRleC5cclxuICAgLy8gKi9cbiAgO1xuXG4gIF9jcmVhdGVDbGFzcyhTcGxpZGUsIFt7XG4gICAga2V5OiBcImluZGV4XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGN1cnJlbnQgc2xpZGUgaW5kZXguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBpbmRleCAtIEEgbmV3IGluZGV4LlxyXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGluZGV4KSB7XG4gICAgICB0aGlzLl9pID0gcGFyc2VJbnQoaW5kZXgpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJldHVybiBsZW5ndGggb2Ygc2xpZGVzLlxyXG4gICAgICogVGhpcyBpcyBhbiBhbGlhcyBvZiBFbGVtZW50cy5sZW5ndGguXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIEEgbnVtYmVyIG9mIHNsaWRlcy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwibGVuZ3RoXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5Db21wb25lbnRzLkVsZW1lbnRzLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IC0gT3B0aW9ucyBvYmplY3QuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9wdGlvbnNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFNldCBvcHRpb25zIHdpdGggbWVyZ2luZyB0aGUgZ2l2ZW4gb2JqZWN0IHRvIHRoZSBjdXJyZW50IG9uZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE5ldyBvcHRpb25zLlxyXG4gICAgICovXG4gICAgLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG9wdGlvbnMpIHtcbiAgICAgIHZhciBjcmVhdGVkID0gdGhpcy5TdGF0ZS5pcyhDUkVBVEVEKTtcblxuICAgICAgaWYgKCFjcmVhdGVkKSB7XG4gICAgICAgIHRoaXMuZW1pdCgndXBkYXRlJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX28gPSBtZXJnZSh0aGlzLl9vLCBvcHRpb25zKTtcblxuICAgICAgaWYgKCFjcmVhdGVkKSB7XG4gICAgICAgIHRoaXMuZW1pdCgndXBkYXRlZCcsIHRoaXMuX28pO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgY2xhc3MgbGlzdC5cclxuICAgICAqIFRoaXMgaXMgYW4gYWxpYXMgb2YgU3BsaWRlLm9wdGlvbnMuY2xhc3NMaXN0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gLSBBbiBvYmplY3QgY29udGFpbmluZyBhbGwgY2xhc3MgbGlzdC5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xhc3Nlc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX28uY2xhc3NlcztcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGkxOG4gc3RyaW5ncy5cclxuICAgICAqIFRoaXMgaXMgYW4gYWxpYXMgb2YgU3BsaWRlLm9wdGlvbnMuaTE4bi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIGkxOG4gc3RyaW5ncy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaTE4blwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX28uaTE4bjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3BsaWRlO1xufSgpO1xuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb21wb25lbnRzL29wdGlvbnMvaW5kZXguanNcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBpbml0aWFsaXppbmcgb3B0aW9ucy5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG5cblxuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGluaXRpYWxpemluZyBvcHRpb25zLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NwbGlkZX0gU3BsaWRlIC0gQSBTcGxpZGUgaW5zdGFuY2UuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBUaGUgY29tcG9uZW50IG9iamVjdC5cclxuICovXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3Qgb3B0aW9ucyA9IChmdW5jdGlvbiAoU3BsaWRlKSB7XG4gIC8qKlxyXG4gICAqIFJldHJpZXZlIG9wdGlvbnMgZnJvbSB0aGUgZGF0YSBhdHRyaWJ1dGUuXHJcbiAgICogTm90ZSB0aGF0IElFMTAgZG9lc24ndCBzdXBwb3J0IGRhdGFzZXQgcHJvcGVydHkuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAqL1xuICB2YXIgb3B0aW9ucyA9IGdldEF0dHJpYnV0ZShTcGxpZGUucm9vdCwgJ2RhdGEtc3BsaWRlJyk7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgU3BsaWRlLm9wdGlvbnMgPSBKU09OLnBhcnNlKG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yKGUubWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cclxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIGlmIChTcGxpZGUuU3RhdGUuaXMoQ1JFQVRFRCkpIHtcbiAgICAgICAgU3BsaWRlLmluZGV4ID0gU3BsaWRlLm9wdGlvbnMuc3RhcnQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29uc3RhbnRzL2RpcmVjdGlvbnMuanNcbi8qKlxyXG4gKiBFeHBvcnQgbGF5b3V0IG1vZGVzLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cbi8qKlxyXG4gKiBFbnVtZXJhdGUgc2xpZGVzIGZyb20gbGVmdCB0byByaWdodC5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXG52YXIgTFRSID0gJ2x0cic7XG4vKipcclxuICogRW51bWVyYXRlIHNsaWRlcyBmcm9tIHJpZ2h0IHRvIGxlZnQuXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xuXG52YXIgUlRMID0gJ3J0bCc7XG4vKipcclxuICogRW51bWVyYXRlIHNsaWRlcyBpbiBhIGNvbC5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXG5cbnZhciBUVEIgPSAndHRiJztcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb21wb25lbnRzL2VsZW1lbnRzL3NsaWRlLmpzXG4vKipcclxuICogVGhlIHN1YiBjb21wb25lbnQgZm9yIGhhbmRsaW5nIGVhY2ggc2xpZGUuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuXG5cblxuXG5cbi8qKlxyXG4gKiBFdmVudHMgZm9yIHJlc3RvcmluZyBvcmlnaW5hbCBzdHlsZXMuXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xuXG52YXIgU1RZTEVfUkVTVE9SRV9FVkVOVFMgPSAndXBkYXRlLnNsaWRlJztcbi8qKlxyXG4gKiBUaGUgc3ViIGNvbXBvbmVudCBmb3IgaGFuZGxpbmcgZWFjaCBzbGlkZS5cclxuICpcclxuICogQHBhcmFtIHtTcGxpZGV9ICBTcGxpZGUgICAgLSBBIFNwbGlkZSBpbnN0YW5jZS5cclxuICogQHBhcmFtIHtudW1iZXJ9ICBpbmRleCAgICAgLSBBbiB1bmlxdWUgc2xpZGUgaW5kZXguXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSAgcmVhbEluZGV4IC0gQ2xvbmVzIHNob3VsZCBwYXNzIGEgcmVhbCBzbGlkZSBpbmRleC5cclxuICogQHBhcmFtIHtFbGVtZW50fSBzbGlkZSAgICAgLSBBIHNsaWRlIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBUaGUgc3ViIGNvbXBvbmVudCBvYmplY3QuXHJcbiAqL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGVsZW1lbnRzX3NsaWRlID0gKGZ1bmN0aW9uIChTcGxpZGUsIGluZGV4LCByZWFsSW5kZXgsIHNsaWRlKSB7XG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdG8gdXBkYXRlIFwiaXMtYWN0aXZlXCIgY2xhc3MgYmVmb3JlIG9yIGFmdGVyIHRyYW5zaXRpb24uXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cbiAgdmFyIHVwZGF0ZU9uTW92ZSA9IFNwbGlkZS5vcHRpb25zLnVwZGF0ZU9uTW92ZTtcbiAgLyoqXHJcbiAgICogRXZlbnRzIHdoZW4gdGhlIHNsaWRlIHN0YXR1cyBpcyB1cGRhdGVkLlxyXG4gICAqIEFwcGVuZCBhIG5hbWVzcGFjZSB0byByZW1vdmUgbGlzdGVuZXJzIGxhdGVyLlxyXG4gICAqXHJcbiAgICogQHR5cGUge3N0cmluZ31cclxuICAgKi9cblxuICB2YXIgU1RBVFVTX1VQREFURV9FVkVOVFMgPSAncmVhZHkuc2xpZGUgdXBkYXRlZC5zbGlkZSByZXNpemVkLnNsaWRlIG1vdmVkLnNsaWRlJyArICh1cGRhdGVPbk1vdmUgPyAnIG1vdmUuc2xpZGUnIDogJycpO1xuICAvKipcclxuICAgKiBTbGlkZSBzdWIgY29tcG9uZW50IG9iamVjdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cbiAgdmFyIFNsaWRlID0ge1xuICAgIC8qKlxyXG4gICAgICogU2xpZGUgZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7RWxlbWVudH1cclxuICAgICAqL1xuICAgIHNsaWRlOiBzbGlkZSxcblxuICAgIC8qKlxyXG4gICAgICogU2xpZGUgaW5kZXguXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xuICAgIGluZGV4OiBpbmRleCxcblxuICAgIC8qKlxyXG4gICAgICogUmVhbCBpbmRleCBmb3IgY2xvbmVzLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cbiAgICByZWFsSW5kZXg6IHJlYWxJbmRleCxcblxuICAgIC8qKlxyXG4gICAgICogQ29udGFpbmVyIGVsZW1lbnQgaWYgYXZhaWxhYmxlLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtFbGVtZW50fHVuZGVmaW5lZH1cclxuICAgICAqL1xuICAgIGNvbnRhaW5lcjogY2hpbGQoc2xpZGUsIFNwbGlkZS5jbGFzc2VzLmNvbnRhaW5lciksXG5cbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhpcyBpcyBhIGNsb25lZCBzbGlkZSBvciBub3QuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cbiAgICBpc0Nsb25lOiByZWFsSW5kZXggPiAtMSxcblxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxyXG4gICAgICovXG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKCF0aGlzLmlzQ2xvbmUpIHtcbiAgICAgICAgc2xpZGUuaWQgPSBTcGxpZGUucm9vdC5pZCArIFwiLXNsaWRlXCIgKyBwYWQoaW5kZXggKyAxKTtcbiAgICAgIH1cblxuICAgICAgU3BsaWRlLm9uKFNUQVRVU19VUERBVEVfRVZFTlRTLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy51cGRhdGUoKTtcbiAgICAgIH0pLm9uKFNUWUxFX1JFU1RPUkVfRVZFTlRTLCByZXN0b3JlU3R5bGVzKS5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBTcGxpZGUuZW1pdCgnY2xpY2snLCBfdGhpcyk7XG4gICAgICB9LCBzbGlkZSk7XG4gICAgICAvKlxyXG4gICAgICAgKiBBZGQgXCJpcy1hY3RpdmVcIiBjbGFzcyB0byBhIGNsb25lIGVsZW1lbnQgdGVtcG9yYXJpbHlcclxuICAgICAgICogYW5kIGl0IHdpbGwgYmUgcmVtb3ZlZCBvbiBcIm1vdmVkXCIgZXZlbnQuXHJcbiAgICAgICAqL1xuXG4gICAgICBpZiAodXBkYXRlT25Nb3ZlKSB7XG4gICAgICAgIFNwbGlkZS5vbignbW92ZS5zbGlkZScsIGZ1bmN0aW9uIChuZXdJbmRleCkge1xuICAgICAgICAgIGlmIChuZXdJbmRleCA9PT0gcmVhbEluZGV4KSB7XG4gICAgICAgICAgICBfdXBkYXRlKHRydWUsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBNYWtlIHN1cmUgdGhlIHNsaWRlIGlzIHNob3duLlxuXG5cbiAgICAgIGFwcGx5U3R5bGUoc2xpZGUsIHtcbiAgICAgICAgZGlzcGxheTogJydcbiAgICAgIH0pOyAvLyBIb2xkIHRoZSBvcmlnaW5hbCBzdHlsZXMuXG5cbiAgICAgIHRoaXMuc3R5bGVzID0gZ2V0QXR0cmlidXRlKHNsaWRlLCAnc3R5bGUnKSB8fCAnJztcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95LlxyXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIFNwbGlkZS5vZmYoU1RBVFVTX1VQREFURV9FVkVOVFMpLm9mZihTVFlMRV9SRVNUT1JFX0VWRU5UUykub2ZmKCdjbGljaycsIHNsaWRlKTtcbiAgICAgIHJlbW92ZUNsYXNzKHNsaWRlLCB2YWx1ZXMoU1RBVFVTX0NMQVNTRVMpKTtcbiAgICAgIHJlc3RvcmVTdHlsZXMoKTtcbiAgICAgIHJlbW92ZUF0dHJpYnV0ZSh0aGlzLmNvbnRhaW5lciwgJ3N0eWxlJyk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGFjdGl2ZSBhbmQgdmlzaWJsZSBzdGF0dXMuXHJcbiAgICAgKi9cbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIF91cGRhdGUodGhpcy5pc0FjdGl2ZSgpLCBmYWxzZSk7XG5cbiAgICAgIF91cGRhdGUodGhpcy5pc1Zpc2libGUoKSwgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGlzIHNsaWRlIGlzIGFjdGl2ZSBvciBub3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRoZSBzbGlkZSBpcyBhY3RpdmUgb3IgZmFsc2UgaWYgbm90LlxyXG4gICAgICovXG4gICAgaXNBY3RpdmU6IGZ1bmN0aW9uIGlzQWN0aXZlKCkge1xuICAgICAgcmV0dXJuIFNwbGlkZS5pbmRleCA9PT0gaW5kZXg7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGlzIHNsaWRlIGlzIHZpc2libGUgaW4gdGhlIHZpZXdwb3J0IG9yIG5vdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRydWUgaWYgdGhlIHNsaWRlIGlzIHZpc2libGUgb3IgZmFsc2UgaWYgbm90LlxyXG4gICAgICovXG4gICAgaXNWaXNpYmxlOiBmdW5jdGlvbiBpc1Zpc2libGUoKSB7XG4gICAgICB2YXIgYWN0aXZlID0gdGhpcy5pc0FjdGl2ZSgpO1xuXG4gICAgICBpZiAoU3BsaWRlLmlzKEZBREUpIHx8IGFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gYWN0aXZlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2VpbCA9IE1hdGguY2VpbDtcbiAgICAgIHZhciB0cmFja1JlY3QgPSBnZXRSZWN0KFNwbGlkZS5Db21wb25lbnRzLkVsZW1lbnRzLnRyYWNrKTtcbiAgICAgIHZhciBzbGlkZVJlY3QgPSBnZXRSZWN0KHNsaWRlKTtcblxuICAgICAgaWYgKFNwbGlkZS5vcHRpb25zLmRpcmVjdGlvbiA9PT0gVFRCKSB7XG4gICAgICAgIHJldHVybiB0cmFja1JlY3QudG9wIDw9IHNsaWRlUmVjdC50b3AgJiYgc2xpZGVSZWN0LmJvdHRvbSA8PSBjZWlsKHRyYWNrUmVjdC5ib3R0b20pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJhY2tSZWN0LmxlZnQgPD0gc2xpZGVSZWN0LmxlZnQgJiYgc2xpZGVSZWN0LnJpZ2h0IDw9IGNlaWwodHJhY2tSZWN0LnJpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGUgaG93IGZhciB0aGlzIHNsaWRlIGlzIGZyb20gYW5vdGhlciBzbGlkZSBhbmRcclxuICAgICAqIHJldHVybiB0cnVlIGlmIHRoZSBkaXN0YW5jZSBpcyB3aXRoaW4gdGhlIGdpdmVuIG51bWJlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbSAgIC0gSW5kZXggb2YgYSB0YXJnZXQgc2xpZGUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2l0aGluIC0gVHJ1ZSBpZiB0aGUgc2xpZGUgaXMgd2l0aGluIHRoaXMgbnVtYmVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiB0aGUgc2xpZGUgaXMgd2l0aGluIHRoZSBudW1iZXIgb3IgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICovXG4gICAgaXNXaXRoaW46IGZ1bmN0aW9uIGlzV2l0aGluKGZyb20sIHdpdGhpbikge1xuICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyhmcm9tIC0gaW5kZXgpO1xuXG4gICAgICBpZiAoIVNwbGlkZS5pcyhTTElERSkgJiYgIXRoaXMuaXNDbG9uZSkge1xuICAgICAgICBkaWZmID0gTWF0aC5taW4oZGlmZiwgU3BsaWRlLmxlbmd0aCAtIGRpZmYpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGlmZiA8IHdpdGhpbjtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBjbGFzc2VzIGZvciBhY3Rpdml0eSBvciB2aXNpYmlsaXR5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBhY3RpdmUgICAgICAgIC0gSXMgYWN0aXZlL3Zpc2libGUgb3Igbm90LlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yVmlzaWJpbGl0eSAtIFRvZ2dsZSBjbGFzc2VzIGZvciBhY3Rpdml0eSBvciB2aXNpYmlsaXR5LlxyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIF91cGRhdGUoYWN0aXZlLCBmb3JWaXNpYmlsaXR5KSB7XG4gICAgdmFyIHR5cGUgPSBmb3JWaXNpYmlsaXR5ID8gJ3Zpc2libGUnIDogJ2FjdGl2ZSc7XG4gICAgdmFyIGNsYXNzTmFtZSA9IFNUQVRVU19DTEFTU0VTW3R5cGVdO1xuXG4gICAgaWYgKGFjdGl2ZSkge1xuICAgICAgYWRkQ2xhc3Moc2xpZGUsIGNsYXNzTmFtZSk7XG4gICAgICBTcGxpZGUuZW1pdChcIlwiICsgdHlwZSwgU2xpZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzQ2xhc3Moc2xpZGUsIGNsYXNzTmFtZSkpIHtcbiAgICAgICAgcmVtb3ZlQ2xhc3Moc2xpZGUsIGNsYXNzTmFtZSk7XG4gICAgICAgIFNwbGlkZS5lbWl0KFwiXCIgKyAoZm9yVmlzaWJpbGl0eSA/ICdoaWRkZW4nIDogJ2luYWN0aXZlJyksIFNsaWRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogUmVzdG9yZSB0aGUgb3JpZ2luYWwgc3R5bGVzLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gcmVzdG9yZVN0eWxlcygpIHtcbiAgICBzZXRBdHRyaWJ1dGUoc2xpZGUsICdzdHlsZScsIFNsaWRlLnN0eWxlcyk7XG4gIH1cblxuICByZXR1cm4gU2xpZGU7XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb21wb25lbnRzL2VsZW1lbnRzL2luZGV4LmpzXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgbWFpbiBlbGVtZW50cy5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG5cblxuXG5cbi8qKlxyXG4gKiBUaGUgcHJvcGVydHkgbmFtZSBmb3IgVUlEIHN0b3JlZCBpbiBhIHdpbmRvdyBvYmplY3QuXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xuXG52YXIgVUlEX05BTUUgPSAndWlkJztcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBtYWluIGVsZW1lbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NwbGlkZX0gU3BsaWRlICAgICAtIEEgU3BsaWRlIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gQ29tcG9uZW50cyAtIEFuIG9iamVjdCBjb250YWluaW5nIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBUaGUgY29tcG9uZW50IG9iamVjdC5cclxuICovXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29tcG9uZW50c19lbGVtZW50cyA9IChmdW5jdGlvbiAoU3BsaWRlLCBDb21wb25lbnRzKSB7XG4gIC8qKlxyXG4gICAqIEhvbGQgdGhlIHJvb3QgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtFbGVtZW50fVxyXG4gICAqL1xuICB2YXIgcm9vdCA9IFNwbGlkZS5yb290O1xuICAvKipcclxuICAgKiBIb2xkIHRoZSBjbGFzcyBsaXN0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuICB2YXIgY2xhc3NlcyA9IFNwbGlkZS5jbGFzc2VzO1xuICAvKipcclxuICAgKiBTdG9yZSBTbGlkZSBvYmplY3RzLlxyXG4gICAqXHJcbiAgICogQHR5cGUge0FycmF5fVxyXG4gICAqL1xuXG4gIHZhciBTbGlkZXMgPSBbXTtcbiAgLypcclxuICAgKiBBc3NpZ24gdW5pcXVlIElEIHRvIHRoZSByb290IGVsZW1lbnQgaWYgaXQgZG9lc24ndCBoYXZlIHRoZSBvbmUuXHJcbiAgICogTm90ZSB0aGF0IElFIGRvZXNuJ3Qgc3VwcG9ydCBwYWRTdGFydCgpIHRvIGZpbGwgdGhlIHVpZCBieSAwLlxyXG4gICAqL1xuXG4gIGlmICghcm9vdC5pZCkge1xuICAgIHdpbmRvdy5zcGxpZGUgPSB3aW5kb3cuc3BsaWRlIHx8IHt9O1xuICAgIHZhciB1aWQgPSB3aW5kb3cuc3BsaWRlW1VJRF9OQU1FXSB8fCAwO1xuICAgIHdpbmRvdy5zcGxpZGVbVUlEX05BTUVdID0gKyt1aWQ7XG4gICAgcm9vdC5pZCA9IFwic3BsaWRlXCIgKyBwYWQodWlkKTtcbiAgfVxuICAvKipcclxuICAgKiBFbGVtZW50cyBjb21wb25lbnQgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuXG4gIHZhciBFbGVtZW50cyA9IHtcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cclxuICAgICAqIENvbGxlY3QgbWFpbiBlbGVtZW50cyBhbmQgc3RvcmUgdGhlbSBhcyBtZW1iZXIgcHJvcGVydGllcy5cclxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgU3BsaWRlLm9uKCdyZWZyZXNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5kZXN0cm95KCk7XG5cbiAgICAgICAgX3RoaXMuaW5pdCgpO1xuICAgICAgfSkub24oJ3VwZGF0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKHJvb3QsIGdldENsYXNzZXMoKSk7XG4gICAgICAgIGFkZENsYXNzKHJvb3QsIGdldENsYXNzZXMoKSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95LlxyXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIFNsaWRlcy5mb3JFYWNoKGZ1bmN0aW9uIChTbGlkZSkge1xuICAgICAgICBTbGlkZS5kZXN0cm95KCk7XG4gICAgICB9KTtcbiAgICAgIFNsaWRlcyA9IFtdO1xuICAgICAgcmVtb3ZlQ2xhc3Mocm9vdCwgZ2V0Q2xhc3NlcygpKTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXphdGlvbi5cclxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgY29sbGVjdCgpO1xuICAgICAgYWRkQ2xhc3Mocm9vdCwgZ2V0Q2xhc3NlcygpKTtcbiAgICAgIHRoaXMuc2xpZGVzLmZvckVhY2goZnVuY3Rpb24gKHNsaWRlLCBpbmRleCkge1xuICAgICAgICBfdGhpczIucmVnaXN0ZXIoc2xpZGUsIGluZGV4LCAtMSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlciBhIHNsaWRlIHRvIGNyZWF0ZSBhIFNsaWRlIG9iamVjdCBhbmQgaGFuZGxlIGl0cyBiZWhhdmlvci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHNsaWRlICAgICAtIEEgc2xpZGUgZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSAgaW5kZXggICAgIC0gQSB1bmlxdWUgaW5kZXguIFRoaXMgY2FuIGJlIG5lZ2F0aXZlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9ICByZWFsSW5kZXggLSBBIHJlYWwgaW5kZXggZm9yIGNsb25lcy4gU2V0IC0xIGZvciByZWFsIHNsaWRlcy5cclxuICAgICAqL1xuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3RlcihzbGlkZSwgaW5kZXgsIHJlYWxJbmRleCkge1xuICAgICAgdmFyIFNsaWRlT2JqZWN0ID0gZWxlbWVudHNfc2xpZGUoU3BsaWRlLCBpbmRleCwgcmVhbEluZGV4LCBzbGlkZSk7XG4gICAgICBTbGlkZU9iamVjdC5tb3VudCgpO1xuICAgICAgU2xpZGVzLnB1c2goU2xpZGVPYmplY3QpO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgU2xpZGUgb2JqZWN0IGRlc2lnbmF0ZWQgYnkgdGhlIGluZGV4LlxyXG4gICAgICogTm90ZSB0aGF0IFwiZmluZFwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH0gLSBBIFNsaWRlIG9iamVjdCBpZiBhdmFpbGFibGUuIFVuZGVmaW5lZCBpZiBub3QuXHJcbiAgICAgKi9cbiAgICBnZXRTbGlkZTogZnVuY3Rpb24gZ2V0U2xpZGUoaW5kZXgpIHtcbiAgICAgIHJldHVybiBTbGlkZXMuZmlsdGVyKGZ1bmN0aW9uIChTbGlkZSkge1xuICAgICAgICByZXR1cm4gU2xpZGUuaW5kZXggPT09IGluZGV4O1xuICAgICAgfSlbMF07XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGFsbCBTbGlkZSBvYmplY3RzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZUNsb25lcyAtIFdoZXRoZXIgdG8gaW5jbHVkZSBjbG9uZWQgc2xpZGVzIG9yIG5vdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3RbXX0gLSBTbGlkZSBvYmplY3RzLlxyXG4gICAgICovXG4gICAgZ2V0U2xpZGVzOiBmdW5jdGlvbiBnZXRTbGlkZXMoaW5jbHVkZUNsb25lcykge1xuICAgICAgcmV0dXJuIGluY2x1ZGVDbG9uZXMgPyBTbGlkZXMgOiBTbGlkZXMuZmlsdGVyKGZ1bmN0aW9uIChTbGlkZSkge1xuICAgICAgICByZXR1cm4gIVNsaWRlLmlzQ2xvbmU7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gU2xpZGUgb2JqZWN0cyBiZWxvbmdpbmcgdG8gdGhlIGdpdmVuIHBhZ2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhZ2UgLSBBIHBhZ2UgbnVtYmVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge09iamVjdFtdfSAtIEFuIGFycmF5IGNvbnRhaW5pbmcgU2xpZGUgb2JqZWN0cy5cclxuICAgICAqL1xuICAgIGdldFNsaWRlc0J5UGFnZTogZnVuY3Rpb24gZ2V0U2xpZGVzQnlQYWdlKHBhZ2UpIHtcbiAgICAgIHZhciBpZHggPSBDb21wb25lbnRzLkNvbnRyb2xsZXIudG9JbmRleChwYWdlKTtcbiAgICAgIHZhciBvcHRpb25zID0gU3BsaWRlLm9wdGlvbnM7XG4gICAgICB2YXIgbWF4ID0gb3B0aW9ucy5mb2N1cyAhPT0gZmFsc2UgPyAxIDogb3B0aW9ucy5wZXJQYWdlO1xuICAgICAgcmV0dXJuIFNsaWRlcy5maWx0ZXIoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gX3JlZi5pbmRleDtcbiAgICAgICAgcmV0dXJuIGlkeCA8PSBpbmRleCAmJiBpbmRleCA8IGlkeCArIG1heDtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIEluc2VydCBhIHNsaWRlIHRvIGEgc2xpZGVyLlxyXG4gICAgICogTmVlZCB0byByZWZyZXNoIFNwbGlkZSBhZnRlciBhZGRpbmcgYSBzbGlkZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge05vZGV8c3RyaW5nfSBzbGlkZSAgICAtIEEgc2xpZGUgZWxlbWVudCB0byBiZSBhZGRlZC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSAgICAgIGluZGV4ICAgIC0gQSBzbGlkZSB3aWxsIGJlIGFkZGVkIGF0IHRoZSBwb3NpdGlvbi5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259ICAgIGNhbGxiYWNrIC0gQ2FsbGVkIHJpZ2h0IGFmdGVyIHRoZSBzbGlkZSBpcyBhZGRlZCB0byB0aGUgRE9NIHRyZWUuXHJcbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uIGFkZChzbGlkZSwgaW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAodHlwZW9mIHNsaWRlID09PSAnc3RyaW5nJykge1xuICAgICAgICBzbGlkZSA9IGRvbWlmeShzbGlkZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzbGlkZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHJlZiA9IHRoaXMuc2xpZGVzW2luZGV4XTsgLy8gVGhpcyB3aWxsIGJlIHJlbW92ZWQgaW4gbW91bnQoKSBvZiBhIFNsaWRlIGNvbXBvbmVudC5cblxuICAgICAgICBhcHBseVN0eWxlKHNsaWRlLCB7XG4gICAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICBiZWZvcmUoc2xpZGUsIHJlZik7XG4gICAgICAgICAgdGhpcy5zbGlkZXMuc3BsaWNlKGluZGV4LCAwLCBzbGlkZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXBwZW5kKHRoaXMubGlzdCwgc2xpZGUpO1xuICAgICAgICAgIHRoaXMuc2xpZGVzLnB1c2goc2xpZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9hZGVkKHNsaWRlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soc2xpZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYSBzbGlkZSBmcm9tIGEgc2xpZGVyLlxyXG4gICAgICogTmVlZCB0byByZWZyZXNoIFNwbGlkZSBhZnRlciByZW1vdmluZyBhIHNsaWRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbmRleCAtIFNsaWRlIGluZGV4LlxyXG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoaW5kZXgpIHtcbiAgICAgIGRvbV9yZW1vdmUodGhpcy5zbGlkZXMuc3BsaWNlKGluZGV4LCAxKVswXSk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogVHJpZ2dlciB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZm9yIGVhY2ggU2xpZGUgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQSBjYWxsYmFjayBmdW5jdGlvbi4gVGhlIGZpcnN0IGFyZ3VtZW50IHdpbGwgYmUgdGhlIFNsaWRlIG9iamVjdC5cclxuICAgICAqL1xuICAgIGVhY2g6IGZ1bmN0aW9uIGVhY2goY2FsbGJhY2spIHtcbiAgICAgIFNsaWRlcy5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gc2xpZGVzIGxlbmd0aCB3aXRob3V0IGNsb25lcy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gU2xpZGUgbGVuZ3RoLlxyXG4gICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNsaWRlcy5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFwiU2xpZGVPYmplY3RzXCIgbGVuZ3RoIGluY2x1ZGluZyBjbG9uZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIFNsaWRlIGxlbmd0aCBpbmNsdWRpbmcgY2xvbmVzLlxyXG4gICAgICovXG4gICAgZ2V0IHRvdGFsKCkge1xuICAgICAgcmV0dXJuIFNsaWRlcy5sZW5ndGg7XG4gICAgfVxuXG4gIH07XG4gIC8qKlxyXG4gICAqIENvbGxlY3QgZWxlbWVudHMuXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gY29sbGVjdCgpIHtcbiAgICBFbGVtZW50cy5zbGlkZXIgPSBjaGlsZChyb290LCBjbGFzc2VzLnNsaWRlcik7XG4gICAgRWxlbWVudHMudHJhY2sgPSBmaW5kKHJvb3QsIFwiLlwiICsgY2xhc3Nlcy50cmFjayk7XG4gICAgRWxlbWVudHMubGlzdCA9IGNoaWxkKEVsZW1lbnRzLnRyYWNrLCBjbGFzc2VzLmxpc3QpO1xuICAgIGV4aXN0KEVsZW1lbnRzLnRyYWNrICYmIEVsZW1lbnRzLmxpc3QsICdUcmFjayBvciBsaXN0IHdhcyBub3QgZm91bmQuJyk7XG4gICAgRWxlbWVudHMuc2xpZGVzID0gY2hpbGRyZW4oRWxlbWVudHMubGlzdCwgY2xhc3Nlcy5zbGlkZSk7XG4gICAgdmFyIGFycm93cyA9IGZpbmRQYXJ0cyhjbGFzc2VzLmFycm93cyk7XG4gICAgRWxlbWVudHMuYXJyb3dzID0ge1xuICAgICAgcHJldjogZmluZChhcnJvd3MsIFwiLlwiICsgY2xhc3Nlcy5wcmV2KSxcbiAgICAgIG5leHQ6IGZpbmQoYXJyb3dzLCBcIi5cIiArIGNsYXNzZXMubmV4dClcbiAgICB9O1xuICAgIHZhciBhdXRvcGxheSA9IGZpbmRQYXJ0cyhjbGFzc2VzLmF1dG9wbGF5KTtcbiAgICBFbGVtZW50cy5iYXIgPSBmaW5kKGZpbmRQYXJ0cyhjbGFzc2VzLnByb2dyZXNzKSwgXCIuXCIgKyBjbGFzc2VzLmJhcik7XG4gICAgRWxlbWVudHMucGxheSA9IGZpbmQoYXV0b3BsYXksIFwiLlwiICsgY2xhc3Nlcy5wbGF5KTtcbiAgICBFbGVtZW50cy5wYXVzZSA9IGZpbmQoYXV0b3BsYXksIFwiLlwiICsgY2xhc3Nlcy5wYXVzZSk7XG4gICAgRWxlbWVudHMudHJhY2suaWQgPSBFbGVtZW50cy50cmFjay5pZCB8fCByb290LmlkICsgXCItdHJhY2tcIjtcbiAgICBFbGVtZW50cy5saXN0LmlkID0gRWxlbWVudHMubGlzdC5pZCB8fCByb290LmlkICsgXCItbGlzdFwiO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybiBjbGFzcyBuYW1lcyBmb3IgdGhlIHJvb3QgZWxlbWVudC5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldENsYXNzZXMoKSB7XG4gICAgdmFyIHJvb3RDbGFzcyA9IGNsYXNzZXMucm9vdDtcbiAgICB2YXIgb3B0aW9ucyA9IFNwbGlkZS5vcHRpb25zO1xuICAgIHJldHVybiBbcm9vdENsYXNzICsgXCItLVwiICsgb3B0aW9ucy50eXBlLCByb290Q2xhc3MgKyBcIi0tXCIgKyBvcHRpb25zLmRpcmVjdGlvbiwgb3B0aW9ucy5kcmFnID8gcm9vdENsYXNzICsgXCItLWRyYWdnYWJsZVwiIDogJycsIG9wdGlvbnMuaXNOYXZpZ2F0aW9uID8gcm9vdENsYXNzICsgXCItLW5hdlwiIDogJycsIFNUQVRVU19DTEFTU0VTLmFjdGl2ZV07XG4gIH1cbiAgLyoqXHJcbiAgICogRmluZCBwYXJ0cyBvbmx5IGZyb20gY2hpbGRyZW4gb2YgdGhlIHJvb3Qgb3IgdHJhY2suXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSAtIEEgZm91bmQgZWxlbWVudCBvciB1bmRlZmluZWQuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBmaW5kUGFydHMoY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIGNoaWxkKHJvb3QsIGNsYXNzTmFtZSkgfHwgY2hpbGQoRWxlbWVudHMuc2xpZGVyLCBjbGFzc05hbWUpO1xuICB9XG5cbiAgcmV0dXJuIEVsZW1lbnRzO1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29tcG9uZW50cy9jb250cm9sbGVyL2luZGV4LmpzXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgY29udHJvbGxpbmcgdGhlIHRyYWNrLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cblxuXG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGNvbnRyb2xsaW5nIHRoZSB0cmFjay5cclxuICpcclxuICogQHBhcmFtIHtTcGxpZGV9IFNwbGlkZSAgICAgLSBBIFNwbGlkZSBpbnN0YW5jZS5cclxuICogQHBhcmFtIHtPYmplY3R9IENvbXBvbmVudHMgLSBBbiBvYmplY3QgY29udGFpbmluZyBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gVGhlIGNvbXBvbmVudCBvYmplY3QuXHJcbiAqL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNvbnRyb2xsZXIgPSAoZnVuY3Rpb24gKFNwbGlkZSwgQ29tcG9uZW50cykge1xuICAvKipcclxuICAgKiBTdG9yZSBjdXJyZW50IG9wdGlvbnMuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuICB2YXIgb3B0aW9ucztcbiAgLyoqXHJcbiAgICogVHJ1ZSBpZiB0aGUgc2xpZGUgaXMgTE9PUCBtb2RlLlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG5cbiAgdmFyIGlzTG9vcDtcbiAgLyoqXHJcbiAgICogQ29udHJvbGxlciBjb21wb25lbnQgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuICB2YXIgQ29udHJvbGxlciA9IHtcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cclxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIG9wdGlvbnMgPSBTcGxpZGUub3B0aW9ucztcbiAgICAgIGlzTG9vcCA9IFNwbGlkZS5pcyhMT09QKTtcbiAgICAgIGJpbmQoKTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlIHRyYWNrIHJ1biBieSB0aGUgZ2l2ZW4gY29udHJvbC5cclxuICAgICAqIC0gXCIre2l9XCIgOiBJbmNyZW1lbnQgdGhlIHNsaWRlIGluZGV4IGJ5IGkuXHJcbiAgICAgKiAtIFwiLXtpfVwiIDogRGVjcmVtZW50IHRoZSBzbGlkZSBpbmRleCBieSBpLlxyXG4gICAgICogLSBcIntpfVwiICA6IEdvIHRvIHRoZSBzbGlkZSB3aG9zZSBpbmRleCBpcyBpLlxyXG4gICAgICogLSBcIj5cIiAgICA6IEdvIHRvIG5leHQgcGFnZS5cclxuICAgICAqIC0gXCI8XCIgICAgOiBHbyB0byBwcmV2IHBhZ2UuXHJcbiAgICAgKiAtIFwiPntpfVwiIDogR28gdG8gcGFnZSBpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gY29udHJvbCAgLSBBIGNvbnRyb2wgcGF0dGVybi5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgc2lsZW50bHkgLSBHbyB0byB0aGUgZGVzdGluYXRpb24gd2l0aG91dCBldmVudCBlbWlzc2lvbi5cclxuICAgICAqL1xuICAgIGdvOiBmdW5jdGlvbiBnbyhjb250cm9sLCBzaWxlbnRseSkge1xuICAgICAgdmFyIGRlc3RJbmRleCA9IHRoaXMudHJpbSh0aGlzLnBhcnNlKGNvbnRyb2wpKTtcbiAgICAgIENvbXBvbmVudHMuVHJhY2suZ28oZGVzdEluZGV4LCB0aGlzLnJld2luZChkZXN0SW5kZXgpLCBzaWxlbnRseSk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUGFyc2UgdGhlIGdpdmVuIGNvbnRyb2wgYW5kIHJldHVybiB0aGUgZGVzdGluYXRpb24gaW5kZXggZm9yIHRoZSB0cmFjay5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJvbCAtIEEgY29udHJvbCB0YXJnZXQgcGF0dGVybi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gQSBwYXJzZWQgdGFyZ2V0LlxyXG4gICAgICovXG4gICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGNvbnRyb2wpIHtcbiAgICAgIHZhciBpbmRleCA9IFNwbGlkZS5pbmRleDtcbiAgICAgIHZhciBtYXRjaGVzID0gU3RyaW5nKGNvbnRyb2wpLm1hdGNoKC8oWytcXC08Pl0rKShcXGQrKT8vKTtcbiAgICAgIHZhciBpbmRpY2F0b3IgPSBtYXRjaGVzID8gbWF0Y2hlc1sxXSA6ICcnO1xuICAgICAgdmFyIG51bWJlciA9IG1hdGNoZXMgPyBwYXJzZUludChtYXRjaGVzWzJdKSA6IDA7XG5cbiAgICAgIHN3aXRjaCAoaW5kaWNhdG9yKSB7XG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgIGluZGV4ICs9IG51bWJlciB8fCAxO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgIGluZGV4IC09IG51bWJlciB8fCAxO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICBpbmRleCA9IHBhcnNlUGFnZShudW1iZXIsIGluZGV4LCBpbmRpY2F0b3IgPT09ICc8Jyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpbmRleCA9IHBhcnNlSW50KGNvbnRyb2wpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZSBpbmRleCBmcm9tIHRoZSBnaXZlbiBwYWdlIG51bWJlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFnZSAtIFBhZ2UgbnVtYmVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBBIGNvbXB1dGVkIHBhZ2UgbnVtYmVyLlxyXG4gICAgICovXG4gICAgdG9JbmRleDogZnVuY3Rpb24gdG9JbmRleChwYWdlKSB7XG4gICAgICBpZiAoaGFzRm9jdXMoKSkge1xuICAgICAgICByZXR1cm4gcGFnZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbmd0aCA9IFNwbGlkZS5sZW5ndGg7XG4gICAgICB2YXIgcGVyUGFnZSA9IG9wdGlvbnMucGVyUGFnZTtcbiAgICAgIHZhciBpbmRleCA9IHBhZ2UgKiBwZXJQYWdlO1xuICAgICAgaW5kZXggPSBpbmRleCAtICh0aGlzLnBhZ2VMZW5ndGggKiBwZXJQYWdlIC0gbGVuZ3RoKSAqIGZsb29yKGluZGV4IC8gbGVuZ3RoKTsgLy8gQWRqdXN0bWVudCBmb3IgdGhlIGxhc3QgcGFnZS5cblxuICAgICAgaWYgKGxlbmd0aCAtIHBlclBhZ2UgPD0gaW5kZXggJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaW5kZXggPSBsZW5ndGggLSBwZXJQYWdlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZSBwYWdlIG51bWJlciBmcm9tIHRoZSBnaXZlbiBzbGlkZSBpbmRleC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBTbGlkZSBpbmRleC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gQSBjb21wdXRlZCBwYWdlIG51bWJlci5cclxuICAgICAqL1xuICAgIHRvUGFnZTogZnVuY3Rpb24gdG9QYWdlKGluZGV4KSB7XG4gICAgICBpZiAoaGFzRm9jdXMoKSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW5ndGggPSBTcGxpZGUubGVuZ3RoO1xuICAgICAgdmFyIHBlclBhZ2UgPSBvcHRpb25zLnBlclBhZ2U7IC8vIE1ha2UgdGhlIGxhc3QgXCJwZXJQYWdlXCIgbnVtYmVyIG9mIHNsaWRlcyBiZWxvbmcgdG8gdGhlIGxhc3QgcGFnZS5cblxuICAgICAgaWYgKGxlbmd0aCAtIHBlclBhZ2UgPD0gaW5kZXggJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZsb29yKChsZW5ndGggLSAxKSAvIHBlclBhZ2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmxvb3IoaW5kZXggLyBwZXJQYWdlKTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBUcmltIHRoZSBnaXZlbiBpbmRleCBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgbW9kZS5cclxuICAgICAqIEluZGV4IGJlaW5nIHJldHVybmVkIGNvdWxkIGJlIGxlc3MgdGhhbiAwIG9yIGdyZWF0ZXIgdGhhbiB0aGUgbGVuZ3RoIGluIExvb3AgbW9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBBbiBpbmRleCBiZWluZyB0cmltbWVkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBBIHRyaW1tZWQgaW5kZXguXHJcbiAgICAgKi9cbiAgICB0cmltOiBmdW5jdGlvbiB0cmltKGluZGV4KSB7XG4gICAgICBpZiAoIWlzTG9vcCkge1xuICAgICAgICBpbmRleCA9IG9wdGlvbnMucmV3aW5kID8gdGhpcy5yZXdpbmQoaW5kZXgpIDogYmV0d2VlbihpbmRleCwgMCwgdGhpcy5lZGdlSW5kZXgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmV3aW5kIHRoZSBnaXZlbiBpbmRleCBpZiBpdCdzIG91dCBvZiByYW5nZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBBbiBpbmRleC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gQSByZXdvdW5kIGluZGV4LlxyXG4gICAgICovXG4gICAgcmV3aW5kOiBmdW5jdGlvbiByZXdpbmQoaW5kZXgpIHtcbiAgICAgIHZhciBlZGdlID0gdGhpcy5lZGdlSW5kZXg7XG5cbiAgICAgIGlmIChpc0xvb3ApIHtcbiAgICAgICAgd2hpbGUgKGluZGV4ID4gZWRnZSkge1xuICAgICAgICAgIGluZGV4IC09IGVkZ2UgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgMCkge1xuICAgICAgICAgIGluZGV4ICs9IGVkZ2UgKyAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW5kZXggPiBlZGdlKSB7XG4gICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgIGluZGV4ID0gZWRnZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgdGhlIGRpcmVjdGlvbiBpcyBcInJ0bFwiIG9yIG5vdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRydWUgaWYgXCJydGxcIiBvciBmYWxzZSBpZiBub3QuXHJcbiAgICAgKi9cbiAgICBpc1J0bDogZnVuY3Rpb24gaXNSdGwoKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5kaXJlY3Rpb24gPT09IFJUTDtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIHBhZ2UgbGVuZ3RoLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBNYXggcGFnZSBudW1iZXIuXHJcbiAgICAgKi9cbiAgICBnZXQgcGFnZUxlbmd0aCgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBTcGxpZGUubGVuZ3RoO1xuICAgICAgcmV0dXJuIGhhc0ZvY3VzKCkgPyBsZW5ndGggOiBNYXRoLmNlaWwobGVuZ3RoIC8gb3B0aW9ucy5wZXJQYWdlKTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGVkZ2UgaW5kZXguXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIEVkZ2UgaW5kZXguXHJcbiAgICAgKi9cbiAgICBnZXQgZWRnZUluZGV4KCkge1xuICAgICAgdmFyIGxlbmd0aCA9IFNwbGlkZS5sZW5ndGg7XG5cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzRm9jdXMoKSB8fCBvcHRpb25zLmlzTmF2aWdhdGlvbiB8fCBpc0xvb3ApIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCAtIDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsZW5ndGggLSBvcHRpb25zLnBlclBhZ2U7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBpbmRleCBvZiB0aGUgcHJldmlvdXMgc2xpZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSBpbmRleCBvZiB0aGUgcHJldmlvdXMgc2xpZGUgaWYgYXZhaWxhYmxlLiAtMSBvdGhlcndpc2UuXHJcbiAgICAgKi9cbiAgICBnZXQgcHJldkluZGV4KCkge1xuICAgICAgdmFyIHByZXYgPSBTcGxpZGUuaW5kZXggLSAxO1xuXG4gICAgICBpZiAoaXNMb29wIHx8IG9wdGlvbnMucmV3aW5kKSB7XG4gICAgICAgIHByZXYgPSB0aGlzLnJld2luZChwcmV2KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXYgPiAtMSA/IHByZXYgOiAtMTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBuZXh0IHNsaWRlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgaW5kZXggb2YgdGhlIG5leHQgc2xpZGUgaWYgYXZhaWxhYmxlLiAtMSBvdGhlcndpc2UuXHJcbiAgICAgKi9cbiAgICBnZXQgbmV4dEluZGV4KCkge1xuICAgICAgdmFyIG5leHQgPSBTcGxpZGUuaW5kZXggKyAxO1xuXG4gICAgICBpZiAoaXNMb29wIHx8IG9wdGlvbnMucmV3aW5kKSB7XG4gICAgICAgIG5leHQgPSB0aGlzLnJld2luZChuZXh0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFNwbGlkZS5pbmRleCA8IG5leHQgJiYgbmV4dCA8PSB0aGlzLmVkZ2VJbmRleCB8fCBuZXh0ID09PSAwID8gbmV4dCA6IC0xO1xuICAgIH1cblxuICB9O1xuICAvKipcclxuICAgKiBMaXN0ZW4gdG8gc29tZSBldmVudHMuXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gYmluZCgpIHtcbiAgICBTcGxpZGUub24oJ21vdmUnLCBmdW5jdGlvbiAobmV3SW5kZXgpIHtcbiAgICAgIFNwbGlkZS5pbmRleCA9IG5ld0luZGV4O1xuICAgIH0pLm9uKCd1cGRhdGVkIHJlZnJlc2gnLCBmdW5jdGlvbiAobmV3T3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG5ld09wdGlvbnMgfHwgb3B0aW9ucztcbiAgICAgIFNwbGlkZS5pbmRleCA9IGJldHdlZW4oU3BsaWRlLmluZGV4LCAwLCBDb250cm9sbGVyLmVkZ2VJbmRleCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogVmVyaWZ5IGlmIHRoZSBmb2N1cyBvcHRpb24gaXMgYXZhaWxhYmxlIG9yIG5vdC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiBhIHNsaWRlciBoYXMgdGhlIGZvY3VzIG9wdGlvbi5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGhhc0ZvY3VzKCkge1xuICAgIHJldHVybiBvcHRpb25zLmZvY3VzICE9PSBmYWxzZTtcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIG5leHQgb3IgcHJldmlvdXMgcGFnZSBpbmRleCBjb21wdXRlZCBieSB0aGUgcGFnZSBudW1iZXIgYW5kIGN1cnJlbnQgaW5kZXguXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gIG51bWJlciAtIFNwZWNpZnkgdGhlIHBhZ2UgbnVtYmVyLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgaW5kZXggIC0gQ3VycmVudCBpbmRleC5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByZXYgICAtIFByZXYgb3IgbmV4dC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBTbGlkZSBpbmRleC5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHBhcnNlUGFnZShudW1iZXIsIGluZGV4LCBwcmV2KSB7XG4gICAgaWYgKG51bWJlciA+IC0xKSB7XG4gICAgICByZXR1cm4gQ29udHJvbGxlci50b0luZGV4KG51bWJlcik7XG4gICAgfVxuXG4gICAgdmFyIHBlck1vdmUgPSBvcHRpb25zLnBlck1vdmU7XG4gICAgdmFyIHNpZ24gPSBwcmV2ID8gLTEgOiAxO1xuXG4gICAgaWYgKHBlck1vdmUpIHtcbiAgICAgIHJldHVybiBpbmRleCArIHBlck1vdmUgKiBzaWduO1xuICAgIH1cblxuICAgIHJldHVybiBDb250cm9sbGVyLnRvSW5kZXgoQ29udHJvbGxlci50b1BhZ2UoaW5kZXgpICsgc2lnbik7XG4gIH1cblxuICByZXR1cm4gQ29udHJvbGxlcjtcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbXBvbmVudHMvdHJhY2svaW5kZXguanNcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBtb3ZpbmcgbGlzdCBpbiB0aGUgdHJhY2suXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuXG5cblxuXG52YXIgYWJzID0gTWF0aC5hYnM7XG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgbW92aW5nIGxpc3QgaW4gdGhlIHRyYWNrLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NwbGlkZX0gU3BsaWRlICAgICAtIEEgU3BsaWRlIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gQ29tcG9uZW50cyAtIEFuIG9iamVjdCBjb250YWluaW5nIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBUaGUgY29tcG9uZW50IG9iamVjdC5cclxuICovXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgdHJhY2sgPSAoZnVuY3Rpb24gKFNwbGlkZSwgQ29tcG9uZW50cykge1xuICAvKipcclxuICAgKiBIb2xkIHRoZSBMYXlvdXQgY29tcG9uZW50LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cbiAgdmFyIExheW91dDtcbiAgLyoqXHJcbiAgICogSG9sZCB0aGUgTGF5b3V0IGNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cbiAgdmFyIEVsZW1lbnRzO1xuICAvKipcclxuICAgKiBTdG9yZSB0aGUgbGlzdCBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHR5cGUge0VsZW1lbnR9XHJcbiAgICovXG5cbiAgdmFyIGxpc3Q7XG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdGhlIGN1cnJlbnQgZGlyZWN0aW9uIGlzIHZlcnRpY2FsIG9yIG5vdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuXG4gIHZhciBpc1ZlcnRpY2FsID0gU3BsaWRlLm9wdGlvbnMuZGlyZWN0aW9uID09PSBUVEI7XG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdGhlIHNsaWRlciB0eXBlIGlzIEZBREUgb3Igbm90LlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG5cbiAgdmFyIGlzRmFkZSA9IFNwbGlkZS5pcyhGQURFKTtcbiAgLyoqXHJcbiAgICogV2hldGhlciB0aGUgc2xpZGVyIGRpcmVjdGlvbiBpcyBSVEwgb3Igbm90LlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG5cbiAgdmFyIGlzUlRMID0gU3BsaWRlLm9wdGlvbnMuZGlyZWN0aW9uID09PSBSVEw7XG4gIC8qKlxyXG4gICAqIFRoaXMgd2lsbCBiZSB0cnVlIHdoaWxlIHRyYW5zaXRpb25pbmcgZnJvbSB0aGUgbGFzdCBpbmRleCB0byB0aGUgZmlyc3Qgb25lLlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG5cbiAgdmFyIGlzTG9vcFBlbmRpbmcgPSBmYWxzZTtcbiAgLyoqXHJcbiAgICogU2lnbiBmb3IgdGhlIGRpcmVjdGlvbi4gT25seSBSVEwgbW9kZSB1c2VzIHRoZSBwb3NpdGl2ZSBzaWduLlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cblxuICB2YXIgc2lnbiA9IGlzUlRMID8gMSA6IC0xO1xuICAvKipcclxuICAgKiBUcmFjayBjb21wb25lbnQgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuICB2YXIgVHJhY2sgPSB7XG4gICAgLyoqXHJcbiAgICAgKiBNYWtlIHB1YmxpYyB0aGUgc2lnbiBkZWZpbmVkIGxvY2FsbHkuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xuICAgIHNpZ246IHNpZ24sXG5cbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cclxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIEVsZW1lbnRzID0gQ29tcG9uZW50cy5FbGVtZW50cztcbiAgICAgIExheW91dCA9IENvbXBvbmVudHMuTGF5b3V0O1xuICAgICAgbGlzdCA9IEVsZW1lbnRzLmxpc3Q7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGFmdGVyIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cclxuICAgICAqIFRoZSByZXNpemUgZXZlbnQgbXVzdCBiZSByZWdpc3RlcmVkIGFmdGVyIHRoZSBMYXlvdXQncyBvbmUgaXMgZG9uZS5cclxuICAgICAqL1xuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoIWlzRmFkZSkge1xuICAgICAgICB0aGlzLmp1bXAoMCk7XG4gICAgICAgIFNwbGlkZS5vbignbW91bnRlZCByZXNpemUgdXBkYXRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5qdW1wKFNwbGlkZS5pbmRleCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIEdvIHRvIHRoZSBnaXZlbiBkZXN0aW5hdGlvbiBpbmRleC5cclxuICAgICAqIEFmdGVyIGFycml2aW5nIHRoZXJlLCB0aGUgdHJhY2sgaXMganVtcCB0byB0aGUgbmV3IGluZGV4IHdpdGhvdXQgYW5pbWF0aW9uLCBtYWlubHkgZm9yIGxvb3AgbW9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gIGRlc3RJbmRleCAtIEEgZGVzdGluYXRpb24gaW5kZXguXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgY2FuIGJlIG5lZ2F0aXZlIG9yIGdyZWF0ZXIgdGhhbiBzbGlkZXMgbGVuZ3RoIGZvciByZWFjaGluZyBjbG9uZXMuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gIG5ld0luZGV4ICAtIEFuIGFjdHVhbCBuZXcgaW5kZXguIFRoZXkgYXJlIGFsd2F5cyBzYW1lIGluIFNsaWRlIGFuZCBSZXdpbmQgbW9kZS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lsZW50bHkgIC0gSWYgdHJ1ZSwgc3VwcHJlc3MgZW1pdHRpbmcgZXZlbnRzLlxyXG4gICAgICovXG4gICAgZ286IGZ1bmN0aW9uIGdvKGRlc3RJbmRleCwgbmV3SW5kZXgsIHNpbGVudGx5KSB7XG4gICAgICB2YXIgbmV3UG9zaXRpb24gPSBnZXRUcmltbWVkUG9zaXRpb24oZGVzdEluZGV4KTtcbiAgICAgIHZhciBwcmV2SW5kZXggPSBTcGxpZGUuaW5kZXg7IC8vIFByZXZlbnQgYW55IGFjdGlvbnMgd2hpbGUgdHJhbnNpdGlvbmluZyBmcm9tIHRoZSBsYXN0IGluZGV4IHRvIHRoZSBmaXJzdCBvbmUgZm9yIGp1bXAuXG5cbiAgICAgIGlmIChTcGxpZGUuU3RhdGUuaXMoTU9WSU5HKSAmJiBpc0xvb3BQZW5kaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaXNMb29wUGVuZGluZyA9IGRlc3RJbmRleCAhPT0gbmV3SW5kZXg7XG5cbiAgICAgIGlmICghc2lsZW50bHkpIHtcbiAgICAgICAgU3BsaWRlLmVtaXQoJ21vdmUnLCBuZXdJbmRleCwgcHJldkluZGV4LCBkZXN0SW5kZXgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoTWF0aC5hYnMobmV3UG9zaXRpb24gLSB0aGlzLnBvc2l0aW9uKSA+PSAxIHx8IGlzRmFkZSkge1xuICAgICAgICBDb21wb25lbnRzLlRyYW5zaXRpb24uc3RhcnQoZGVzdEluZGV4LCBuZXdJbmRleCwgcHJldkluZGV4LCB0aGlzLnRvQ29vcmQobmV3UG9zaXRpb24pLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgb25UcmFuc2l0aW9uRW5kKGRlc3RJbmRleCwgbmV3SW5kZXgsIHByZXZJbmRleCwgc2lsZW50bHkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChkZXN0SW5kZXggIT09IHByZXZJbmRleCAmJiBTcGxpZGUub3B0aW9ucy50cmltU3BhY2UgPT09ICdtb3ZlJykge1xuICAgICAgICAgIENvbXBvbmVudHMuQ29udHJvbGxlci5nbyhkZXN0SW5kZXggKyBkZXN0SW5kZXggLSBwcmV2SW5kZXgsIHNpbGVudGx5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvblRyYW5zaXRpb25FbmQoZGVzdEluZGV4LCBuZXdJbmRleCwgcHJldkluZGV4LCBzaWxlbnRseSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlIHRoZSB0cmFjayB0byB0aGUgc3BlY2lmaWVkIGluZGV4LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIEEgZGVzdGluYXRpb24gaW5kZXggd2hlcmUgdGhlIHRyYWNrIGp1bXBzLlxyXG4gICAgICovXG4gICAganVtcDogZnVuY3Rpb24ganVtcChpbmRleCkge1xuICAgICAgdGhpcy50cmFuc2xhdGUoZ2V0VHJpbW1lZFBvc2l0aW9uKGluZGV4KSk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBsaXN0IHBvc2l0aW9uIGJ5IENTUyB0cmFuc2xhdGUgcHJvcGVydHkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIC0gQSBuZXcgcG9zaXRpb24gdmFsdWUuXHJcbiAgICAgKi9cbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uIHRyYW5zbGF0ZShwb3NpdGlvbikge1xuICAgICAgYXBwbHlTdHlsZShsaXN0LCB7XG4gICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVcIiArIChpc1ZlcnRpY2FsID8gJ1knIDogJ1gnKSArIFwiKFwiICsgcG9zaXRpb24gKyBcInB4KVwiXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBDYW5jZWwgdGhlIHRyYW5zaXRpb24gYW5kIHNldCB0aGUgbGlzdCBwb3NpdGlvbi5cclxuICAgICAqIEFsc28sIGxvb3AgdGhlIHNsaWRlciBpZiBuZWNlc3NhcnkuXHJcbiAgICAgKi9cbiAgICBjYW5jZWw6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgIGlmIChTcGxpZGUuaXMoTE9PUCkpIHtcbiAgICAgICAgdGhpcy5zaGlmdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICB0aGlzLnRyYW5zbGF0ZSh0aGlzLnBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgYXBwbHlTdHlsZShsaXN0LCB7XG4gICAgICAgIHRyYW5zaXRpb246ICcnXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBTaGlmdCB0aGUgc2xpZGVyIGlmIGl0IGV4Y2VlZHMgYm9yZGVycyBvbiB0aGUgZWRnZS5cclxuICAgICAqL1xuICAgIHNoaWZ0OiBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IGFicyh0aGlzLnBvc2l0aW9uKTtcbiAgICAgIHZhciBsZWZ0ID0gYWJzKHRoaXMudG9Qb3NpdGlvbigwKSk7XG4gICAgICB2YXIgcmlnaHQgPSBhYnModGhpcy50b1Bvc2l0aW9uKFNwbGlkZS5sZW5ndGgpKTtcbiAgICAgIHZhciBpbm5lclNpemUgPSByaWdodCAtIGxlZnQ7XG5cbiAgICAgIGlmIChwb3NpdGlvbiA8IGxlZnQpIHtcbiAgICAgICAgcG9zaXRpb24gKz0gaW5uZXJTaXplO1xuICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA+IHJpZ2h0KSB7XG4gICAgICAgIHBvc2l0aW9uIC09IGlubmVyU2l6ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50cmFuc2xhdGUoc2lnbiAqIHBvc2l0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBUcmltIHJlZHVuZGFudCBzcGFjZXMgb24gdGhlIGxlZnQgb3IgcmlnaHQgZWRnZSBpZiBuZWNlc3NhcnkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIC0gUG9zaXRpb24gdmFsdWUgdG8gYmUgdHJpbW1lZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVHJpbW1lZCBwb3NpdGlvbi5cclxuICAgICAqL1xuICAgIHRyaW06IGZ1bmN0aW9uIHRyaW0ocG9zaXRpb24pIHtcbiAgICAgIGlmICghU3BsaWRlLm9wdGlvbnMudHJpbVNwYWNlIHx8IFNwbGlkZS5pcyhMT09QKSkge1xuICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBlZGdlID0gc2lnbiAqIChMYXlvdXQudG90YWxTaXplKCkgLSBMYXlvdXQuc2l6ZSAtIExheW91dC5nYXApO1xuICAgICAgcmV0dXJuIGJldHdlZW4ocG9zaXRpb24sIGVkZ2UsIDApO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZSB0aGUgY2xvc2VzdCBzbGlkZSBpbmRleCBmcm9tIHRoZSBnaXZlbiBwb3NpdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gLSBBIHBvc2l0aW9uIGNvbnZlcnRlZCB0byBhbiBzbGlkZSBpbmRleC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIGNsb3Nlc3Qgc2xpZGUgaW5kZXguXHJcbiAgICAgKi9cbiAgICB0b0luZGV4OiBmdW5jdGlvbiB0b0luZGV4KHBvc2l0aW9uKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciBtaW5EaXN0YW5jZSA9IEluZmluaXR5O1xuICAgICAgRWxlbWVudHMuZ2V0U2xpZGVzKHRydWUpLmZvckVhY2goZnVuY3Rpb24gKFNsaWRlKSB7XG4gICAgICAgIHZhciBzbGlkZUluZGV4ID0gU2xpZGUuaW5kZXg7XG4gICAgICAgIHZhciBkaXN0YW5jZSA9IGFicyhfdGhpczIudG9Qb3NpdGlvbihzbGlkZUluZGV4KSAtIHBvc2l0aW9uKTtcblxuICAgICAgICBpZiAoZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgICAgaW5kZXggPSBzbGlkZUluZGV4O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gY29vcmRpbmF0ZXMgb2JqZWN0IGJ5IHRoZSBnaXZlbiBwb3NpdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gLSBBIHBvc2l0aW9uIHZhbHVlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gLSBBIGNvb3JkaW5hdGVzIG9iamVjdC5cclxuICAgICAqL1xuICAgIHRvQ29vcmQ6IGZ1bmN0aW9uIHRvQ29vcmQocG9zaXRpb24pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IGlzVmVydGljYWwgPyAwIDogcG9zaXRpb24sXG4gICAgICAgIHk6IGlzVmVydGljYWwgPyBwb3NpdGlvbiA6IDBcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlIHRoZSB0cmFjayBwb3NpdGlvbiBieSBhIHNsaWRlIGluZGV4LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFNsaWRlIGluZGV4LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gLSBDYWxjdWxhdGVkIHBvc2l0aW9uLlxyXG4gICAgICovXG4gICAgdG9Qb3NpdGlvbjogZnVuY3Rpb24gdG9Qb3NpdGlvbihpbmRleCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gTGF5b3V0LnRvdGFsU2l6ZShpbmRleCkgLSBMYXlvdXQuc2xpZGVTaXplKGluZGV4KSAtIExheW91dC5nYXA7XG4gICAgICByZXR1cm4gc2lnbiAqIChwb3NpdGlvbiArIHRoaXMub2Zmc2V0KGluZGV4KSk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBjdXJyZW50IG9mZnNldCB2YWx1ZSwgY29uc2lkZXJpbmcgZGlyZWN0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBPZmZzZXQgYW1vdW50LlxyXG4gICAgICovXG4gICAgb2Zmc2V0OiBmdW5jdGlvbiBvZmZzZXQoaW5kZXgpIHtcbiAgICAgIHZhciBmb2N1cyA9IFNwbGlkZS5vcHRpb25zLmZvY3VzO1xuICAgICAgdmFyIHNsaWRlU2l6ZSA9IExheW91dC5zbGlkZVNpemUoaW5kZXgpO1xuXG4gICAgICBpZiAoZm9jdXMgPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHJldHVybiAtKExheW91dC5zaXplIC0gc2xpZGVTaXplKSAvIDI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAtKHBhcnNlSW50KGZvY3VzKSB8fCAwKSAqIChzbGlkZVNpemUgKyBMYXlvdXQuZ2FwKTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgcG9zaXRpb24uXHJcbiAgICAgKiBUaGlzIHJldHVybnMgdGhlIGNvcnJlY3QgcG9zaXRpb24gZXZlbiB3aGlsZSB0cmFuc2l0aW9uaW5nIGJ5IENTUy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gQ3VycmVudCBwb3NpdGlvbi5cclxuICAgICAqL1xuICAgIGdldCBwb3NpdGlvbigpIHtcbiAgICAgIHZhciBwcm9wID0gaXNWZXJ0aWNhbCA/ICd0b3AnIDogaXNSVEwgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgcmV0dXJuIGdldFJlY3QobGlzdClbcHJvcF0gLSAoZ2V0UmVjdChFbGVtZW50cy50cmFjaylbcHJvcF0gLSBMYXlvdXQucGFkZGluZ1twcm9wXSAqIHNpZ24pO1xuICAgIH1cblxuICB9O1xuICAvKipcclxuICAgKiBDYWxsZWQgd2hlbmV2ZXIgc2xpZGVzIGFycml2ZSBhdCBhIGRlc3RpbmF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9ICBkZXN0SW5kZXggLSBBIGRlc3RpbmF0aW9uIGluZGV4LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgbmV3SW5kZXggIC0gQSBuZXcgaW5kZXguXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9ICBwcmV2SW5kZXggLSBBIHByZXZpb3VzIGluZGV4LlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lsZW50bHkgIC0gSWYgdHJ1ZSwgc3VwcHJlc3MgZW1pdHRpbmcgZXZlbnRzLlxyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG9uVHJhbnNpdGlvbkVuZChkZXN0SW5kZXgsIG5ld0luZGV4LCBwcmV2SW5kZXgsIHNpbGVudGx5KSB7XG4gICAgYXBwbHlTdHlsZShsaXN0LCB7XG4gICAgICB0cmFuc2l0aW9uOiAnJ1xuICAgIH0pO1xuICAgIGlzTG9vcFBlbmRpbmcgPSBmYWxzZTtcblxuICAgIGlmICghaXNGYWRlKSB7XG4gICAgICBUcmFjay5qdW1wKG5ld0luZGV4KTtcbiAgICB9XG5cbiAgICBpZiAoIXNpbGVudGx5KSB7XG4gICAgICBTcGxpZGUuZW1pdCgnbW92ZWQnLCBuZXdJbmRleCwgcHJldkluZGV4LCBkZXN0SW5kZXgpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBDb252ZXJ0IGluZGV4IHRvIHRoZSB0cmltbWVkIHBvc2l0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFRyaW1tZWQgcG9zaXRpb24uXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRUcmltbWVkUG9zaXRpb24oaW5kZXgpIHtcbiAgICByZXR1cm4gVHJhY2sudHJpbShUcmFjay50b1Bvc2l0aW9uKGluZGV4KSk7XG4gIH1cblxuICByZXR1cm4gVHJhY2s7XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb21wb25lbnRzL2Nsb25lcy9pbmRleC5qc1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGNsb25pbmcgc29tZSBzbGlkZXMgZm9yIFwibG9vcFwiIG1vZGUgb2YgdGhlIHRyYWNrLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cblxuXG5cbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBjbG9uaW5nIHNvbWUgc2xpZGVzIGZvciBcImxvb3BcIiBtb2RlIG9mIHRoZSB0cmFjay5cclxuICpcclxuICogQHBhcmFtIHtTcGxpZGV9IFNwbGlkZSAgICAgLSBBIFNwbGlkZSBpbnN0YW5jZS5cclxuICogQHBhcmFtIHtPYmplY3R9IENvbXBvbmVudHMgLSBBbiBvYmplY3QgY29udGFpbmluZyBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gVGhlIGNvbXBvbmVudCBvYmplY3QuXHJcbiAqL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGNsb25lcyA9IChmdW5jdGlvbiAoU3BsaWRlLCBDb21wb25lbnRzKSB7XG4gIC8qKlxyXG4gICAqIFN0b3JlIGluZm9ybWF0aW9uIG9mIGFsbCBjbG9uZXMuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICovXG4gIHZhciBjbG9uZXMgPSBbXTtcbiAgLyoqXHJcbiAgICogU3RvcmUgdGhlIGN1cnJlbnQgY2xvbmUgY291bnQgb24gb25lIHNpZGUuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xuXG4gIHZhciBjbG9uZUNvdW50ID0gMDtcbiAgLyoqXHJcbiAgICogS2VlcCBFbGVtZW50cyBjb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG4gIHZhciBFbGVtZW50cyA9IENvbXBvbmVudHMuRWxlbWVudHM7XG4gIC8qKlxyXG4gICAqIENsb25lcyBjb21wb25lbnQgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuICB2YXIgQ2xvbmVzID0ge1xuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxyXG4gICAgICovXG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKFNwbGlkZS5pcyhMT09QKSkge1xuICAgICAgICBpbml0KCk7XG4gICAgICAgIFNwbGlkZS5vbigncmVmcmVzaDpiZWZvcmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuZGVzdHJveSgpO1xuICAgICAgICB9KS5vbigncmVmcmVzaCcsIGluaXQpLm9uKCdyZXNpemUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGNsb25lQ291bnQgIT09IGdldENsb25lQ291bnQoKSkge1xuICAgICAgICAgICAgLy8gRGVzdHJveSBiZWZvcmUgcmVmcmVzaCBub3QgdG8gY29sbGVjdCBjbG9uZXMgYnkgdGhlIEVsZW1lbnRzIGNvbXBvbmVudC5cbiAgICAgICAgICAgIF90aGlzLmRlc3Ryb3koKTtcblxuICAgICAgICAgICAgU3BsaWRlLnJlZnJlc2goKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIERlc3Ryb3kuXHJcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgZG9tX3JlbW92ZShjbG9uZXMpO1xuICAgICAgY2xvbmVzID0gW107XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGFsbCBjbG9uZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7RWxlbWVudFtdfSAtIENsb25lZCBlbGVtZW50cy5cclxuICAgICAqL1xuICAgIGdldCBjbG9uZXMoKSB7XG4gICAgICByZXR1cm4gY2xvbmVzO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJldHVybiBjbG9uZSBsZW5ndGguXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIEEgbGVuZ3RoIG9mIGNsb25lcy5cclxuICAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICByZXR1cm4gY2xvbmVzLmxlbmd0aDtcbiAgICB9XG5cbiAgfTtcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6YXRpb24uXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBDbG9uZXMuZGVzdHJveSgpO1xuICAgIGNsb25lQ291bnQgPSBnZXRDbG9uZUNvdW50KCk7XG4gICAgZ2VuZXJhdGVDbG9uZXMoY2xvbmVDb3VudCk7XG4gIH1cbiAgLyoqXHJcbiAgICogR2VuZXJhdGUgYW5kIGFwcGVuZC9wcmVwZW5kIGNsb25lcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIFRoZSBoYWxmIG51bWJlciBvZiBjbG9uZXMuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUNsb25lcyhjb3VudCkge1xuICAgIHZhciBsZW5ndGggPSBFbGVtZW50cy5sZW5ndGgsXG4gICAgICAgIHJlZ2lzdGVyID0gRWxlbWVudHMucmVnaXN0ZXI7XG5cbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICB2YXIgc2xpZGVzID0gRWxlbWVudHMuc2xpZGVzO1xuXG4gICAgICB3aGlsZSAoc2xpZGVzLmxlbmd0aCA8IGNvdW50KSB7XG4gICAgICAgIHNsaWRlcyA9IHNsaWRlcy5jb25jYXQoc2xpZGVzKTtcbiAgICAgIH0gLy8gQ2xvbmVzIGFmdGVyIHRoZSBsYXN0IGVsZW1lbnQuXG5cblxuICAgICAgc2xpZGVzLnNsaWNlKDAsIGNvdW50KS5mb3JFYWNoKGZ1bmN0aW9uIChlbG0sIGluZGV4KSB7XG4gICAgICAgIHZhciBjbG9uZSA9IGNsb25lRGVlcGx5KGVsbSk7XG4gICAgICAgIGFwcGVuZChFbGVtZW50cy5saXN0LCBjbG9uZSk7XG4gICAgICAgIGNsb25lcy5wdXNoKGNsb25lKTtcbiAgICAgICAgcmVnaXN0ZXIoY2xvbmUsIGluZGV4ICsgbGVuZ3RoLCBpbmRleCAlIGxlbmd0aCk7XG4gICAgICB9KTsgLy8gQ2xvbmVzIGJlZm9yZSB0aGUgZmlyc3QgZWxlbWVudC5cblxuICAgICAgc2xpZGVzLnNsaWNlKC1jb3VudCkuZm9yRWFjaChmdW5jdGlvbiAoZWxtLCBpbmRleCkge1xuICAgICAgICB2YXIgY2xvbmUgPSBjbG9uZURlZXBseShlbG0pO1xuICAgICAgICBiZWZvcmUoY2xvbmUsIHNsaWRlc1swXSk7XG4gICAgICAgIGNsb25lcy5wdXNoKGNsb25lKTtcbiAgICAgICAgcmVnaXN0ZXIoY2xvbmUsIGluZGV4IC0gY291bnQsIChsZW5ndGggKyBpbmRleCAtIGNvdW50ICUgbGVuZ3RoKSAlIGxlbmd0aCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJuIGhhbGYgY291bnQgb2YgY2xvbmVzIHRvIGJlIGdlbmVyYXRlZC5cclxuICAgKiBDbG9uZSBjb3VudCBpcyBkZXRlcm1pbmVkIGJ5OlxyXG4gICAqIC0gXCJjbG9uZXNcIiB2YWx1ZSBpbiB0aGUgb3B0aW9ucy5cclxuICAgKiAtIE51bWJlciBvZiBzbGlkZXMgdGhhdCBjYW4gYmUgcGxhY2VkIGluIGEgdmlldyBpbiBcImZpeGVkXCIgbW9kZS5cclxuICAgKiAtIE1heCBwYWdlcyBhIGZsaWNrIGFjdGlvbiBjYW4gbW92ZS5cclxuICAgKiAtIFdoZXRoZXIgdGhlIHNsaWRlIGxlbmd0aCBpcyBlbm91Z2ggZm9yIHBlclBhZ2UuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gQ291bnQgZm9yIGNsb25lcy5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldENsb25lQ291bnQoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBTcGxpZGUub3B0aW9ucztcblxuICAgIGlmIChvcHRpb25zLmNsb25lcykge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuY2xvbmVzO1xuICAgIH0gLy8gVXNlIHRoZSBzbGlkZSBsZW5ndGggaW4gYXV0b1dpZHRoIG1vZGUgYmVjYXVzZSB0aGUgbnVtYmVyIGNhbm5vdCBiZSBjYWxjdWxhdGVkLlxuXG5cbiAgICB2YXIgYmFzZUNvdW50ID0gb3B0aW9ucy5hdXRvV2lkdGggfHwgb3B0aW9ucy5hdXRvSGVpZ2h0ID8gRWxlbWVudHMubGVuZ3RoIDogb3B0aW9ucy5wZXJQYWdlO1xuICAgIHZhciBkaW1lbnNpb24gPSBvcHRpb25zLmRpcmVjdGlvbiA9PT0gVFRCID8gJ0hlaWdodCcgOiAnV2lkdGgnO1xuICAgIHZhciBmaXhlZFNpemUgPSB0b1BpeGVsKFNwbGlkZS5yb290LCBvcHRpb25zW1wiZml4ZWRcIiArIGRpbWVuc2lvbl0pO1xuXG4gICAgaWYgKGZpeGVkU2l6ZSkge1xuICAgICAgLy8gUm91Z2hseSBjYWxjdWxhdGUgdGhlIGNvdW50LiBUaGlzIG5lZWRzIG5vdCB0byBiZSBzdHJpY3QuXG4gICAgICBiYXNlQ291bnQgPSBNYXRoLmNlaWwoRWxlbWVudHMudHJhY2tbXCJjbGllbnRcIiArIGRpbWVuc2lvbl0gLyBmaXhlZFNpemUpO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlQ291bnQgKiAob3B0aW9ucy5kcmFnID8gb3B0aW9ucy5mbGlja01heFBhZ2VzICsgMSA6IDEpO1xuICB9XG4gIC8qKlxyXG4gICAqIENsb25lIGRlZXBseSB0aGUgZ2l2ZW4gZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxtIC0gQW4gZWxlbWVudCBiZWluZyBkdXBsaWNhdGVkLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Tm9kZX0gLSBBIGNsb25lZCBub2RlKGVsZW1lbnQpLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gY2xvbmVEZWVwbHkoZWxtKSB7XG4gICAgdmFyIGNsb25lID0gZWxtLmNsb25lTm9kZSh0cnVlKTtcbiAgICBhZGRDbGFzcyhjbG9uZSwgU3BsaWRlLmNsYXNzZXMuY2xvbmUpOyAvLyBJRCBzaG91bGQgbm90IGJlIGR1cGxpY2F0ZWQuXG5cbiAgICByZW1vdmVBdHRyaWJ1dGUoY2xvbmUsICdpZCcpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIHJldHVybiBDbG9uZXM7XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb21wb25lbnRzL2xheW91dC9kaXJlY3Rpb25zL2hvcml6b250YWwuanNcbi8qKlxyXG4gKiBUaGUgcmVzb2x2ZXIgY29tcG9uZW50IGZvciBob3Jpem9udGFsIGxheW91dC5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG5cblxuLyoqXHJcbiAqIFRoZSByZXNvbHZlciBjb21wb25lbnQgZm9yIGhvcml6b250YWwgbGF5b3V0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NwbGlkZX0gU3BsaWRlICAgICAtIEEgU3BsaWRlIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gQ29tcG9uZW50cyAtIEFuIG9iamVjdCBjb250YWluaW5nIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBUaGUgcmVzb2x2ZXIgb2JqZWN0LlxyXG4gKi9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBob3Jpem9udGFsID0gKGZ1bmN0aW9uIChTcGxpZGUsIENvbXBvbmVudHMpIHtcbiAgLyoqXHJcbiAgICogS2VlcCB0aGUgRWxlbWVudHMgY29tcG9uZW50LlxyXG4gICAqXHJcbiAgICogQHR5cGUge3N0cmluZ31cclxuICAgKi9cbiAgdmFyIEVsZW1lbnRzID0gQ29tcG9uZW50cy5FbGVtZW50cztcbiAgLyoqXHJcbiAgICogS2VlcCB0aGUgcm9vdCBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHR5cGUge0VsZW1lbnR9XHJcbiAgICovXG5cbiAgdmFyIHJvb3QgPSBTcGxpZGUucm9vdDtcbiAgLyoqXHJcbiAgICogS2VlcCB0aGUgdHJhY2sgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtFbGVtZW50fVxyXG4gICAqL1xuXG4gIHZhciB0cmFjaztcbiAgLyoqXHJcbiAgICogS2VlcCB0aGUgbGF0ZXN0IG9wdGlvbnMuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7RWxlbWVudH1cclxuICAgKi9cblxuICB2YXIgb3B0aW9ucyA9IFNwbGlkZS5vcHRpb25zO1xuICByZXR1cm4ge1xuICAgIC8qKlxyXG4gICAgICogTWFyZ2luIHByb3BlcnR5IG5hbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqL1xuICAgIG1hcmdpbjogJ21hcmdpbicgKyAob3B0aW9ucy5kaXJlY3Rpb24gPT09IFJUTCA/ICdMZWZ0JyA6ICdSaWdodCcpLFxuXG4gICAgLyoqXHJcbiAgICAgKiBBbHdheXMgMCBiZWNhdXNlIHRoZSBoZWlnaHQgd2lsbCBiZSBkZXRlcm1pbmVkIGJ5IGlubmVyIGNvbnRlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cbiAgICBoZWlnaHQ6IDAsXG5cbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemF0aW9uLlxyXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmVzaXplIGdhcCBhbmQgcGFkZGluZy5cclxuICAgICAqIFRoaXMgbXVzdCBiZSBjYWxsZWQgb24gaW5pdC5cclxuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24gcmVzaXplKCkge1xuICAgICAgb3B0aW9ucyA9IFNwbGlkZS5vcHRpb25zO1xuICAgICAgdHJhY2sgPSBFbGVtZW50cy50cmFjaztcbiAgICAgIHRoaXMuZ2FwID0gdG9QaXhlbChyb290LCBvcHRpb25zLmdhcCk7XG4gICAgICB2YXIgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZztcbiAgICAgIHZhciBsZWZ0ID0gdG9QaXhlbChyb290LCBwYWRkaW5nLmxlZnQgfHwgcGFkZGluZyk7XG4gICAgICB2YXIgcmlnaHQgPSB0b1BpeGVsKHJvb3QsIHBhZGRpbmcucmlnaHQgfHwgcGFkZGluZyk7XG4gICAgICB0aGlzLnBhZGRpbmcgPSB7XG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHJpZ2h0OiByaWdodFxuICAgICAgfTtcbiAgICAgIGFwcGx5U3R5bGUodHJhY2ssIHtcbiAgICAgICAgcGFkZGluZ0xlZnQ6IHVuaXQobGVmdCksXG4gICAgICAgIHBhZGRpbmdSaWdodDogdW5pdChyaWdodClcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJldHVybiB0b3RhbCB3aWR0aCBmcm9tIHRoZSBsZWZ0IG9mIHRoZSBsaXN0IHRvIHRoZSByaWdodCBvZiB0aGUgc2xpZGUgc3BlY2lmaWVkIGJ5IHRoZSBwcm92aWRlZCBpbmRleC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBPcHRpb25hbC4gQSBzbGlkZSBpbmRleC4gSWYgdW5kZWZpbmVkLCB0b3RhbCB3aWR0aCBvZiB0aGUgc2xpZGVyIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIFRvdGFsIHdpZHRoIHRvIHRoZSByaWdodCBzaWRlIG9mIHRoZSBzcGVjaWZpZWQgc2xpZGUsIG9yIDAgZm9yIGFuIGludmFsaWQgaW5kZXguXHJcbiAgICAgKi9cbiAgICB0b3RhbFdpZHRoOiBmdW5jdGlvbiB0b3RhbFdpZHRoKGluZGV4KSB7XG4gICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkge1xuICAgICAgICBpbmRleCA9IFNwbGlkZS5sZW5ndGggLSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgU2xpZGUgPSBFbGVtZW50cy5nZXRTbGlkZShpbmRleCk7XG4gICAgICB2YXIgd2lkdGggPSAwO1xuXG4gICAgICBpZiAoU2xpZGUpIHtcbiAgICAgICAgdmFyIHNsaWRlUmVjdCA9IGdldFJlY3QoU2xpZGUuc2xpZGUpO1xuICAgICAgICB2YXIgbGlzdFJlY3QgPSBnZXRSZWN0KEVsZW1lbnRzLmxpc3QpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGlvbiA9PT0gUlRMKSB7XG4gICAgICAgICAgd2lkdGggPSBsaXN0UmVjdC5yaWdodCAtIHNsaWRlUmVjdC5sZWZ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpZHRoID0gc2xpZGVSZWN0LnJpZ2h0IC0gbGlzdFJlY3QubGVmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHdpZHRoICs9IHRoaXMuZ2FwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gd2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBzbGlkZSB3aWR0aCBpbiBweC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBTbGlkZSBpbmRleC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHNsaWRlIHdpZHRoLlxyXG4gICAgICovXG4gICAgc2xpZGVXaWR0aDogZnVuY3Rpb24gc2xpZGVXaWR0aChpbmRleCkge1xuICAgICAgaWYgKG9wdGlvbnMuYXV0b1dpZHRoKSB7XG4gICAgICAgIHZhciBTbGlkZSA9IEVsZW1lbnRzLmdldFNsaWRlKGluZGV4KTtcbiAgICAgICAgcmV0dXJuIFNsaWRlID8gU2xpZGUuc2xpZGUub2Zmc2V0V2lkdGggOiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgd2lkdGggPSBvcHRpb25zLmZpeGVkV2lkdGggfHwgKHRoaXMud2lkdGggKyB0aGlzLmdhcCkgLyBvcHRpb25zLnBlclBhZ2UgLSB0aGlzLmdhcDtcbiAgICAgIHJldHVybiB0b1BpeGVsKHJvb3QsIHdpZHRoKTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIHNsaWRlIGhlaWdodCBpbiBweC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIHNsaWRlIGhlaWdodC5cclxuICAgICAqL1xuICAgIHNsaWRlSGVpZ2h0OiBmdW5jdGlvbiBzbGlkZUhlaWdodCgpIHtcbiAgICAgIHZhciBoZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCBvcHRpb25zLmZpeGVkSGVpZ2h0IHx8IHRoaXMud2lkdGggKiBvcHRpb25zLmhlaWdodFJhdGlvO1xuICAgICAgcmV0dXJuIHRvUGl4ZWwocm9vdCwgaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gc2xpZGVyIHdpZHRoIHdpdGhvdXQgcGFkZGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gQ3VycmVudCBzbGlkZXIgd2lkdGguXHJcbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICByZXR1cm4gdHJhY2suY2xpZW50V2lkdGggLSB0aGlzLnBhZGRpbmcubGVmdCAtIHRoaXMucGFkZGluZy5yaWdodDtcbiAgICB9XG5cbiAgfTtcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbXBvbmVudHMvbGF5b3V0L2RpcmVjdGlvbnMvdmVydGljYWwuanNcbi8qKlxyXG4gKiBUaGUgcmVzb2x2ZXIgY29tcG9uZW50IGZvciB2ZXJ0aWNhbCBsYXlvdXQuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuXG5cbi8qKlxyXG4gKiBUaGUgcmVzb2x2ZXIgY29tcG9uZW50IGZvciB2ZXJ0aWNhbCBsYXlvdXQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3BsaWRlfSBTcGxpZGUgICAgIC0gQSBTcGxpZGUgaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBDb21wb25lbnRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgY29tcG9uZW50cy5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAtIFRoZSByZXNvbHZlciBvYmplY3QuXHJcbiAqL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IHZlcnRpY2FsID0gKGZ1bmN0aW9uIChTcGxpZGUsIENvbXBvbmVudHMpIHtcbiAgLyoqXHJcbiAgICogS2VlcCB0aGUgRWxlbWVudHMgY29tcG9uZW50LlxyXG4gICAqXHJcbiAgICogQHR5cGUge3N0cmluZ31cclxuICAgKi9cbiAgdmFyIEVsZW1lbnRzID0gQ29tcG9uZW50cy5FbGVtZW50cztcbiAgLyoqXHJcbiAgICogS2VlcCB0aGUgcm9vdCBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHR5cGUge0VsZW1lbnR9XHJcbiAgICovXG5cbiAgdmFyIHJvb3QgPSBTcGxpZGUucm9vdDtcbiAgLyoqXHJcbiAgICogS2VlcCB0aGUgdHJhY2sgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtFbGVtZW50fVxyXG4gICAqL1xuXG4gIHZhciB0cmFjaztcbiAgLyoqXHJcbiAgICogS2VlcCB0aGUgbGF0ZXN0IG9wdGlvbnMuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7RWxlbWVudH1cclxuICAgKi9cblxuICB2YXIgb3B0aW9ucztcbiAgcmV0dXJuIHtcbiAgICAvKipcclxuICAgICAqIE1hcmdpbiBwcm9wZXJ0eSBuYW1lLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKi9cbiAgICBtYXJnaW46ICdtYXJnaW5Cb3R0b20nLFxuXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXphdGlvbi5cclxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJlc2l6ZSBnYXAgYW5kIHBhZGRpbmcuXHJcbiAgICAgKiBUaGlzIG11c3QgYmUgY2FsbGVkIG9uIGluaXQuXHJcbiAgICAgKi9cbiAgICByZXNpemU6IGZ1bmN0aW9uIHJlc2l6ZSgpIHtcbiAgICAgIG9wdGlvbnMgPSBTcGxpZGUub3B0aW9ucztcbiAgICAgIHRyYWNrID0gRWxlbWVudHMudHJhY2s7XG4gICAgICB0aGlzLmdhcCA9IHRvUGl4ZWwocm9vdCwgb3B0aW9ucy5nYXApO1xuICAgICAgdmFyIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmc7XG4gICAgICB2YXIgdG9wID0gdG9QaXhlbChyb290LCBwYWRkaW5nLnRvcCB8fCBwYWRkaW5nKTtcbiAgICAgIHZhciBib3R0b20gPSB0b1BpeGVsKHJvb3QsIHBhZGRpbmcuYm90dG9tIHx8IHBhZGRpbmcpO1xuICAgICAgdGhpcy5wYWRkaW5nID0ge1xuICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgYm90dG9tOiBib3R0b21cbiAgICAgIH07XG4gICAgICBhcHBseVN0eWxlKHRyYWNrLCB7XG4gICAgICAgIHBhZGRpbmdUb3A6IHVuaXQodG9wKSxcbiAgICAgICAgcGFkZGluZ0JvdHRvbTogdW5pdChib3R0b20pXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdG90YWwgaGVpZ2h0IGZyb20gdGhlIHRvcCBvZiB0aGUgbGlzdCB0byB0aGUgYm90dG9tIG9mIHRoZSBzbGlkZSBzcGVjaWZpZWQgYnkgdGhlIHByb3ZpZGVkIGluZGV4LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIE9wdGlvbmFsLiBBIHNsaWRlIGluZGV4LiBJZiB1bmRlZmluZWQsIHRvdGFsIGhlaWdodCBvZiB0aGUgc2xpZGVyIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIFRvdGFsIGhlaWdodCB0byB0aGUgYm90dG9tIG9mIHRoZSBzcGVjaWZpZWQgc2xpZGUsIG9yIDAgZm9yIGFuIGludmFsaWQgaW5kZXguXHJcbiAgICAgKi9cbiAgICB0b3RhbEhlaWdodDogZnVuY3Rpb24gdG90YWxIZWlnaHQoaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGluZGV4ID0gU3BsaWRlLmxlbmd0aCAtIDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBTbGlkZSA9IEVsZW1lbnRzLmdldFNsaWRlKGluZGV4KTtcblxuICAgICAgaWYgKFNsaWRlKSB7XG4gICAgICAgIHJldHVybiBnZXRSZWN0KFNsaWRlLnNsaWRlKS5ib3R0b20gLSBnZXRSZWN0KEVsZW1lbnRzLmxpc3QpLnRvcCArIHRoaXMuZ2FwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIHNsaWRlIHdpZHRoIGluIHB4LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgc2xpZGUgd2lkdGguXHJcbiAgICAgKi9cbiAgICBzbGlkZVdpZHRoOiBmdW5jdGlvbiBzbGlkZVdpZHRoKCkge1xuICAgICAgcmV0dXJuIHRvUGl4ZWwocm9vdCwgb3B0aW9ucy5maXhlZFdpZHRoIHx8IHRoaXMud2lkdGgpO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgc2xpZGUgaGVpZ2h0IGluIHB4LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFNsaWRlIGluZGV4LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgc2xpZGUgaGVpZ2h0LlxyXG4gICAgICovXG4gICAgc2xpZGVIZWlnaHQ6IGZ1bmN0aW9uIHNsaWRlSGVpZ2h0KGluZGV4KSB7XG4gICAgICBpZiAob3B0aW9ucy5hdXRvSGVpZ2h0KSB7XG4gICAgICAgIHZhciBTbGlkZSA9IEVsZW1lbnRzLmdldFNsaWRlKGluZGV4KTtcbiAgICAgICAgcmV0dXJuIFNsaWRlID8gU2xpZGUuc2xpZGUub2Zmc2V0SGVpZ2h0IDogMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGhlaWdodCA9IG9wdGlvbnMuZml4ZWRIZWlnaHQgfHwgKHRoaXMuaGVpZ2h0ICsgdGhpcy5nYXApIC8gb3B0aW9ucy5wZXJQYWdlIC0gdGhpcy5nYXA7XG4gICAgICByZXR1cm4gdG9QaXhlbChyb290LCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJldHVybiBzbGlkZXIgd2lkdGggd2l0aG91dCBwYWRkaW5nLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBDdXJyZW50IHNsaWRlciB3aWR0aC5cclxuICAgICAqL1xuICAgIGdldCB3aWR0aCgpIHtcbiAgICAgIHJldHVybiB0cmFjay5jbGllbnRXaWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gc2xpZGUgaGVpZ2h0IHdpdGhvdXQgcGFkZGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gU2xpZGVyIGhlaWdodC5cclxuICAgICAqL1xuICAgIGdldCBoZWlnaHQoKSB7XG4gICAgICB2YXIgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQgfHwgdGhpcy53aWR0aCAqIG9wdGlvbnMuaGVpZ2h0UmF0aW87XG4gICAgICBleGlzdChoZWlnaHQsICdcImhlaWdodFwiIG9yIFwiaGVpZ2h0UmF0aW9cIiBpcyBtaXNzaW5nLicpO1xuICAgICAgcmV0dXJuIHRvUGl4ZWwocm9vdCwgaGVpZ2h0KSAtIHRoaXMucGFkZGluZy50b3AgLSB0aGlzLnBhZGRpbmcuYm90dG9tO1xuICAgIH1cblxuICB9O1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvdXRpbHMvdGltZS5qc1xuLyoqXHJcbiAqIEEgcGFja2FnZSBvZiB1dGlsaXR5IGZ1bmN0aW9ucyByZWxhdGVkIHdpdGggdGltZS5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG4vKipcclxuICogU2ltcGxlIHRocm90dGxlIGZ1bmN0aW9uIHRoYXQgY29udHJvbHMgaG93IG9mdGVuIHRoZSBnaXZlbiBmdW5jdGlvbiBpcyBleGVjdXRlZC5cclxuICpcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyAtIEEgZnVuY3Rpb24gdG8gYmUgdGhyb3R0bGVkLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gICB3YWl0IC0gVGltZSBpbiBtaWxsaXNlY29uZCBmb3IgaW50ZXJ2YWwgb2YgZXhlY3V0aW9uLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gLSBBIGRlYm91bmNlZCBmdW5jdGlvbi5cclxuICovXG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0KSB7XG4gIHZhciB0aW1lb3V0OyAvLyBEZWNsYXJlIGZ1bmN0aW9uIGJ5IHRoZSBcImZ1bmN0aW9uXCIga2V5d29yZCB0byBwcmV2ZW50IFwidGhpc1wiIGZyb20gYmVpbmcgaW5oZXJpdGVkLlxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aW1lb3V0KSB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmMoKTtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICB9LCB3YWl0KTtcbiAgICB9XG4gIH07XG59XG4vKipcclxuICogQ3VzdG9tIHNldEludGVydmFsIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgcHJvZ3Jlc3MgcmF0ZSBhcyBjYWxsYmFjay5cclxuICpcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBBIGNhbGxiYWNrIGZ1bmN0aW9uIGZpcmVkIGV2ZXJ5IHRpbWUgdGhlIGludGVydmFsIHRpbWUgcGFzc2VzLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gICBpbnRlcnZhbCAtIEludGVydmFsIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gcHJvZ3Jlc3MgLSBBIGNhbGxiYWNrIGZ1bmN0aW9uIGZpcmVkIHdoZW5ldmVyIHRoZSBwcm9ncmVzcyBnb2VzLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgcGxheSgpIGFuZCBwYXVzZSgpIGZ1bmN0aW9ucy5cclxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUludGVydmFsKGNhbGxiYWNrLCBpbnRlcnZhbCwgcHJvZ3Jlc3MpIHtcbiAgdmFyIF93aW5kb3cgPSB3aW5kb3csXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBfd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgdmFyIHN0YXJ0LFxuICAgICAgZWxhcHNlLFxuICAgICAgcmF0ZSxcbiAgICAgIF9wYXVzZSA9IHRydWU7XG5cbiAgdmFyIHN0ZXAgPSBmdW5jdGlvbiBzdGVwKHRpbWVzdGFtcCkge1xuICAgIGlmICghX3BhdXNlKSB7XG4gICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgIHN0YXJ0ID0gdGltZXN0YW1wO1xuXG4gICAgICAgIGlmIChyYXRlICYmIHJhdGUgPCAxKSB7XG4gICAgICAgICAgc3RhcnQgLT0gcmF0ZSAqIGludGVydmFsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVsYXBzZSA9IHRpbWVzdGFtcCAtIHN0YXJ0O1xuICAgICAgcmF0ZSA9IGVsYXBzZSAvIGludGVydmFsO1xuXG4gICAgICBpZiAoZWxhcHNlID49IGludGVydmFsKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgcmF0ZSA9IDE7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9ncmVzcykge1xuICAgICAgICBwcm9ncmVzcyhyYXRlKTtcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHBhdXNlOiBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAgIF9wYXVzZSA9IHRydWU7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfSxcbiAgICBwbGF5OiBmdW5jdGlvbiBwbGF5KHJlc2V0KSB7XG4gICAgICBzdGFydCA9IDA7XG5cbiAgICAgIGlmIChyZXNldCkge1xuICAgICAgICByYXRlID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKF9wYXVzZSkge1xuICAgICAgICBfcGF1c2UgPSBmYWxzZTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb21wb25lbnRzL2xheW91dC9pbmRleC5qc1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGhhbmRpbmcgc2xpZGUgbGF5b3V0cyBhbmQgdGhlaXIgc2l6ZXMuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuXG5cblxuXG5cblxuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGhhbmRpbmcgc2xpZGUgbGF5b3V0cyBhbmQgdGhlaXIgc2l6ZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3BsaWRlfSBTcGxpZGUgICAgIC0gQSBTcGxpZGUgaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBDb21wb25lbnRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgY29tcG9uZW50cy5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAtIFRoZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gKi9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBsYXlvdXQgPSAoZnVuY3Rpb24gKFNwbGlkZSwgQ29tcG9uZW50cykge1xuICAvKipcclxuICAgKiBLZWVwIHRoZSBFbGVtZW50cyBjb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAqL1xuICB2YXIgRWxlbWVudHMgPSBDb21wb25lbnRzLkVsZW1lbnRzO1xuICAvKipcclxuICAgKiBXaGV0aGVyIHRoZSBzbGlkZXIgaXMgdmVydGljYWwgb3Igbm90LlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG5cbiAgdmFyIGlzVmVydGljYWwgPSBTcGxpZGUub3B0aW9ucy5kaXJlY3Rpb24gPT09IFRUQjtcbiAgLyoqXHJcbiAgICogTGF5b3V0IGNvbXBvbmVudCBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG4gIHZhciBMYXlvdXQgPSBvYmplY3RfYXNzaWduKHtcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cclxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIGJpbmQoKTtcbiAgICAgIGluaXQoKTsgLy8gVGhlIHdvcmQgXCJzaXplXCIgbWVhbnMgd2lkdGggZm9yIGEgaG9yaXpvbnRhbCBzbGlkZXIgYW5kIGhlaWdodCBmb3IgYSB2ZXJ0aWNhbCBzbGlkZXIuXG5cbiAgICAgIHRoaXMudG90YWxTaXplID0gaXNWZXJ0aWNhbCA/IHRoaXMudG90YWxIZWlnaHQgOiB0aGlzLnRvdGFsV2lkdGg7XG4gICAgICB0aGlzLnNsaWRlU2l6ZSA9IGlzVmVydGljYWwgPyB0aGlzLnNsaWRlSGVpZ2h0IDogdGhpcy5zbGlkZVdpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIERlc3Ryb3kgdGhlIGNvbXBvbmVudC5cclxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICByZW1vdmVBdHRyaWJ1dGUoW0VsZW1lbnRzLmxpc3QsIEVsZW1lbnRzLnRyYWNrXSwgJ3N0eWxlJyk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBzbGlkZXIgaGVpZ2h0IG9uIHRoZSB2ZXJ0aWNhbCBtb2RlIG9yIHdpZHRoIG9uIHRoZSBob3Jpem9udGFsIG1vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAgICovXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gaXNWZXJ0aWNhbCA/IHRoaXMuaGVpZ2h0IDogdGhpcy53aWR0aDtcbiAgICB9XG5cbiAgfSwgaXNWZXJ0aWNhbCA/IHZlcnRpY2FsKFNwbGlkZSwgQ29tcG9uZW50cykgOiBob3Jpem9udGFsKFNwbGlkZSwgQ29tcG9uZW50cykpO1xuICAvKipcclxuICAgKiBJbml0IHNsaWRlciBzdHlsZXMgYWNjb3JkaW5nIHRvIG9wdGlvbnMuXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBMYXlvdXQuaW5pdCgpO1xuICAgIGFwcGx5U3R5bGUoU3BsaWRlLnJvb3QsIHtcbiAgICAgIG1heFdpZHRoOiB1bml0KFNwbGlkZS5vcHRpb25zLndpZHRoKVxuICAgIH0pO1xuICAgIEVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKFNsaWRlKSB7XG4gICAgICBTbGlkZS5zbGlkZS5zdHlsZVtMYXlvdXQubWFyZ2luXSA9IHVuaXQoTGF5b3V0LmdhcCk7XG4gICAgfSk7XG4gICAgcmVzaXplKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogTGlzdGVuIHRoZSByZXNpemUgbmF0aXZlIGV2ZW50IHdpdGggdGhyb3R0bGUuXHJcbiAgICogSW5pdGlhbGl6ZSB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZCBvciBvcHRpb25zIGFyZSB1cGRhdGVkLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYmluZCgpIHtcbiAgICBTcGxpZGUub24oJ3Jlc2l6ZSBsb2FkJywgdGhyb3R0bGUoZnVuY3Rpb24gKCkge1xuICAgICAgU3BsaWRlLmVtaXQoJ3Jlc2l6ZScpO1xuICAgIH0sIFNwbGlkZS5vcHRpb25zLnRocm90dGxlKSwgd2luZG93KS5vbigncmVzaXplJywgcmVzaXplKS5vbigndXBkYXRlZCByZWZyZXNoJywgaW5pdCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVzaXplIHRoZSB0cmFjayBhbmQgc2xpZGUgZWxlbWVudHMuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiByZXNpemUoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBTcGxpZGUub3B0aW9ucztcbiAgICBMYXlvdXQucmVzaXplKCk7XG4gICAgYXBwbHlTdHlsZShFbGVtZW50cy50cmFjaywge1xuICAgICAgaGVpZ2h0OiB1bml0KExheW91dC5oZWlnaHQpXG4gICAgfSk7XG4gICAgdmFyIHNsaWRlSGVpZ2h0ID0gb3B0aW9ucy5hdXRvSGVpZ2h0ID8gbnVsbCA6IHVuaXQoTGF5b3V0LnNsaWRlSGVpZ2h0KCkpO1xuICAgIEVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKFNsaWRlKSB7XG4gICAgICBhcHBseVN0eWxlKFNsaWRlLmNvbnRhaW5lciwge1xuICAgICAgICBoZWlnaHQ6IHNsaWRlSGVpZ2h0XG4gICAgICB9KTtcbiAgICAgIGFwcGx5U3R5bGUoU2xpZGUuc2xpZGUsIHtcbiAgICAgICAgd2lkdGg6IG9wdGlvbnMuYXV0b1dpZHRoID8gbnVsbCA6IHVuaXQoTGF5b3V0LnNsaWRlV2lkdGgoU2xpZGUuaW5kZXgpKSxcbiAgICAgICAgaGVpZ2h0OiBTbGlkZS5jb250YWluZXIgPyBudWxsIDogc2xpZGVIZWlnaHRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIFNwbGlkZS5lbWl0KCdyZXNpemVkJyk7XG4gIH1cblxuICByZXR1cm4gTGF5b3V0O1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29tcG9uZW50cy9kcmFnL2luZGV4LmpzXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3Igc3VwcG9ydGluZyBtb3VzZSBkcmFnIGFuZCBzd2lwZS5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG5cblxuXG5cbnZhciBkcmFnX2FicyA9IE1hdGguYWJzO1xuLyoqXHJcbiAqIElmIHRoZSBhYnNvbHV0ZSB2ZWxvY2l0eSBpcyBncmVhdGVyIHRoYW50IHRoaXMgdmFsdWUsXHJcbiAqIGEgc2xpZGVyIGFsd2F5cyBnb2VzIHRvIGEgZGlmZmVyZW50IHNsaWRlIGFmdGVyIGRyYWcsIG5vdCBhbGxvd2VkIHRvIHN0YXkgb24gYSBjdXJyZW50IHNsaWRlLlxyXG4gKi9cblxudmFyIE1JTl9WRUxPQ0lUWSA9IDAuMTtcbi8qKlxyXG4gKiBBZGp1c3QgaG93IG11Y2ggdGhlIHRyYWNrIGNhbiBiZSBwdWxsZWQgb24gdGhlIGZpcnN0IG9yIGxhc3QgcGFnZS5cclxuICogVGhlIGxhcmdlciBudW1iZXIgdGhpcyBpcywgdGhlIGZhcnRoZXIgdGhlIHRyYWNrIG1vdmVzLlxyXG4gKiBUaGlzIHNob3VsZCBiZSBhcm91bmQgNSAtIDkuXHJcbiAqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqL1xuXG52YXIgRlJJQ1RJT05fUkVEVUNFUiA9IDc7XG4vKipcclxuICogVGhlIGNvbXBvbmVudCBzdXBwb3J0aW5nIG1vdXNlIGRyYWcgYW5kIHN3aXBlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NwbGlkZX0gU3BsaWRlICAgICAtIEEgU3BsaWRlIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gQ29tcG9uZW50cyAtIEFuIG9iamVjdCBjb250YWluaW5nIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBUaGUgY29tcG9uZW50IG9iamVjdC5cclxuICovXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgZHJhZyA9IChmdW5jdGlvbiAoU3BsaWRlLCBDb21wb25lbnRzKSB7XG4gIC8qKlxyXG4gICAqIFN0b3JlIHRoZSBNb3ZlIGNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG4gIHZhciBUcmFjayA9IENvbXBvbmVudHMuVHJhY2s7XG4gIC8qKlxyXG4gICAqIFN0b3JlIHRoZSBDb250cm9sbGVyIGNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cbiAgdmFyIENvbnRyb2xsZXIgPSBDb21wb25lbnRzLkNvbnRyb2xsZXI7XG4gIC8qKlxyXG4gICAqIENvb3JkaW5hdGUgb2YgdGhlIHRyYWNrIG9uIHN0YXJ0aW5nIGRyYWcuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG4gIHZhciBzdGFydENvb3JkO1xuICAvKipcclxuICAgKiBBbmFseXplZCBpbmZvIG9uIHN0YXJ0aW5nIGRyYWcuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XHJcbiAgICovXG5cbiAgdmFyIHN0YXJ0SW5mbztcbiAgLyoqXHJcbiAgICogQW5hbHl6ZWQgaW5mbyBiZWluZyB1cGRhdGVkIHdoaWxlIGRyYWdnaW5nL3N3aXBpbmcuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG4gIHZhciBjdXJyZW50SW5mbztcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgc2xpZGVzIGFyZSBiZWluZyBkcmFnZ2VkIG9yIG5vdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuXG4gIHZhciBpc0RyYWdnaW5nO1xuICAvKipcclxuICAgKiBXaGV0aGVyIHRoZSBzbGlkZXIgZGlyZWN0aW9uIGlzIHZlcnRpY2FsIG9yIG5vdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuXG4gIHZhciBpc1ZlcnRpY2FsID0gU3BsaWRlLm9wdGlvbnMuZGlyZWN0aW9uID09PSBUVEI7XG4gIC8qKlxyXG4gICAqIEF4aXMgZm9yIHRoZSBkaXJlY3Rpb24uXHJcbiAgICpcclxuICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAqL1xuXG4gIHZhciBheGlzID0gaXNWZXJ0aWNhbCA/ICd5JyA6ICd4JztcbiAgLyoqXHJcbiAgICogRHJhZyBjb21wb25lbnQgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuICB2YXIgRHJhZyA9IHtcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgZHJhZ2dpbmcgaXMgZGlzYWJsZWQgb3Igbm90LlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXG4gICAgZGlzYWJsZWQ6IGZhbHNlLFxuXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXHJcbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgRWxlbWVudHMgPSBDb21wb25lbnRzLkVsZW1lbnRzO1xuICAgICAgdmFyIHRyYWNrID0gRWxlbWVudHMudHJhY2s7XG4gICAgICBTcGxpZGUub24oJ3RvdWNoc3RhcnQgbW91c2Vkb3duJywgc3RhcnQsIHRyYWNrKS5vbigndG91Y2htb3ZlIG1vdXNlbW92ZScsIG1vdmUsIHRyYWNrLCB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9KS5vbigndG91Y2hlbmQgdG91Y2hjYW5jZWwgbW91c2VsZWF2ZSBtb3VzZXVwIGRyYWdlbmQnLCBlbmQsIHRyYWNrKS5vbignbW91bnRlZCByZWZyZXNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQcmV2ZW50IGRyYWdnaW5nIGFuIGltYWdlIG9yIGFuY2hvciBpdHNlbGYuXG4gICAgICAgIGVhY2goRWxlbWVudHMubGlzdC5xdWVyeVNlbGVjdG9yQWxsKCdpbWcsIGEnKSwgZnVuY3Rpb24gKGVsbSkge1xuICAgICAgICAgIFNwbGlkZS5vZmYoJ2RyYWdzdGFydCcsIGVsbSkub24oJ2RyYWdzdGFydCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfSwgZWxtLCB7XG4gICAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pLm9uKCdtb3VudGVkIHVwZGF0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmRpc2FibGVkID0gIVNwbGlkZS5vcHRpb25zLmRyYWc7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIENhbGxlZCB3aGVuIHRoZSB0cmFjayBzdGFydHMgdG8gYmUgZHJhZ2dlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudHxNb3VzZUV2ZW50fSBlIC0gVG91Y2hFdmVudCBvciBNb3VzZUV2ZW50IG9iamVjdC5cclxuICAgKi9cblxuICBmdW5jdGlvbiBzdGFydChlKSB7XG4gICAgaWYgKCFEcmFnLmRpc2FibGVkICYmICFpc0RyYWdnaW5nKSB7XG4gICAgICAvLyBUaGVzZSBwcmFtcyBhcmUgdXNlZCB0byBldmFsdWF0ZSB3aGV0aGVyIHRoZSBzbGlkZXIgc2hvdWxkIHN0YXJ0IG1vdmluZy5cbiAgICAgIGluaXQoZSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgcGFyYW1ldGVycy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudHxNb3VzZUV2ZW50fSBlIC0gVG91Y2hFdmVudCBvciBNb3VzZUV2ZW50IG9iamVjdC5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGluaXQoZSkge1xuICAgIHN0YXJ0Q29vcmQgPSBUcmFjay50b0Nvb3JkKFRyYWNrLnBvc2l0aW9uKTtcbiAgICBzdGFydEluZm8gPSBhbmFseXplKGUsIHt9KTtcbiAgICBjdXJyZW50SW5mbyA9IHN0YXJ0SW5mbztcbiAgfVxuICAvKipcclxuICAgKiBDYWxsZWQgd2hpbGUgdGhlIHRyYWNrIGJlaW5nIGRyYWdnZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR8TW91c2VFdmVudH0gZSAtIFRvdWNoRXZlbnQgb3IgTW91c2VFdmVudCBvYmplY3QuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBtb3ZlKGUpIHtcbiAgICBpZiAoc3RhcnRJbmZvKSB7XG4gICAgICBjdXJyZW50SW5mbyA9IGFuYWx5emUoZSwgc3RhcnRJbmZvKTtcblxuICAgICAgaWYgKGlzRHJhZ2dpbmcpIHtcbiAgICAgICAgaWYgKGUuY2FuY2VsYWJsZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghU3BsaWRlLmlzKEZBREUpKSB7XG4gICAgICAgICAgdmFyIHBvc2l0aW9uID0gc3RhcnRDb29yZFtheGlzXSArIGN1cnJlbnRJbmZvLm9mZnNldFtheGlzXTtcbiAgICAgICAgICBUcmFjay50cmFuc2xhdGUocmVzaXN0KHBvc2l0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzaG91bGRNb3ZlKGN1cnJlbnRJbmZvKSkge1xuICAgICAgICAgIFNwbGlkZS5lbWl0KCdkcmFnJywgc3RhcnRJbmZvKTtcbiAgICAgICAgICBpc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICBUcmFjay5jYW5jZWwoKTsgLy8gVGhlc2UgcGFyYW1zIGFyZSBhY3R1YWwgZHJhZyBkYXRhLlxuXG4gICAgICAgICAgaW5pdChlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBEZXRlcm1pbmUgd2hldGhlciB0byBzdGFydCBtb3ZpbmcgdGhlIHRyYWNrIG9yIG5vdCBieSBkcmFnIGFuZ2xlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGluZm8gLSBBbiBpbmZvcm1hdGlvbiBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRydWUgaWYgdGhlIHRyYWNrIHNob3VsZCBiZSBtb3ZlZCBvciBmYWxzZSBpZiBub3QuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBzaG91bGRNb3ZlKF9yZWYpIHtcbiAgICB2YXIgb2Zmc2V0ID0gX3JlZi5vZmZzZXQ7XG5cbiAgICBpZiAoU3BsaWRlLlN0YXRlLmlzKE1PVklORykgJiYgU3BsaWRlLm9wdGlvbnMud2FpdEZvclRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4oZHJhZ19hYnMob2Zmc2V0LnkpIC8gZHJhZ19hYnMob2Zmc2V0LngpKSAqIDE4MCAvIE1hdGguUEk7XG5cbiAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgYW5nbGUgPSA5MCAtIGFuZ2xlO1xuICAgIH1cblxuICAgIHJldHVybiBhbmdsZSA8IFNwbGlkZS5vcHRpb25zLmRyYWdBbmdsZVRocmVzaG9sZDtcbiAgfVxuICAvKipcclxuICAgKiBSZXNpc3QgZHJhZ2dpbmcgdGhlIHRyYWNrIG9uIHRoZSBmaXJzdC9sYXN0IHBhZ2UgYmVjYXVzZSB0aGVyZSBpcyBubyBtb3JlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIC0gQSBwb3NpdGlvbiBiZWluZyBhcHBsaWVkIHRvIHRoZSB0cmFjay5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge09iamVjdH0gLSBBZGp1c3RlZCBwb3NpdGlvbi5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHJlc2lzdChwb3NpdGlvbikge1xuICAgIGlmIChTcGxpZGUuaXMoU0xJREUpKSB7XG4gICAgICB2YXIgc2lnbiA9IFRyYWNrLnNpZ247XG5cbiAgICAgIHZhciBfc3RhcnQgPSBzaWduICogVHJhY2sudHJpbShUcmFjay50b1Bvc2l0aW9uKDApKTtcblxuICAgICAgdmFyIF9lbmQgPSBzaWduICogVHJhY2sudHJpbShUcmFjay50b1Bvc2l0aW9uKENvbnRyb2xsZXIuZWRnZUluZGV4KSk7XG5cbiAgICAgIHBvc2l0aW9uICo9IHNpZ247XG5cbiAgICAgIGlmIChwb3NpdGlvbiA8IF9zdGFydCkge1xuICAgICAgICBwb3NpdGlvbiA9IF9zdGFydCAtIEZSSUNUSU9OX1JFRFVDRVIgKiBNYXRoLmxvZyhfc3RhcnQgLSBwb3NpdGlvbik7XG4gICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID4gX2VuZCkge1xuICAgICAgICBwb3NpdGlvbiA9IF9lbmQgKyBGUklDVElPTl9SRURVQ0VSICogTWF0aC5sb2cocG9zaXRpb24gLSBfZW5kKTtcbiAgICAgIH1cblxuICAgICAgcG9zaXRpb24gKj0gc2lnbjtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH1cbiAgLyoqXHJcbiAgICogQ2FsbGVkIHdoZW4gZHJhZ2dpbmcgZW5kcy5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGVuZCgpIHtcbiAgICBzdGFydEluZm8gPSBudWxsO1xuXG4gICAgaWYgKGlzRHJhZ2dpbmcpIHtcbiAgICAgIFNwbGlkZS5lbWl0KCdkcmFnZ2VkJywgY3VycmVudEluZm8pO1xuICAgICAgZ28oY3VycmVudEluZm8pO1xuICAgICAgaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBHbyB0byB0aGUgc2xpZGUgZGV0ZXJtaW5lZCBieSB0aGUgYW5hbHl6ZWQgZGF0YS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvIC0gQW4gaW5mbyBvYmplY3QuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBnbyhpbmZvKSB7XG4gICAgdmFyIHZlbG9jaXR5ID0gaW5mby52ZWxvY2l0eVtheGlzXTtcbiAgICB2YXIgYWJzViA9IGRyYWdfYWJzKHZlbG9jaXR5KTtcblxuICAgIGlmIChhYnNWID4gMCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBTcGxpZGUub3B0aW9ucztcbiAgICAgIHZhciBpbmRleCA9IFNwbGlkZS5pbmRleDtcbiAgICAgIHZhciBzaWduID0gdmVsb2NpdHkgPCAwID8gLTEgOiAxO1xuICAgICAgdmFyIGRlc3RJbmRleCA9IGluZGV4O1xuXG4gICAgICBpZiAoIVNwbGlkZS5pcyhGQURFKSkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSBUcmFjay5wb3NpdGlvbjtcblxuICAgICAgICBpZiAoYWJzViA+IG9wdGlvbnMuZmxpY2tWZWxvY2l0eVRocmVzaG9sZCAmJiBkcmFnX2FicyhpbmZvLm9mZnNldFtheGlzXSkgPCBvcHRpb25zLnN3aXBlRGlzdGFuY2VUaHJlc2hvbGQpIHtcbiAgICAgICAgICBkZXN0aW5hdGlvbiArPSBzaWduICogTWF0aC5taW4oYWJzViAqIG9wdGlvbnMuZmxpY2tQb3dlciwgQ29tcG9uZW50cy5MYXlvdXQuc2l6ZSAqIChvcHRpb25zLmZsaWNrTWF4UGFnZXMgfHwgMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzdEluZGV4ID0gVHJhY2sudG9JbmRleChkZXN0aW5hdGlvbik7XG4gICAgICB9XG4gICAgICAvKlxyXG4gICAgICAgKiBEbyBub3QgYWxsb3cgdGhlIHRyYWNrIHRvIGdvIHRvIGEgcHJldmlvdXMgcG9zaXRpb24gaWYgdGhlcmUgaXMgZW5vdWdoIHZlbG9jaXR5LlxyXG4gICAgICAgKiBBbHdheXMgdXNlIHRoZSBhZGphY2VudCBpbmRleCBmb3IgdGhlIGZhZGUgbW9kZS5cclxuICAgICAgICovXG5cblxuICAgICAgaWYgKGRlc3RJbmRleCA9PT0gaW5kZXggJiYgYWJzViA+IE1JTl9WRUxPQ0lUWSkge1xuICAgICAgICBkZXN0SW5kZXggPSBpbmRleCArIHNpZ24gKiBUcmFjay5zaWduO1xuICAgICAgfVxuXG4gICAgICBpZiAoU3BsaWRlLmlzKFNMSURFKSkge1xuICAgICAgICBkZXN0SW5kZXggPSBiZXR3ZWVuKGRlc3RJbmRleCwgMCwgQ29udHJvbGxlci5lZGdlSW5kZXgpO1xuICAgICAgfVxuXG4gICAgICBDb250cm9sbGVyLmdvKGRlc3RJbmRleCwgb3B0aW9ucy5pc05hdmlnYXRpb24pO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBBbmFseXplIHRoZSBnaXZlbiBldmVudCBvYmplY3QgYW5kIHJldHVybiBpbXBvcnRhbnQgaW5mb3JtYXRpb24gZm9yIGhhbmRsaW5nIHN3aXBlIGJlaGF2aW9yLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFdmVudH0gICBlICAgICAgICAgIC0gVG91Y2ggb3IgTW91c2UgZXZlbnQgb2JqZWN0LlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAgc3RhcnRJbmZvICAtIEluZm9ybWF0aW9uIGFuYWx5emVkIG9uIHN0YXJ0IGZvciBjYWxjdWxhdGluZyBkaWZmZXJlbmNlIGZyb20gdGhlIGN1cnJlbnQgb25lLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7T2JqZWN0fSAtIEFuIG9iamVjdCBjb250YWluaW5nIGFuYWx5emVkIGluZm9ybWF0aW9uLCBzdWNoIGFzIG9mZnNldCwgdmVsb2NpdHksIGV0Yy5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGFuYWx5emUoZSwgc3RhcnRJbmZvKSB7XG4gICAgdmFyIHRpbWVTdGFtcCA9IGUudGltZVN0YW1wLFxuICAgICAgICB0b3VjaGVzID0gZS50b3VjaGVzO1xuXG4gICAgdmFyIF9yZWYyID0gdG91Y2hlcyA/IHRvdWNoZXNbMF0gOiBlLFxuICAgICAgICBjbGllbnRYID0gX3JlZjIuY2xpZW50WCxcbiAgICAgICAgY2xpZW50WSA9IF9yZWYyLmNsaWVudFk7XG5cbiAgICB2YXIgX3JlZjMgPSBzdGFydEluZm8udG8gfHwge30sXG4gICAgICAgIF9yZWYzJHggPSBfcmVmMy54LFxuICAgICAgICBmcm9tWCA9IF9yZWYzJHggPT09IHZvaWQgMCA/IGNsaWVudFggOiBfcmVmMyR4LFxuICAgICAgICBfcmVmMyR5ID0gX3JlZjMueSxcbiAgICAgICAgZnJvbVkgPSBfcmVmMyR5ID09PSB2b2lkIDAgPyBjbGllbnRZIDogX3JlZjMkeTtcblxuICAgIHZhciBzdGFydFRpbWUgPSBzdGFydEluZm8udGltZSB8fCAwO1xuICAgIHZhciBvZmZzZXQgPSB7XG4gICAgICB4OiBjbGllbnRYIC0gZnJvbVgsXG4gICAgICB5OiBjbGllbnRZIC0gZnJvbVlcbiAgICB9O1xuICAgIHZhciBkdXJhdGlvbiA9IHRpbWVTdGFtcCAtIHN0YXJ0VGltZTtcbiAgICB2YXIgdmVsb2NpdHkgPSB7XG4gICAgICB4OiBvZmZzZXQueCAvIGR1cmF0aW9uLFxuICAgICAgeTogb2Zmc2V0LnkgLyBkdXJhdGlvblxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvOiB7XG4gICAgICAgIHg6IGNsaWVudFgsXG4gICAgICAgIHk6IGNsaWVudFlcbiAgICAgIH0sXG4gICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgIHRpbWU6IHRpbWVTdGFtcCxcbiAgICAgIHZlbG9jaXR5OiB2ZWxvY2l0eVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gRHJhZztcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbXBvbmVudHMvY2xpY2svaW5kZXguanNcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBoYW5kbGluZyBhIGNsaWNrIGV2ZW50LlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBoYW5kbGluZyBhIGNsaWNrIGV2ZW50LlxyXG4gKiBDbGljayBzaG91bGQgYmUgZGlzYWJsZWQgZHVyaW5nIGRyYWcvc3dpcGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3BsaWRlfSBTcGxpZGUgICAgIC0gQSBTcGxpZGUgaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBDb21wb25lbnRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgY29tcG9uZW50cy5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAtIFRoZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY2xpY2sgPSAoZnVuY3Rpb24gKFNwbGlkZSwgQ29tcG9uZW50cykge1xuICAvKipcclxuICAgKiBXaGV0aGVyIGNsaWNrIGlzIGRpc2FibGVkIG9yIG5vdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuICB2YXIgZGlzYWJsZWQgPSBmYWxzZTtcbiAgLyoqXHJcbiAgICogQ2xpY2sgY29tcG9uZW50IG9iamVjdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cbiAgdmFyIENsaWNrID0ge1xuICAgIC8qKlxyXG4gICAgICogTW91bnQgb25seSB3aGVuIHRoZSBkcmFnIGlzIGFjdGl2YXRlZCBhbmQgdGhlIHNsaWRlIHR5cGUgaXMgbm90IFwiZmFkZVwiLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXG4gICAgcmVxdWlyZWQ6IFNwbGlkZS5vcHRpb25zLmRyYWcsXG5cbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cclxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIFNwbGlkZS5vbignY2xpY2snLCBvbkNsaWNrLCBDb21wb25lbnRzLkVsZW1lbnRzLnRyYWNrLCB7XG4gICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICAgIH0pLm9uKCdkcmFnJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBkaXNhYmxlZCA9IHRydWU7XG4gICAgICB9KS5vbignZHJhZ2dlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBmbGFnIGlzIHJlbGVhc2VkIGFmdGVyIHRoZSBjbGljayBldmVudCBpcyBmaXJlZC5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIENhbGxlZCB3aGVuIGEgdHJhY2sgZWxlbWVudCBpcyBjbGlja2VkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFdmVudH0gZSAtIEEgY2xpY2sgZXZlbnQuXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gQ2xpY2s7XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb21wb25lbnRzL2F1dG9wbGF5L2luZGV4LmpzXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgcGxheWluZyBzbGlkZXMgYXV0b21hdGljYWxseS5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG5cbi8qKlxyXG4gKiBTZXQgb2YgcGF1c2UgZmxhZ3MuXHJcbiAqL1xuXG52YXIgUEFVU0VfRkxBR1MgPSB7XG4gIEhPVkVSOiAxLFxuICBGT0NVUzogMixcbiAgTUFOVUFMOiAzXG59O1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIHBsYXlpbmcgc2xpZGVzIGF1dG9tYXRpY2FsbHkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3BsaWRlfSBTcGxpZGUgICAgIC0gQSBTcGxpZGUgaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBDb21wb25lbnRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgY29tcG9uZW50cy5cclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgICAgICAgLSBBIGNvbXBvbmVudCBuYW1lIGFzIGEgbG93ZXJjYXNlIHN0cmluZy5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAtIFRoZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gKi9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBhdXRvcGxheSA9IChmdW5jdGlvbiAoU3BsaWRlLCBDb21wb25lbnRzLCBuYW1lKSB7XG4gIC8qKlxyXG4gICAqIFN0b3JlIHBhdXNlIGZsYWdzLlxyXG4gICAqXHJcbiAgICogQHR5cGUge0FycmF5fVxyXG4gICAqL1xuICB2YXIgZmxhZ3MgPSBbXTtcbiAgLyoqXHJcbiAgICogU3RvcmUgYW4gaW50ZXJ2YWwgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH07XHJcbiAgICovXG5cbiAgdmFyIGludGVydmFsO1xuICAvKipcclxuICAgKiBLZWVwIHRoZSBFbGVtZW50cyBjb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAqL1xuXG4gIHZhciBFbGVtZW50cyA9IENvbXBvbmVudHMuRWxlbWVudHM7XG4gIC8qKlxyXG4gICAqIEF1dG9wbGF5IGNvbXBvbmVudCBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG4gIHZhciBBdXRvcGxheSA9IHtcbiAgICAvKipcclxuICAgICAqIFJlcXVpcmVkIG9ubHkgd2hlbiB0aGUgYXV0b3BsYXkgb3B0aW9uIGlzIHRydWUuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cbiAgICByZXF1aXJlZDogU3BsaWRlLm9wdGlvbnMuYXV0b3BsYXksXG5cbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cclxuICAgICAqIE5vdGUgdGhhdCBhdXRvcGxheSBzdGFydHMgb25seSBpZiB0aGVyZSBhcmUgc2xpZGVzIG92ZXIgcGVyUGFnZSBudW1iZXIuXHJcbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IFNwbGlkZS5vcHRpb25zO1xuXG4gICAgICBpZiAoRWxlbWVudHMuc2xpZGVzLmxlbmd0aCA+IG9wdGlvbnMucGVyUGFnZSkge1xuICAgICAgICBpbnRlcnZhbCA9IGNyZWF0ZUludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBTcGxpZGUuZ28oJz4nKTtcbiAgICAgICAgfSwgb3B0aW9ucy5pbnRlcnZhbCwgZnVuY3Rpb24gKHJhdGUpIHtcbiAgICAgICAgICBTcGxpZGUuZW1pdChuYW1lICsgXCI6cGxheWluZ1wiLCByYXRlKTtcblxuICAgICAgICAgIGlmIChFbGVtZW50cy5iYXIpIHtcbiAgICAgICAgICAgIGFwcGx5U3R5bGUoRWxlbWVudHMuYmFyLCB7XG4gICAgICAgICAgICAgIHdpZHRoOiByYXRlICogMTAwICsgXCIlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGJpbmQoKTtcbiAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogU3RhcnQgYXV0b3BsYXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZsYWcgLSBBIHBhdXNlIGZsYWcgdG8gYmUgcmVtb3ZlZC5cclxuICAgICAqL1xuICAgIHBsYXk6IGZ1bmN0aW9uIHBsYXkoZmxhZykge1xuICAgICAgaWYgKGZsYWcgPT09IHZvaWQgMCkge1xuICAgICAgICBmbGFnID0gMDtcbiAgICAgIH1cblxuICAgICAgZmxhZ3MgPSBmbGFncy5maWx0ZXIoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGYgIT09IGZsYWc7XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFmbGFncy5sZW5ndGgpIHtcbiAgICAgICAgU3BsaWRlLmVtaXQobmFtZSArIFwiOnBsYXlcIik7XG4gICAgICAgIGludGVydmFsLnBsYXkoU3BsaWRlLm9wdGlvbnMucmVzZXRQcm9ncmVzcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUGF1c2UgYXV0b3BsYXkuXHJcbiAgICAgKiBOb3RlIHRoYXQgQXJyYXkuaW5jbHVkZXMgaXMgbm90IHN1cHBvcnRlZCBieSBJRS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZmxhZyAtIEEgcGF1c2UgZmxhZyB0byBiZSBhZGRlZC5cclxuICAgICAqL1xuICAgIHBhdXNlOiBmdW5jdGlvbiBwYXVzZShmbGFnKSB7XG4gICAgICBpZiAoZmxhZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGZsYWcgPSAwO1xuICAgICAgfVxuXG4gICAgICBpbnRlcnZhbC5wYXVzZSgpO1xuXG4gICAgICBpZiAoZmxhZ3MuaW5kZXhPZihmbGFnKSA9PT0gLTEpIHtcbiAgICAgICAgZmxhZ3MucHVzaChmbGFnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZsYWdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBTcGxpZGUuZW1pdChuYW1lICsgXCI6cGF1c2VcIik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBMaXN0ZW4gc29tZSBldmVudHMuXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gYmluZCgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IFNwbGlkZS5vcHRpb25zO1xuICAgIHZhciBzaWJsaW5nID0gU3BsaWRlLnNpYmxpbmc7XG4gICAgdmFyIGVsbXMgPSBbU3BsaWRlLnJvb3QsIHNpYmxpbmcgPyBzaWJsaW5nLnJvb3QgOiBudWxsXTtcblxuICAgIGlmIChvcHRpb25zLnBhdXNlT25Ib3Zlcikge1xuICAgICAgc3dpdGNoT24oZWxtcywgJ21vdXNlbGVhdmUnLCBQQVVTRV9GTEFHUy5IT1ZFUiwgdHJ1ZSk7XG4gICAgICBzd2l0Y2hPbihlbG1zLCAnbW91c2VlbnRlcicsIFBBVVNFX0ZMQUdTLkhPVkVSLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucGF1c2VPbkZvY3VzKSB7XG4gICAgICBzd2l0Y2hPbihlbG1zLCAnZm9jdXNvdXQnLCBQQVVTRV9GTEFHUy5GT0NVUywgdHJ1ZSk7XG4gICAgICBzd2l0Y2hPbihlbG1zLCAnZm9jdXNpbicsIFBBVVNFX0ZMQUdTLkZPQ1VTLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKEVsZW1lbnRzLnBsYXkpIHtcbiAgICAgIFNwbGlkZS5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE5lZWQgdG8gYmUgcmVtb3ZlZCBhIGZvY3VzIGZsYWcgYXQgZmlyc3QuXG4gICAgICAgIEF1dG9wbGF5LnBsYXkoUEFVU0VfRkxBR1MuRk9DVVMpO1xuICAgICAgICBBdXRvcGxheS5wbGF5KFBBVVNFX0ZMQUdTLk1BTlVBTCk7XG4gICAgICB9LCBFbGVtZW50cy5wbGF5KTtcbiAgICB9XG5cbiAgICBpZiAoRWxlbWVudHMucGF1c2UpIHtcbiAgICAgIHN3aXRjaE9uKFtFbGVtZW50cy5wYXVzZV0sICdjbGljaycsIFBBVVNFX0ZMQUdTLk1BTlVBTCwgZmFsc2UpO1xuICAgIH1cblxuICAgIFNwbGlkZS5vbignbW92ZSByZWZyZXNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgQXV0b3BsYXkucGxheSgpO1xuICAgIH0pIC8vIFJld2luZCB0aGUgdGltZXIuXG4gICAgLm9uKCdkZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgQXV0b3BsYXkucGF1c2UoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBQbGF5IG9yIHBhdXNlIG9uIHRoZSBnaXZlbiBldmVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudFtdfSBlbG1zICAtIEVsZW1lbnRzLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICBldmVudCAtIEFuIGV2ZW50IG5hbWUgb3IgbmFtZXMuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9ICAgIGZsYWcgIC0gQSBwYXVzZSBmbGFnIGRlZmluZWQgb24gdGhlIHRvcC5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgcGxheSAgLSBEZXRlcm1pbmUgd2hldGhlciB0byBwbGF5IG9yIHBhdXNlLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gc3dpdGNoT24oZWxtcywgZXZlbnQsIGZsYWcsIHBsYXkpIHtcbiAgICBlbG1zLmZvckVhY2goZnVuY3Rpb24gKGVsbSkge1xuICAgICAgU3BsaWRlLm9uKGV2ZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIEF1dG9wbGF5W3BsYXkgPyAncGxheScgOiAncGF1c2UnXShmbGFnKTtcbiAgICAgIH0sIGVsbSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gQXV0b3BsYXk7XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb21wb25lbnRzL2NvdmVyL2luZGV4LmpzXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgY2hhbmdlIGFuIGltZyBlbGVtZW50IHRvIGJhY2tncm91bmQgaW1hZ2Ugb2YgaXRzIHdyYXBwZXIuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGNoYW5nZSBhbiBpbWcgZWxlbWVudCB0byBiYWNrZ3JvdW5kIGltYWdlIG9mIGl0cyB3cmFwcGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NwbGlkZX0gU3BsaWRlICAgICAtIEEgU3BsaWRlIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gQ29tcG9uZW50cyAtIEFuIG9iamVjdCBjb250YWluaW5nIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBUaGUgY29tcG9uZW50IG9iamVjdC5cclxuICovXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY292ZXIgPSAoZnVuY3Rpb24gKFNwbGlkZSwgQ29tcG9uZW50cykge1xuICAvKipcclxuICAgKiBIb2xkIG9wdGlvbnMuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuICB2YXIgb3B0aW9ucyA9IFNwbGlkZS5vcHRpb25zO1xuICAvKipcclxuICAgKiBDb3ZlciBjb21wb25lbnQgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuICB2YXIgQ292ZXIgPSB7XG4gICAgLyoqXHJcbiAgICAgKiBSZXF1aXJlZCBvbmx5IHdoZW4gXCJjb3ZlclwiIG9wdGlvbiBpcyB0cnVlLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXG4gICAgcmVxdWlyZWQ6IG9wdGlvbnMuY292ZXIsXG5cbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cclxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIFNwbGlkZS5vbignbGF6eWxvYWQ6bG9hZGVkJywgZnVuY3Rpb24gKGltZykge1xuICAgICAgICBjb3ZlcihpbWcsIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgICAgU3BsaWRlLm9uKCdtb3VudGVkIHVwZGF0ZWQgcmVmcmVzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIERlc3Ryb3kuXHJcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgYXBwbHkodHJ1ZSk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBBcHBseSBcImNvdmVyXCIgdG8gYWxsIHNsaWRlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdW5jb3ZlciAtIElmIHRydWUsIFwiY292ZXJcIiB3aWxsIGJlIGNsZWFyLlxyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFwcGx5KHVuY292ZXIpIHtcbiAgICBDb21wb25lbnRzLkVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKFNsaWRlKSB7XG4gICAgICB2YXIgaW1nID0gY2hpbGQoU2xpZGUuc2xpZGUsICdJTUcnKSB8fCBjaGlsZChTbGlkZS5jb250YWluZXIsICdJTUcnKTtcblxuICAgICAgaWYgKGltZyAmJiBpbWcuc3JjKSB7XG4gICAgICAgIGNvdmVyKGltZywgdW5jb3Zlcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogU2V0IGJhY2tncm91bmQgaW1hZ2Ugb2YgdGhlIHBhcmVudCBlbGVtZW50LCB1c2luZyBzb3VyY2Ugb2YgdGhlIGdpdmVuIGltYWdlIGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGltZyAgICAgLSBBbiBpbWFnZSBlbGVtZW50LlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdW5jb3ZlciAtIFJlc2V0IFwiY292ZXJcIi5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGNvdmVyKGltZywgdW5jb3Zlcikge1xuICAgIGFwcGx5U3R5bGUoaW1nLnBhcmVudEVsZW1lbnQsIHtcbiAgICAgIGJhY2tncm91bmQ6IHVuY292ZXIgPyAnJyA6IFwiY2VudGVyL2NvdmVyIG5vLXJlcGVhdCB1cmwoXFxcIlwiICsgaW1nLnNyYyArIFwiXFxcIilcIlxuICAgIH0pO1xuICAgIGFwcGx5U3R5bGUoaW1nLCB7XG4gICAgICBkaXNwbGF5OiB1bmNvdmVyID8gJycgOiAnbm9uZSdcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBDb3Zlcjtcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbXBvbmVudHMvYXJyb3dzL3BhdGguanNcbi8qKlxyXG4gKiBFeHBvcnQgdmVjdG9yIHBhdGggZm9yIGFuIGFycm93LlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cbi8qKlxyXG4gKiBOYW1lc3BhY2UgZGVmaW5pdGlvbiBmb3IgU1ZHIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xudmFyIFhNTF9OQU1FX1NQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbi8qKlxyXG4gKiBUaGUgYXJyb3cgdmVjdG9yIHBhdGguXHJcbiAqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqL1xuXG52YXIgUEFUSCA9ICdtMTUuNSAwLjkzMi00LjMgNC4zOCAxNC41IDE0LjYtMTQuNSAxNC41IDQuMyA0LjQgMTQuNi0xNC42IDQuNC00LjMtNC40LTQuNC0xNC42LTE0LjZ6Jztcbi8qKlxyXG4gKiBTVkcgd2lkdGggYW5kIGhlaWdodC5cclxuICpcclxuICogQHR5cGUge251bWJlcn1cclxuICovXG5cbnZhciBTSVpFID0gNDA7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29tcG9uZW50cy9hcnJvd3MvaW5kZXguanNcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBhcHBlbmRpbmcgcHJldi9uZXh0IGFycm93cy5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG5cblxuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGFwcGVuZGluZyBwcmV2L25leHQgYXJyb3dzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NwbGlkZX0gU3BsaWRlICAgICAtIEEgU3BsaWRlIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gQ29tcG9uZW50cyAtIEFuIG9iamVjdCBjb250YWluaW5nIGNvbXBvbmVudHMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICAgICAgIC0gQSBjb21wb25lbnQgbmFtZSBhcyBhIGxvd2VyY2FzZSBzdHJpbmcuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBUaGUgY29tcG9uZW50IG9iamVjdC5cclxuICovXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgYXJyb3dzID0gKGZ1bmN0aW9uIChTcGxpZGUsIENvbXBvbmVudHMsIG5hbWUpIHtcbiAgLyoqXHJcbiAgICogUHJldmlvdXMgYXJyb3cgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtFbGVtZW50fHVuZGVmaW5lZH1cclxuICAgKi9cbiAgdmFyIHByZXY7XG4gIC8qKlxyXG4gICAqIE5leHQgYXJyb3cgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtFbGVtZW50fHVuZGVmaW5lZH1cclxuICAgKi9cblxuICB2YXIgbmV4dDtcbiAgLyoqXHJcbiAgICogU3RvcmUgdGhlIGNsYXNzIGxpc3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG4gIHZhciBjbGFzc2VzID0gU3BsaWRlLmNsYXNzZXM7XG4gIC8qKlxyXG4gICAqIEhvbGQgdGhlIHJvb3QgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtFbGVtZW50fVxyXG4gICAqL1xuXG4gIHZhciByb290ID0gU3BsaWRlLnJvb3Q7XG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgYXJyb3dzIGFyZSBjcmVhdGVkIHByb2dyYW1tYXRpY2FsbHkgb3Igbm90LlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG5cbiAgdmFyIGNyZWF0ZWQ7XG4gIC8qKlxyXG4gICAqIEhvbGQgdGhlIEVsZW1lbnRzIGNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cbiAgdmFyIEVsZW1lbnRzID0gQ29tcG9uZW50cy5FbGVtZW50cztcbiAgLyoqXHJcbiAgICogQXJyb3dzIGNvbXBvbmVudCBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG4gIHZhciBBcnJvd3MgPSB7XG4gICAgLyoqXHJcbiAgICAgKiBSZXF1aXJlZCB3aGVuIHRoZSBhcnJvd3Mgb3B0aW9uIGlzIHRydWUuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cbiAgICByZXF1aXJlZDogU3BsaWRlLm9wdGlvbnMuYXJyb3dzLFxuXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXHJcbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICAvLyBBdHRlbXB0IHRvIGdldCBhcnJvd3MgZnJvbSBIVE1MIHNvdXJjZS5cbiAgICAgIHByZXYgPSBFbGVtZW50cy5hcnJvd3MucHJldjtcbiAgICAgIG5leHQgPSBFbGVtZW50cy5hcnJvd3MubmV4dDsgLy8gSWYgYXJyb3dzIHdlcmUgbm90IGZvdW5kIGluIEhUTUwsIGxldCdzIGdlbmVyYXRlIHRoZW0uXG5cbiAgICAgIGlmICgoIXByZXYgfHwgIW5leHQpICYmIFNwbGlkZS5vcHRpb25zLmFycm93cykge1xuICAgICAgICBwcmV2ID0gY3JlYXRlQXJyb3codHJ1ZSk7XG4gICAgICAgIG5leHQgPSBjcmVhdGVBcnJvdyhmYWxzZSk7XG4gICAgICAgIGNyZWF0ZWQgPSB0cnVlO1xuICAgICAgICBhcHBlbmRBcnJvd3MoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByZXYgJiYgbmV4dCkge1xuICAgICAgICBiaW5kKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXJyb3dzID0ge1xuICAgICAgICBwcmV2OiBwcmV2LFxuICAgICAgICBuZXh0OiBuZXh0XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIENhbGxlZCBhZnRlciBhbGwgY29tcG9uZW50cyBhcmUgbW91bnRlZC5cclxuICAgICAqL1xuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICBTcGxpZGUuZW1pdChuYW1lICsgXCI6bW91bnRlZFwiLCBwcmV2LCBuZXh0KTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95LlxyXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHJlbW92ZUF0dHJpYnV0ZShbcHJldiwgbmV4dF0sICdkaXNhYmxlZCcpO1xuXG4gICAgICBpZiAoY3JlYXRlZCkge1xuICAgICAgICBkb21fcmVtb3ZlKHByZXYucGFyZW50RWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBMaXN0ZW4gdG8gbmF0aXZlIGFuZCBjdXN0b20gZXZlbnRzLlxyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgU3BsaWRlLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIFNwbGlkZS5nbygnPCcpO1xuICAgIH0sIHByZXYpLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIFNwbGlkZS5nbygnPicpO1xuICAgIH0sIG5leHQpLm9uKCdtb3VudGVkIG1vdmUgdXBkYXRlZCByZWZyZXNoJywgdXBkYXRlRGlzYWJsZWQpO1xuICB9XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBhIGRpc2FibGVkIGF0dHJpYnV0ZS5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHVwZGF0ZURpc2FibGVkKCkge1xuICAgIHZhciBfQ29tcG9uZW50cyRDb250cm9sbGUgPSBDb21wb25lbnRzLkNvbnRyb2xsZXIsXG4gICAgICAgIHByZXZJbmRleCA9IF9Db21wb25lbnRzJENvbnRyb2xsZS5wcmV2SW5kZXgsXG4gICAgICAgIG5leHRJbmRleCA9IF9Db21wb25lbnRzJENvbnRyb2xsZS5uZXh0SW5kZXg7XG4gICAgdmFyIGlzRW5vdWdoID0gU3BsaWRlLmxlbmd0aCA+IFNwbGlkZS5vcHRpb25zLnBlclBhZ2UgfHwgU3BsaWRlLmlzKExPT1ApO1xuICAgIHByZXYuZGlzYWJsZWQgPSBwcmV2SW5kZXggPCAwIHx8ICFpc0Vub3VnaDtcbiAgICBuZXh0LmRpc2FibGVkID0gbmV4dEluZGV4IDwgMCB8fCAhaXNFbm91Z2g7XG4gICAgU3BsaWRlLmVtaXQobmFtZSArIFwiOnVwZGF0ZWRcIiwgcHJldiwgbmV4dCwgcHJldkluZGV4LCBuZXh0SW5kZXgpO1xuICB9XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIHdyYXBwZXIgZWxlbWVudCBhbmQgYXBwZW5kIGFycm93cy5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGFwcGVuZEFycm93cygpIHtcbiAgICB2YXIgd3JhcHBlciA9IGNyZWF0ZSgnZGl2Jywge1xuICAgICAgXCJjbGFzc1wiOiBjbGFzc2VzLmFycm93c1xuICAgIH0pO1xuICAgIGFwcGVuZCh3cmFwcGVyLCBwcmV2KTtcbiAgICBhcHBlbmQod3JhcHBlciwgbmV4dCk7XG4gICAgdmFyIHNsaWRlciA9IEVsZW1lbnRzLnNsaWRlcjtcbiAgICB2YXIgcGFyZW50ID0gU3BsaWRlLm9wdGlvbnMuYXJyb3dzID09PSAnc2xpZGVyJyAmJiBzbGlkZXIgPyBzbGlkZXIgOiByb290O1xuICAgIGJlZm9yZSh3cmFwcGVyLCBwYXJlbnQuZmlyc3RFbGVtZW50Q2hpbGQpO1xuICB9XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhbiBhcnJvdyBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBwcmV2IC0gRGV0ZXJtaW5lIHRvIGNyZWF0ZSBhIHByZXYgYXJyb3cgb3IgbmV4dCBhcnJvdy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9IC0gQSBjcmVhdGVkIGFycm93IGVsZW1lbnQuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJvdyhwcmV2KSB7XG4gICAgdmFyIGFycm93ID0gXCI8YnV0dG9uIGNsYXNzPVxcXCJcIiArIGNsYXNzZXMuYXJyb3cgKyBcIiBcIiArIChwcmV2ID8gY2xhc3Nlcy5wcmV2IDogY2xhc3Nlcy5uZXh0KSArIFwiXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiPlwiICsgKFwiPHN2ZyB4bWxucz1cXFwiXCIgKyBYTUxfTkFNRV9TUEFDRSArIFwiXFxcIlxcdHZpZXdCb3g9XFxcIjAgMCBcIiArIFNJWkUgKyBcIiBcIiArIFNJWkUgKyBcIlxcXCJcXHR3aWR0aD1cXFwiXCIgKyBTSVpFICsgXCJcXFwiXFx0aGVpZ2h0PVxcXCJcIiArIFNJWkUgKyBcIlxcXCI+XCIpICsgKFwiPHBhdGggZD1cXFwiXCIgKyAoU3BsaWRlLm9wdGlvbnMuYXJyb3dQYXRoIHx8IFBBVEgpICsgXCJcXFwiIC8+XCIpO1xuICAgIHJldHVybiBkb21pZnkoYXJyb3cpO1xuICB9XG5cbiAgcmV0dXJuIEFycm93cztcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbXBvbmVudHMvcGFnaW5hdGlvbi9pbmRleC5qc1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGhhbmRsaW5nIHBhZ2luYXRpb25cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG5cbi8qKlxyXG4gKiBUaGUgZXZlbnQgbmFtZSBmb3IgdXBkYXRpbmcgc29tZSBhdHRyaWJ1dGVzIG9mIHBhZ2luYXRpb24gbm9kZXMuXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xuXG52YXIgQVRUUklCVVRFU19VUERBVEVfRVZFTlQgPSAnbW92ZS5wYWdlJztcbi8qKlxyXG4gKiBUaGUgZXZlbnQgbmFtZSBmb3IgcmVjcmVhdGluZyBwYWdpbmF0aW9uLlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cblxudmFyIFVQREFURV9FVkVOVCA9ICd1cGRhdGVkLnBhZ2UgcmVmcmVzaC5wYWdlJztcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBoYW5kbGluZyBwYWdpbmF0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3BsaWRlfSBTcGxpZGUgICAgIC0gQSBTcGxpZGUgaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBDb21wb25lbnRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgY29tcG9uZW50cy5cclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgICAgICAgLSBBIGNvbXBvbmVudCBuYW1lIGFzIGEgbG93ZXJjYXNlIHN0cmluZy5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAtIFRoZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gKi9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBwYWdpbmF0aW9uID0gKGZ1bmN0aW9uIChTcGxpZGUsIENvbXBvbmVudHMsIG5hbWUpIHtcbiAgLyoqXHJcbiAgICogU3RvcmUgYWxsIGRhdGEgZm9yIHBhZ2luYXRpb24uXHJcbiAgICogLSBsaXN0OiBBIGxpc3QgZWxlbWVudC5cclxuICAgKiAtIGl0ZW1zOiBBbiBhcnJheSB0aGF0IGNvbnRhaW5zIG9iamVjdHMobGksIGJ1dHRvbiwgaW5kZXgsIHBhZ2UpLlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cbiAgdmFyIGRhdGEgPSB7fTtcbiAgLyoqXHJcbiAgICogSG9sZCB0aGUgRWxlbWVudHMgY29tcG9uZW50LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuICB2YXIgRWxlbWVudHMgPSBDb21wb25lbnRzLkVsZW1lbnRzO1xuICAvKipcclxuICAgKiBQYWdpbmF0aW9uIGNvbXBvbmVudCBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG4gIHZhciBQYWdpbmF0aW9uID0ge1xuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxyXG4gICAgICovXG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgdmFyIHBhZ2luYXRpb24gPSBTcGxpZGUub3B0aW9ucy5wYWdpbmF0aW9uO1xuXG4gICAgICBpZiAocGFnaW5hdGlvbikge1xuICAgICAgICBkYXRhID0gY3JlYXRlUGFnaW5hdGlvbigpO1xuICAgICAgICB2YXIgc2xpZGVyID0gRWxlbWVudHMuc2xpZGVyO1xuICAgICAgICB2YXIgcGFyZW50ID0gcGFnaW5hdGlvbiA9PT0gJ3NsaWRlcicgJiYgc2xpZGVyID8gc2xpZGVyIDogU3BsaWRlLnJvb3Q7XG4gICAgICAgIGFwcGVuZChwYXJlbnQsIGRhdGEubGlzdCk7XG4gICAgICAgIFNwbGlkZS5vbihBVFRSSUJVVEVTX1VQREFURV9FVkVOVCwgdXBkYXRlQXR0cmlidXRlcyk7XG4gICAgICB9XG5cbiAgICAgIFNwbGlkZS5vZmYoVVBEQVRFX0VWRU5UKS5vbihVUERBVEVfRVZFTlQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgUGFnaW5hdGlvbi5kZXN0cm95KCk7XG5cbiAgICAgICAgaWYgKFNwbGlkZS5vcHRpb25zLnBhZ2luYXRpb24pIHtcbiAgICAgICAgICBQYWdpbmF0aW9uLm1vdW50KCk7XG4gICAgICAgICAgUGFnaW5hdGlvbi5tb3VudGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIENhbGxlZCBhZnRlciBhbGwgY29tcG9uZW50cyBhcmUgbW91bnRlZC5cclxuICAgICAqL1xuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICBpZiAoU3BsaWRlLm9wdGlvbnMucGFnaW5hdGlvbikge1xuICAgICAgICB2YXIgaW5kZXggPSBTcGxpZGUuaW5kZXg7XG4gICAgICAgIFNwbGlkZS5lbWl0KG5hbWUgKyBcIjptb3VudGVkXCIsIGRhdGEsIHRoaXMuZ2V0SXRlbShpbmRleCkpO1xuICAgICAgICB1cGRhdGVBdHRyaWJ1dGVzKGluZGV4LCAtMSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveSB0aGUgcGFnaW5hdGlvbi5cclxuICAgICAqIEJlIGF3YXJlIHRoYXQgbm9kZS5yZW1vdmUoKSBpcyBub3Qgc3VwcG9ydGVkIGJ5IElFLlxyXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIGRvbV9yZW1vdmUoZGF0YS5saXN0KTtcblxuICAgICAgaWYgKGRhdGEuaXRlbXMpIHtcbiAgICAgICAgZGF0YS5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgU3BsaWRlLm9mZignY2xpY2snLCBpdGVtLmJ1dHRvbik7XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBEbyBub3QgcmVtb3ZlIFVQREFURV9FVkVOVCB0byByZWNyZWF0ZSBwYWdpbmF0aW9uIGlmIG5lZWRlZC5cblxuXG4gICAgICBTcGxpZGUub2ZmKEFUVFJJQlVURVNfVVBEQVRFX0VWRU5UKTtcbiAgICAgIGRhdGEgPSB7fTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYW4gaXRlbSBieSBpbmRleC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBBIHNsaWRlIGluZGV4LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9IC0gQW4gaXRlbSBvYmplY3Qgb24gc3VjY2VzcyBvciB1bmRlZmluZWQgb24gZmFpbHVyZS5cclxuICAgICAqL1xuICAgIGdldEl0ZW06IGZ1bmN0aW9uIGdldEl0ZW0oaW5kZXgpIHtcbiAgICAgIHJldHVybiBkYXRhLml0ZW1zW0NvbXBvbmVudHMuQ29udHJvbGxlci50b1BhZ2UoaW5kZXgpXTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gb2JqZWN0IGNvbnRhaW5pbmcgcGFnaW5hdGlvbiBkYXRhLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gLSBQYWdpbmF0aW9uIGRhdGEgaW5jbHVkaW5nIGxpc3QgYW5kIGl0ZW1zLlxyXG4gICAgICovXG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgfTtcbiAgLyoqXHJcbiAgICogVXBkYXRlIGF0dHJpYnV0ZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggICAgIC0gQWN0aXZlIGluZGV4LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwcmV2SW5kZXggLSBQcmV2IGluZGV4LlxyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZUF0dHJpYnV0ZXMoaW5kZXgsIHByZXZJbmRleCkge1xuICAgIHZhciBwcmV2ID0gUGFnaW5hdGlvbi5nZXRJdGVtKHByZXZJbmRleCk7XG4gICAgdmFyIGN1cnIgPSBQYWdpbmF0aW9uLmdldEl0ZW0oaW5kZXgpO1xuICAgIHZhciBhY3RpdmUgPSBTVEFUVVNfQ0xBU1NFUy5hY3RpdmU7XG5cbiAgICBpZiAocHJldikge1xuICAgICAgcmVtb3ZlQ2xhc3MocHJldi5idXR0b24sIGFjdGl2ZSk7XG4gICAgfVxuXG4gICAgaWYgKGN1cnIpIHtcbiAgICAgIGFkZENsYXNzKGN1cnIuYnV0dG9uLCBhY3RpdmUpO1xuICAgIH1cblxuICAgIFNwbGlkZS5lbWl0KG5hbWUgKyBcIjp1cGRhdGVkXCIsIGRhdGEsIHByZXYsIGN1cnIpO1xuICB9XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIHdyYXBwZXIgYW5kIGJ1dHRvbiBlbGVtZW50cy5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge09iamVjdH0gLSBBbiBvYmplY3QgY29udGFpbnMgYWxsIGRhdGEuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBjcmVhdGVQYWdpbmF0aW9uKCkge1xuICAgIHZhciBvcHRpb25zID0gU3BsaWRlLm9wdGlvbnM7XG4gICAgdmFyIGNsYXNzZXMgPSBTcGxpZGUuY2xhc3NlcztcbiAgICB2YXIgbGlzdCA9IGNyZWF0ZSgndWwnLCB7XG4gICAgICBcImNsYXNzXCI6IGNsYXNzZXMucGFnaW5hdGlvblxuICAgIH0pO1xuICAgIHZhciBpdGVtcyA9IEVsZW1lbnRzLmdldFNsaWRlcyhmYWxzZSkuZmlsdGVyKGZ1bmN0aW9uIChTbGlkZSkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuZm9jdXMgIT09IGZhbHNlIHx8IFNsaWRlLmluZGV4ICUgb3B0aW9ucy5wZXJQYWdlID09PSAwO1xuICAgIH0pLm1hcChmdW5jdGlvbiAoU2xpZGUsIHBhZ2UpIHtcbiAgICAgIHZhciBsaSA9IGNyZWF0ZSgnbGknLCB7fSk7XG4gICAgICB2YXIgYnV0dG9uID0gY3JlYXRlKCdidXR0b24nLCB7XG4gICAgICAgIFwiY2xhc3NcIjogY2xhc3Nlcy5wYWdlLFxuICAgICAgICB0eXBlOiAnYnV0dG9uJ1xuICAgICAgfSk7XG4gICAgICBhcHBlbmQobGksIGJ1dHRvbik7XG4gICAgICBhcHBlbmQobGlzdCwgbGkpO1xuICAgICAgU3BsaWRlLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgU3BsaWRlLmdvKFwiPlwiICsgcGFnZSk7XG4gICAgICB9LCBidXR0b24pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGk6IGxpLFxuICAgICAgICBidXR0b246IGJ1dHRvbixcbiAgICAgICAgcGFnZTogcGFnZSxcbiAgICAgICAgU2xpZGVzOiBFbGVtZW50cy5nZXRTbGlkZXNCeVBhZ2UocGFnZSlcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpc3Q6IGxpc3QsXG4gICAgICBpdGVtczogaXRlbXNcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIFBhZ2luYXRpb247XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb21wb25lbnRzL2xhenlsb2FkL2luZGV4LmpzXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgbG9hZGluZyBzbGlkZXIgaW1hZ2VzIGxhemlseS5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG5cblxuLyoqXHJcbiAqIFRoZSBuYW1lIGZvciBhIGRhdGEgYXR0cmlidXRlIG9mIHNyYy5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXG5cbnZhciBTUkNfREFUQV9OQU1FID0gJ2RhdGEtc3BsaWRlLWxhenknO1xuLyoqXHJcbiAqIFRoZSBuYW1lIGZvciBhIGRhdGEgYXR0cmlidXRlIG9mIHNyY3NldC5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXG5cbnZhciBTUkNTRVRfREFUQV9OQU1FID0gJ2RhdGEtc3BsaWRlLWxhenktc3Jjc2V0Jztcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBsb2FkaW5nIHNsaWRlciBpbWFnZXMgbGF6aWx5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NwbGlkZX0gU3BsaWRlICAgICAtIEEgU3BsaWRlIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gQ29tcG9uZW50cyAtIEFuIG9iamVjdCBjb250YWluaW5nIGNvbXBvbmVudHMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICAgICAgIC0gQSBjb21wb25lbnQgbmFtZSBhcyBhIGxvd2VyY2FzZSBzdHJpbmcuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBUaGUgY29tcG9uZW50IG9iamVjdC5cclxuICovXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgbGF6eWxvYWQgPSAoZnVuY3Rpb24gKFNwbGlkZSwgQ29tcG9uZW50cywgbmFtZSkge1xuICAvKipcclxuICAgKiBOZXh0IGluZGV4IGZvciBzZXF1ZW50aWFsIGxvYWRpbmcuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xuICB2YXIgbmV4dEluZGV4O1xuICAvKipcclxuICAgKiBTdG9yZSBvYmplY3RzIGNvbnRhaW5pbmcgYW4gaW1nIGVsZW1lbnQgYW5kIGEgU2xpZGUgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdFtdfVxyXG4gICAqL1xuXG4gIHZhciBpbWFnZXM7XG4gIC8qKlxyXG4gICAqIFN0b3JlIHRoZSBvcHRpb25zLlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuICB2YXIgb3B0aW9ucyA9IFNwbGlkZS5vcHRpb25zO1xuICAvKipcclxuICAgKiBXaGV0aGVyIHRvIGxvYWQgaW1hZ2VzIHNlcXVlbnRpYWxseSBvciBub3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cblxuICB2YXIgaXNTZXF1ZW50aWFsID0gb3B0aW9ucy5sYXp5TG9hZCA9PT0gJ3NlcXVlbnRpYWwnO1xuICAvKipcclxuICAgKiBMYXp5bG9hZCBjb21wb25lbnQgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuICB2YXIgTGF6eWxvYWQgPSB7XG4gICAgLyoqXHJcbiAgICAgKiBNb3VudCBvbmx5IHdoZW4gdGhlIGxhenlsb2FkIG9wdGlvbiBpcyBwcm92aWRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xuICAgIHJlcXVpcmVkOiBvcHRpb25zLmxhenlMb2FkLFxuXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXHJcbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICBTcGxpZGUub24oJ21vdW50ZWQgcmVmcmVzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5pdCgpO1xuICAgICAgICBDb21wb25lbnRzLkVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKFNsaWRlKSB7XG4gICAgICAgICAgZWFjaChTbGlkZS5zbGlkZS5xdWVyeVNlbGVjdG9yQWxsKFwiW1wiICsgU1JDX0RBVEFfTkFNRSArIFwiXSwgW1wiICsgU1JDU0VUX0RBVEFfTkFNRSArIFwiXVwiKSwgZnVuY3Rpb24gKGltZykge1xuICAgICAgICAgICAgaWYgKCFpbWcuc3JjICYmICFpbWcuc3Jjc2V0KSB7XG4gICAgICAgICAgICAgIGltYWdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbWc6IGltZyxcbiAgICAgICAgICAgICAgICBTbGlkZTogU2xpZGVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGFwcGx5U3R5bGUoaW1nLCB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaXNTZXF1ZW50aWFsKSB7XG4gICAgICAgICAgbG9hZE5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghaXNTZXF1ZW50aWFsKSB7XG4gICAgICAgIFNwbGlkZS5vbihcIm1vdW50ZWQgcmVmcmVzaCBtb3ZlZC5cIiArIG5hbWUsIGNoZWNrKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95LlxyXG4gICAgICovXG4gICAgZGVzdHJveTogaW5pdFxuICB9O1xuICAvKipcclxuICAgKiBJbml0aWFsaXplIHBhcmFtZXRlcnMuXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBpbWFnZXMgPSBbXTtcbiAgICBuZXh0SW5kZXggPSAwO1xuICB9XG4gIC8qKlxyXG4gICAqIENoZWNrIGhvdyBjbG9zZSBlYWNoIGltYWdlIGlzIGZyb20gdGhlIGFjdGl2ZSBzbGlkZSBhbmRcclxuICAgKiBkZXRlcm1pbmUgd2hldGhlciB0byBzdGFydCBsb2FkaW5nIG9yIG5vdCwgYWNjb3JkaW5nIHRvIHRoZSBkaXN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIEN1cnJlbnQgaW5kZXguXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBjaGVjayhpbmRleCkge1xuICAgIGluZGV4ID0gaXNOYU4oaW5kZXgpID8gU3BsaWRlLmluZGV4IDogaW5kZXg7XG4gICAgaW1hZ2VzID0gaW1hZ2VzLmZpbHRlcihmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgIGlmIChpbWFnZS5TbGlkZS5pc1dpdGhpbihpbmRleCwgb3B0aW9ucy5wZXJQYWdlICogKG9wdGlvbnMucHJlbG9hZFBhZ2VzICsgMSkpKSB7XG4gICAgICAgIGxvYWQoaW1hZ2UuaW1nLCBpbWFnZS5TbGlkZSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7IC8vIFVuYmluZCBpZiBhbGwgaW1hZ2VzIGFyZSBsb2FkZWQuXG5cbiAgICBpZiAoIWltYWdlc1swXSkge1xuICAgICAgU3BsaWRlLm9mZihcIm1vdmVkLlwiICsgbmFtZSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFN0YXJ0IGxvYWRpbmcgYW4gaW1hZ2UuXHJcbiAgICogQ3JlYXRpbmcgYSBjbG9uZSBvZiB0aGUgaW1hZ2UgZWxlbWVudCBzaW5jZSBzZXR0aW5nIHNyYyBhdHRyaWJ1dGUgZGlyZWN0bHkgdG8gaXRcclxuICAgKiBvZnRlbiBvY2N1cnMgJ2hpdGNoJywgYmxvY2tpbmcgc29tZSBvdGhlciBwcm9jZXNzZXMgb2YgYSBicm93c2VyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBpbWcgICAtIEFuIGltYWdlIGVsZW1lbnQuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9ICBTbGlkZSAtIEEgU2xpZGUgb2JqZWN0LlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gbG9hZChpbWcsIFNsaWRlKSB7XG4gICAgYWRkQ2xhc3MoU2xpZGUuc2xpZGUsIFNUQVRVU19DTEFTU0VTLmxvYWRpbmcpO1xuICAgIHZhciBzcGlubmVyID0gY3JlYXRlKCdzcGFuJywge1xuICAgICAgXCJjbGFzc1wiOiBTcGxpZGUuY2xhc3Nlcy5zcGlubmVyXG4gICAgfSk7XG4gICAgYXBwZW5kKGltZy5wYXJlbnRFbGVtZW50LCBzcGlubmVyKTtcblxuICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBsb2FkZWQoaW1nLCBzcGlubmVyLCBTbGlkZSwgZmFsc2UpO1xuICAgIH07XG5cbiAgICBpbWcub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGxvYWRlZChpbWcsIHNwaW5uZXIsIFNsaWRlLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgc2V0QXR0cmlidXRlKGltZywgJ3NyY3NldCcsIGdldEF0dHJpYnV0ZShpbWcsIFNSQ1NFVF9EQVRBX05BTUUpIHx8ICcnKTtcbiAgICBzZXRBdHRyaWJ1dGUoaW1nLCAnc3JjJywgZ2V0QXR0cmlidXRlKGltZywgU1JDX0RBVEFfTkFNRSkgfHwgJycpO1xuICB9XG4gIC8qKlxyXG4gICAqIFN0YXJ0IGxvYWRpbmcgYSBuZXh0IGltYWdlIGluIGltYWdlcyBhcnJheS5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGxvYWROZXh0KCkge1xuICAgIGlmIChuZXh0SW5kZXggPCBpbWFnZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgaW1hZ2UgPSBpbWFnZXNbbmV4dEluZGV4XTtcbiAgICAgIGxvYWQoaW1hZ2UuaW1nLCBpbWFnZS5TbGlkZSk7XG4gICAgfVxuXG4gICAgbmV4dEluZGV4Kys7XG4gIH1cbiAgLyoqXHJcbiAgICogQ2FsbGVkIGp1c3QgYWZ0ZXIgdGhlIGltYWdlIHdhcyBsb2FkZWQgb3IgbG9hZGluZyB3YXMgYWJvcnRlZCBieSBzb21lIGVycm9yLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBpbWcgICAgIC0gQW4gaW1hZ2UgZWxlbWVudC5cclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHNwaW5uZXIgLSBBIHNwaW5uZXIgZWxlbWVudC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gIFNsaWRlICAgLSBBIFNsaWRlIG9iamVjdC5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVycm9yICAgLSBUcnVlIGlmIHRoZSBpbWFnZSB3YXMgbG9hZGVkIHN1Y2Nlc3NmdWxseSBvciBmYWxzZSBvbiBlcnJvci5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGxvYWRlZChpbWcsIHNwaW5uZXIsIFNsaWRlLCBlcnJvcikge1xuICAgIHJlbW92ZUNsYXNzKFNsaWRlLnNsaWRlLCBTVEFUVVNfQ0xBU1NFUy5sb2FkaW5nKTtcblxuICAgIGlmICghZXJyb3IpIHtcbiAgICAgIGRvbV9yZW1vdmUoc3Bpbm5lcik7XG4gICAgICBhcHBseVN0eWxlKGltZywge1xuICAgICAgICBkaXNwbGF5OiAnJ1xuICAgICAgfSk7XG4gICAgICBTcGxpZGUuZW1pdChuYW1lICsgXCI6bG9hZGVkXCIsIGltZykuZW1pdCgncmVzaXplJyk7XG4gICAgfVxuXG4gICAgaWYgKGlzU2VxdWVudGlhbCkge1xuICAgICAgbG9hZE5leHQoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gTGF6eWxvYWQ7XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb25zdGFudHMvYTExeS5qc1xuLyoqXHJcbiAqIEV4cG9ydCBhcmlhIGF0dHJpYnV0ZSBuYW1lcy5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG4vKipcclxuICogQXR0cmlidXRlIG5hbWUgZm9yIGFyaWEtY3VycmVudC5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXG52YXIgQVJJQV9DVVJSRU5SVCA9ICdhcmlhLWN1cnJlbnQnO1xuLyoqXHJcbiAqIEF0dHJpYnV0ZSBuYW1lIGZvciBhcmlhLWNvbnRyb2wuXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xuXG52YXIgQVJJQV9DT05UUk9MUyA9ICdhcmlhLWNvbnRyb2xzJztcbi8qKlxyXG4gKiBBdHRyaWJ1dGUgbmFtZSBmb3IgYXJpYS1jb250cm9sLlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cblxudmFyIEFSSUFfTEFCRUwgPSAnYXJpYS1sYWJlbCc7XG4vKipcclxuICogQXR0cmlidXRlIG5hbWUgZm9yIGFyaWEtbGFiZWxsZWRieS5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXG5cbnZhciBBUklBX0xBQkVMTEVEQlkgPSAnYXJpYS1sYWJlbGxlZGJ5Jztcbi8qKlxyXG4gKiBBdHRyaWJ1dGUgbmFtZSBmb3IgYXJpYS1oaWRkZW4uXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xuXG52YXIgQVJJQV9ISURERU4gPSAnYXJpYS1oaWRkZW4nO1xuLyoqXHJcbiAqIEF0dHJpYnV0ZSBuYW1lIGZvciB0YWItaW5kZXguXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xuXG52YXIgVEFCX0lOREVYID0gJ3RhYmluZGV4JztcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb21wb25lbnRzL2tleWJvYXJkL2luZGV4LmpzXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgY29udHJvbGxpbmcgc2xpZGVzIHZpYSBrZXlib2FyZC5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG5cbi8qKlxyXG4gKiBNYXAgYSBrZXkgdG8gYSBzbGlkZSBjb250cm9sLlxyXG4gKlxyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKi9cblxudmFyIEtFWV9NQVAgPSB7XG4gIGx0cjoge1xuICAgIEFycm93TGVmdDogJzwnLFxuICAgIEFycm93UmlnaHQ6ICc+JyxcbiAgICAvLyBGb3IgSUUuXG4gICAgTGVmdDogJzwnLFxuICAgIFJpZ2h0OiAnPidcbiAgfSxcbiAgcnRsOiB7XG4gICAgQXJyb3dMZWZ0OiAnPicsXG4gICAgQXJyb3dSaWdodDogJzwnLFxuICAgIC8vIEZvciBJRS5cbiAgICBMZWZ0OiAnPicsXG4gICAgUmlnaHQ6ICc8J1xuICB9LFxuICB0dGI6IHtcbiAgICBBcnJvd1VwOiAnPCcsXG4gICAgQXJyb3dEb3duOiAnPicsXG4gICAgLy8gRm9yIElFLlxuICAgIFVwOiAnPCcsXG4gICAgRG93bjogJz4nXG4gIH1cbn07XG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgY29udHJvbGxpbmcgc2xpZGVzIHZpYSBrZXlib2FyZC5cclxuICpcclxuICogQHBhcmFtIHtTcGxpZGV9IFNwbGlkZSAtIEEgU3BsaWRlIGluc3RhbmNlLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gVGhlIGNvbXBvbmVudCBvYmplY3QuXHJcbiAqL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGtleWJvYXJkID0gKGZ1bmN0aW9uIChTcGxpZGUpIHtcbiAgLyoqXHJcbiAgICogSG9sZCB0aGUgdGFyZ2V0IGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7RWxlbWVudHxEb2N1bWVudHx1bmRlZmluZWR9XHJcbiAgICovXG4gIHZhciB0YXJnZXQ7XG4gIHJldHVybiB7XG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXHJcbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICBTcGxpZGUub24oJ21vdW50ZWQgdXBkYXRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBTcGxpZGUub3B0aW9ucztcbiAgICAgICAgdmFyIHJvb3QgPSBTcGxpZGUucm9vdDtcbiAgICAgICAgdmFyIG1hcCA9IEtFWV9NQVBbb3B0aW9ucy5kaXJlY3Rpb25dO1xuICAgICAgICB2YXIga2V5Ym9hcmQgPSBvcHRpb25zLmtleWJvYXJkO1xuXG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICBTcGxpZGUub2ZmKCdrZXlkb3duJywgdGFyZ2V0KTtcbiAgICAgICAgICByZW1vdmVBdHRyaWJ1dGUocm9vdCwgVEFCX0lOREVYKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXlib2FyZCkge1xuICAgICAgICAgIGlmIChrZXlib2FyZCA9PT0gJ2ZvY3VzZWQnKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSByb290O1xuICAgICAgICAgICAgc2V0QXR0cmlidXRlKHJvb3QsIFRBQl9JTkRFWCwgMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldCA9IGRvY3VtZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIFNwbGlkZS5vbigna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAobWFwW2Uua2V5XSkge1xuICAgICAgICAgICAgICBTcGxpZGUuZ28obWFwW2Uua2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29tcG9uZW50cy9hMTF5L2luZGV4LmpzXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgZW5oYW5jaW5nIGFjY2Vzc2liaWxpdHkuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuXG5cbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBlbmhhbmNpbmcgYWNjZXNzaWJpbGl0eS5cclxuICpcclxuICogQHBhcmFtIHtTcGxpZGV9IFNwbGlkZSAgICAgLSBBIFNwbGlkZSBpbnN0YW5jZS5cclxuICogQHBhcmFtIHtPYmplY3R9IENvbXBvbmVudHMgLSBBbiBvYmplY3QgY29udGFpbmluZyBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gVGhlIGNvbXBvbmVudCBvYmplY3QuXHJcbiAqL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGExMXkgPSAoZnVuY3Rpb24gKFNwbGlkZSwgQ29tcG9uZW50cykge1xuICAvKipcclxuICAgKiBIb2xkIGEgaTE4biBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuICB2YXIgaTE4biA9IFNwbGlkZS5pMThuO1xuICAvKipcclxuICAgKiBIb2xkIHRoZSBFbGVtZW50cyBjb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG4gIHZhciBFbGVtZW50cyA9IENvbXBvbmVudHMuRWxlbWVudHM7XG4gIC8qKlxyXG4gICAqIEFsbCBhdHRyaWJ1dGVzIHJlbGF0ZWQgd2l0aCBBMTF5LlxyXG4gICAqXHJcbiAgICogQHR5cGUge3N0cmluZ1tdfVxyXG4gICAqL1xuXG4gIHZhciBhbGxBdHRyaWJ1dGVzID0gW0FSSUFfSElEREVOLCBUQUJfSU5ERVgsIEFSSUFfQ09OVFJPTFMsIEFSSUFfTEFCRUwsIEFSSUFfQ1VSUkVOUlQsICdyb2xlJ107XG4gIC8qKlxyXG4gICAqIEExMXkgY29tcG9uZW50IG9iamVjdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cbiAgdmFyIEExMXkgPSB7XG4gICAgLyoqXHJcbiAgICAgKiBSZXF1aXJlZCBvbmx5IHdoZW4gdGhlIGFjY2Vzc2liaWxpdHkgb3B0aW9uIGlzIHRydWUuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cbiAgICByZXF1aXJlZDogU3BsaWRlLm9wdGlvbnMuYWNjZXNzaWJpbGl0eSxcblxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxyXG4gICAgICovXG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgU3BsaWRlLm9uKCd2aXNpYmxlJywgZnVuY3Rpb24gKFNsaWRlKSB7XG4gICAgICAgIHVwZGF0ZVNsaWRlKFNsaWRlLnNsaWRlLCB0cnVlKTtcbiAgICAgIH0pLm9uKCdoaWRkZW4nLCBmdW5jdGlvbiAoU2xpZGUpIHtcbiAgICAgICAgdXBkYXRlU2xpZGUoU2xpZGUuc2xpZGUsIGZhbHNlKTtcbiAgICAgIH0pLm9uKCdhcnJvd3M6bW91bnRlZCcsIGluaXRBcnJvd3MpLm9uKCdhcnJvd3M6dXBkYXRlZCcsIHVwZGF0ZUFycm93cykub24oJ3BhZ2luYXRpb246bW91bnRlZCcsIGluaXRQYWdpbmF0aW9uKS5vbigncGFnaW5hdGlvbjp1cGRhdGVkJywgdXBkYXRlUGFnaW5hdGlvbikub24oJ3JlZnJlc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZUF0dHJpYnV0ZShDb21wb25lbnRzLkNsb25lcy5jbG9uZXMsIGFsbEF0dHJpYnV0ZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChTcGxpZGUub3B0aW9ucy5pc05hdmlnYXRpb24pIHtcbiAgICAgICAgU3BsaWRlLm9uKCduYXZpZ2F0aW9uOm1vdW50ZWQgbmF2aWdhdGlvbjp1cGRhdGVkJywgaW5pdE5hdmlnYXRpb24pLm9uKCdhY3RpdmUnLCBmdW5jdGlvbiAoU2xpZGUpIHtcbiAgICAgICAgICB1cGRhdGVOYXZpZ2F0aW9uKFNsaWRlLCB0cnVlKTtcbiAgICAgICAgfSkub24oJ2luYWN0aXZlJywgZnVuY3Rpb24gKFNsaWRlKSB7XG4gICAgICAgICAgdXBkYXRlTmF2aWdhdGlvbihTbGlkZSwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaW5pdEF1dG9wbGF5KCk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveS5cclxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB2YXIgQXJyb3dzID0gQ29tcG9uZW50cy5BcnJvd3M7XG4gICAgICB2YXIgYXJyb3dzID0gQXJyb3dzID8gQXJyb3dzLmFycm93cyA6IHt9O1xuICAgICAgcmVtb3ZlQXR0cmlidXRlKEVsZW1lbnRzLnNsaWRlcy5jb25jYXQoW2Fycm93cy5wcmV2LCBhcnJvd3MubmV4dCwgRWxlbWVudHMucGxheSwgRWxlbWVudHMucGF1c2VdKSwgYWxsQXR0cmlidXRlcyk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBVcGRhdGUgc2xpZGUgYXR0cmlidXRlcyB3aGVuIGl0IGdldHMgdmlzaWJsZSBvciBoaWRkZW4uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHNsaWRlICAgLSBBIHNsaWRlIGVsZW1lbnQuXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSB2aXNpYmxlIC0gVHJ1ZSB3aGVuIHRoZSBzbGlkZSBnZXRzIHZpc2libGUsIG9yIGZhbHNlIHdoZW4gaGlkZGVuLlxyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNsaWRlKHNsaWRlLCB2aXNpYmxlKSB7XG4gICAgc2V0QXR0cmlidXRlKHNsaWRlLCBBUklBX0hJRERFTiwgIXZpc2libGUpO1xuXG4gICAgaWYgKFNwbGlkZS5vcHRpb25zLnNsaWRlRm9jdXMpIHtcbiAgICAgIHNldEF0dHJpYnV0ZShzbGlkZSwgVEFCX0lOREVYLCB2aXNpYmxlID8gMCA6IC0xKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSBhcnJvd3MgaWYgdGhleSBhcmUgYXZhaWxhYmxlLlxyXG4gICAqIEFwcGVuZCBzY3JlZW4gcmVhZGVyIGVsZW1lbnRzIGFuZCBhZGQgYXJpYS1jb250cm9scyBhdHRyaWJ1dGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHByZXYgLSBQcmV2aW91cyBhcnJvdyBlbGVtZW50LlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbmV4dCAtIE5leHQgYXJyb3cgZWxlbWVudC5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGluaXRBcnJvd3MocHJldiwgbmV4dCkge1xuICAgIHZhciBjb250cm9scyA9IEVsZW1lbnRzLnRyYWNrLmlkO1xuICAgIHNldEF0dHJpYnV0ZShwcmV2LCBBUklBX0NPTlRST0xTLCBjb250cm9scyk7XG4gICAgc2V0QXR0cmlidXRlKG5leHQsIEFSSUFfQ09OVFJPTFMsIGNvbnRyb2xzKTtcbiAgfVxuICAvKipcclxuICAgKiBVcGRhdGUgYXJyb3cgYXR0cmlidXRlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcHJldiAgICAgIC0gUHJldmlvdXMgYXJyb3cgZWxlbWVudC5cclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5leHQgICAgICAtIE5leHQgYXJyb3cgZWxlbWVudC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gIHByZXZJbmRleCAtIFByZXZpb3VzIHNsaWRlIGluZGV4IG9yIC0xIHdoZW4gdGhlcmUgaXMgbm8gcHJlY2VkZSBzbGlkZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gIG5leHRJbmRleCAtIE5leHQgc2xpZGUgaW5kZXggb3IgLTEgd2hlbiB0aGVyZSBpcyBubyBuZXh0IHNsaWRlLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gdXBkYXRlQXJyb3dzKHByZXYsIG5leHQsIHByZXZJbmRleCwgbmV4dEluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gU3BsaWRlLmluZGV4O1xuICAgIHZhciBwcmV2TGFiZWwgPSBwcmV2SW5kZXggPiAtMSAmJiBpbmRleCA8IHByZXZJbmRleCA/IGkxOG4ubGFzdCA6IGkxOG4ucHJldjtcbiAgICB2YXIgbmV4dExhYmVsID0gbmV4dEluZGV4ID4gLTEgJiYgaW5kZXggPiBuZXh0SW5kZXggPyBpMThuLmZpcnN0IDogaTE4bi5uZXh0O1xuICAgIHNldEF0dHJpYnV0ZShwcmV2LCBBUklBX0xBQkVMLCBwcmV2TGFiZWwpO1xuICAgIHNldEF0dHJpYnV0ZShuZXh0LCBBUklBX0xBQkVMLCBuZXh0TGFiZWwpO1xuICB9XG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgcGFnaW5hdGlvbiBpZiBpdCdzIGF2YWlsYWJsZS5cclxuICAgKiBBcHBlbmQgYSBzY3JlZW4gcmVhZGVyIGVsZW1lbnQgYW5kIGFkZCBhcmlhLWNvbnRyb2xzL2xhYmVsIGF0dHJpYnV0ZSB0byBlYWNoIGl0ZW0uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgICAtIERhdGEgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIGl0ZW1zLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY3RpdmVJdGVtIC0gQW4gaW5pdGlhbCBhY3RpdmUgaXRlbS5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGluaXRQYWdpbmF0aW9uKGRhdGEsIGFjdGl2ZUl0ZW0pIHtcbiAgICBpZiAoYWN0aXZlSXRlbSkge1xuICAgICAgc2V0QXR0cmlidXRlKGFjdGl2ZUl0ZW0uYnV0dG9uLCBBUklBX0NVUlJFTlJULCB0cnVlKTtcbiAgICB9XG5cbiAgICBkYXRhLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBvcHRpb25zID0gU3BsaWRlLm9wdGlvbnM7XG4gICAgICB2YXIgdGV4dCA9IG9wdGlvbnMuZm9jdXMgPT09IGZhbHNlICYmIG9wdGlvbnMucGVyUGFnZSA+IDEgPyBpMThuLnBhZ2VYIDogaTE4bi5zbGlkZVg7XG4gICAgICB2YXIgbGFiZWwgPSBzcHJpbnRmKHRleHQsIGl0ZW0ucGFnZSArIDEpO1xuICAgICAgdmFyIGJ1dHRvbiA9IGl0ZW0uYnV0dG9uO1xuICAgICAgdmFyIGNvbnRyb2xzID0gaXRlbS5TbGlkZXMubWFwKGZ1bmN0aW9uIChTbGlkZSkge1xuICAgICAgICByZXR1cm4gU2xpZGUuc2xpZGUuaWQ7XG4gICAgICB9KTtcbiAgICAgIHNldEF0dHJpYnV0ZShidXR0b24sIEFSSUFfQ09OVFJPTFMsIGNvbnRyb2xzLmpvaW4oJyAnKSk7XG4gICAgICBzZXRBdHRyaWJ1dGUoYnV0dG9uLCBBUklBX0xBQkVMLCBsYWJlbCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogVXBkYXRlIHBhZ2luYXRpb24gYXR0cmlidXRlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAgZGF0YSAtIERhdGEgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIGl0ZW1zLlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcHJldiAtIEEgcHJldmlvdXMgYWN0aXZlIGVsZW1lbnQuXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBjdXJyIC0gQSBjdXJyZW50IGFjdGl2ZSBlbGVtZW50LlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gdXBkYXRlUGFnaW5hdGlvbihkYXRhLCBwcmV2LCBjdXJyKSB7XG4gICAgaWYgKHByZXYpIHtcbiAgICAgIHJlbW92ZUF0dHJpYnV0ZShwcmV2LmJ1dHRvbiwgQVJJQV9DVVJSRU5SVCk7XG4gICAgfVxuXG4gICAgaWYgKGN1cnIpIHtcbiAgICAgIHNldEF0dHJpYnV0ZShjdXJyLmJ1dHRvbiwgQVJJQV9DVVJSRU5SVCwgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgYXV0b3BsYXkgYnV0dG9ucy5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGluaXRBdXRvcGxheSgpIHtcbiAgICBbJ3BsYXknLCAncGF1c2UnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgZWxtID0gRWxlbWVudHNbbmFtZV07XG5cbiAgICAgIGlmIChlbG0pIHtcbiAgICAgICAgaWYgKCFpc0J1dHRvbihlbG0pKSB7XG4gICAgICAgICAgc2V0QXR0cmlidXRlKGVsbSwgJ3JvbGUnLCAnYnV0dG9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRBdHRyaWJ1dGUoZWxtLCBBUklBX0NPTlRST0xTLCBFbGVtZW50cy50cmFjay5pZCk7XG4gICAgICAgIHNldEF0dHJpYnV0ZShlbG0sIEFSSUFfTEFCRUwsIGkxOG5bbmFtZV0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgbmF2aWdhdGlvbiBzbGlkZXIuXHJcbiAgICogQWRkIGJ1dHRvbiByb2xlLCBhcmlhLWxhYmVsLCBhcmlhLWNvbnRyb2xzIHRvIHNsaWRlIGVsZW1lbnRzIGFuZCBhcHBlbmQgc2NyZWVuIHJlYWRlciB0ZXh0IHRvIHRoZW0uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1NwbGlkZX0gbWFpbiAtIEEgbWFpbiBTcGxpZGUgaW5zdGFuY2UuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBpbml0TmF2aWdhdGlvbihtYWluKSB7XG4gICAgRWxlbWVudHMuZWFjaChmdW5jdGlvbiAoU2xpZGUpIHtcbiAgICAgIHZhciBzbGlkZSA9IFNsaWRlLnNsaWRlO1xuICAgICAgdmFyIHJlYWxJbmRleCA9IFNsaWRlLnJlYWxJbmRleDtcblxuICAgICAgaWYgKCFpc0J1dHRvbihzbGlkZSkpIHtcbiAgICAgICAgc2V0QXR0cmlidXRlKHNsaWRlLCAncm9sZScsICdidXR0b24nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNsaWRlSW5kZXggPSByZWFsSW5kZXggPiAtMSA/IHJlYWxJbmRleCA6IFNsaWRlLmluZGV4O1xuICAgICAgdmFyIGxhYmVsID0gc3ByaW50ZihpMThuLnNsaWRlWCwgc2xpZGVJbmRleCArIDEpO1xuICAgICAgdmFyIG1haW5TbGlkZSA9IG1haW4uQ29tcG9uZW50cy5FbGVtZW50cy5nZXRTbGlkZShzbGlkZUluZGV4KTtcbiAgICAgIHNldEF0dHJpYnV0ZShzbGlkZSwgQVJJQV9MQUJFTCwgbGFiZWwpO1xuXG4gICAgICBpZiAobWFpblNsaWRlKSB7XG4gICAgICAgIHNldEF0dHJpYnV0ZShzbGlkZSwgQVJJQV9DT05UUk9MUywgbWFpblNsaWRlLnNsaWRlLmlkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBVcGRhdGUgbmF2aWdhdGlvbiBhdHRyaWJ1dGVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9ICBTbGlkZSAgLSBBIHRhcmdldCBTbGlkZSBvYmplY3QuXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBhY3RpdmUgLSBUcnVlIGlmIHRoZSBzbGlkZSBpcyBhY3RpdmUgb3IgZmFsc2UgaWYgaW5hY3RpdmUuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiB1cGRhdGVOYXZpZ2F0aW9uKF9yZWYsIGFjdGl2ZSkge1xuICAgIHZhciBzbGlkZSA9IF9yZWYuc2xpZGU7XG5cbiAgICBpZiAoYWN0aXZlKSB7XG4gICAgICBzZXRBdHRyaWJ1dGUoc2xpZGUsIEFSSUFfQ1VSUkVOUlQsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVBdHRyaWJ1dGUoc2xpZGUsIEFSSUFfQ1VSUkVOUlQpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBidXR0b24gb3Igbm90LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbG0gLSBBbiBlbGVtZW50IHRvIGJlIGNoZWNrZWQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRydWUgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgYnV0dG9uLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaXNCdXR0b24oZWxtKSB7XG4gICAgcmV0dXJuIGVsbS50YWdOYW1lID09PSAnQlVUVE9OJztcbiAgfVxuXG4gIHJldHVybiBBMTF5O1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29tcG9uZW50cy9zeW5jL2luZGV4LmpzXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3Igc3luY2hyb25pemluZyBhIHNsaWRlciB3aXRoIGFub3RoZXIuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuXG4vKipcclxuICogVGhlIGV2ZW50IG5hbWUgZm9yIHN5bmMuXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xuXG52YXIgU1lOQ19FVkVOVCA9ICdtb3ZlLnN5bmMnO1xuLyoqXHJcbiAqIFRoZSBldmVudCBuYW1lcyBmb3IgY2xpY2sgbmF2aWdhdGlvbi5cclxuICogQHR5cGUge3N0cmluZ31cclxuICovXG5cbnZhciBDTElDS19FVkVOVFMgPSAnbW91c2V1cCB0b3VjaGVuZCc7XG4vKipcclxuICogVGhlIGtleXMgZm9yIHRyaWdnZXJpbmcgdGhlIG5hdmlnYXRpb24gYnV0dG9uLlxyXG4gKlxyXG4gKiBAdHlwZSB7U3RyaW5nW119XHJcbiAqL1xuXG52YXIgVFJJR0dFUl9LRVlTID0gWycgJywgJ0VudGVyJywgJ1NwYWNlYmFyJ107XG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3Igc3luY2hyb25pemluZyBhIHNsaWRlciB3aXRoIGFub3RoZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3BsaWRlfSBTcGxpZGUgLSBBIFNwbGlkZSBpbnN0YW5jZS5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAtIFRoZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gKi9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBzeW5jID0gKGZ1bmN0aW9uIChTcGxpZGUpIHtcbiAgLyoqXHJcbiAgICogS2VlcCB0aGUgc2libGluZyBTcGxpZGUgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7U3BsaWRlfVxyXG4gICAqL1xuICB2YXIgc2libGluZyA9IFNwbGlkZS5zaWJsaW5nO1xuICAvKipcclxuICAgKiBXaGV0aGVyIHRoZSBzaWJsaW5nIHNsaWRlciBpcyBuYXZpZ2F0aW9uIG9yIG5vdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtTcGxpZGV8Ym9vbGVhbn1cclxuICAgKi9cblxuICB2YXIgaXNOYXZpZ2F0aW9uID0gc2libGluZyAmJiBzaWJsaW5nLm9wdGlvbnMuaXNOYXZpZ2F0aW9uO1xuICAvKipcclxuICAgKiBMYXlvdXQgY29tcG9uZW50IG9iamVjdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cbiAgdmFyIFN5bmMgPSB7XG4gICAgLyoqXHJcbiAgICAgKiBSZXF1aXJlZCBvbmx5IHdoZW4gdGhlIHN1YiBzbGlkZXIgaXMgYXZhaWxhYmxlLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXG4gICAgcmVxdWlyZWQ6ICEhc2libGluZyxcblxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxyXG4gICAgICovXG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgc3luY01haW4oKTtcbiAgICAgIHN5bmNTaWJsaW5nKCk7XG5cbiAgICAgIGlmIChpc05hdmlnYXRpb24pIHtcbiAgICAgICAgYmluZCgpO1xuICAgICAgICBTcGxpZGUub24oJ3JlZnJlc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBiaW5kKCk7XG4gICAgICAgICAgICBzaWJsaW5nLmVtaXQoJ25hdmlnYXRpb246dXBkYXRlZCcsIFNwbGlkZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIENhbGxlZCBhZnRlciBhbGwgY29tcG9uZW50cyBhcmUgbW91bnRlZC5cclxuICAgICAqL1xuICAgIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgICBpZiAoaXNOYXZpZ2F0aW9uKSB7XG4gICAgICAgIHNpYmxpbmcuZW1pdCgnbmF2aWdhdGlvbjptb3VudGVkJywgU3BsaWRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIExpc3RlbiB0aGUgcHJpbWFyeSBzbGlkZXIgZXZlbnQgdG8gbW92ZSBzZWNvbmRhcnkgb25lLlxyXG4gICAqIE11c3QgdW5iaW5kIGEgaGFuZGxlciBhdCBmaXJzdCB0byBhdm9pZCBpbmZpbml0ZSBsb29wLlxyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHN5bmNNYWluKCkge1xuICAgIFNwbGlkZS5vbihTWU5DX0VWRU5ULCBmdW5jdGlvbiAobmV3SW5kZXgsIHByZXZJbmRleCwgZGVzdEluZGV4KSB7XG4gICAgICBzaWJsaW5nLm9mZihTWU5DX0VWRU5UKS5nbyhzaWJsaW5nLmlzKExPT1ApID8gZGVzdEluZGV4IDogbmV3SW5kZXgsIGZhbHNlKTtcbiAgICAgIHN5bmNTaWJsaW5nKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogTGlzdGVuIHRoZSBzZWNvbmRhcnkgc2xpZGVyIGV2ZW50IHRvIG1vdmUgcHJpbWFyeSBvbmUuXHJcbiAgICogTXVzdCB1bmJpbmQgYSBoYW5kbGVyIGF0IGZpcnN0IHRvIGF2b2lkIGluZmluaXRlIGxvb3AuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBzeW5jU2libGluZygpIHtcbiAgICBzaWJsaW5nLm9uKFNZTkNfRVZFTlQsIGZ1bmN0aW9uIChuZXdJbmRleCwgcHJldkluZGV4LCBkZXN0SW5kZXgpIHtcbiAgICAgIFNwbGlkZS5vZmYoU1lOQ19FVkVOVCkuZ28oU3BsaWRlLmlzKExPT1ApID8gZGVzdEluZGV4IDogbmV3SW5kZXgsIGZhbHNlKTtcbiAgICAgIHN5bmNNYWluKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogTGlzdGVuIHNvbWUgZXZlbnRzIG9uIGVhY2ggc2xpZGUuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHNpYmxpbmcuQ29tcG9uZW50cy5FbGVtZW50cy5lYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgc2xpZGUgPSBfcmVmLnNsaWRlLFxuICAgICAgICAgIGluZGV4ID0gX3JlZi5pbmRleDtcblxuICAgICAgLypcclxuICAgICAgICogTGlzdGVuIG1vdXNldXAgYW5kIHRvdWNoZW5kIGV2ZW50cyB0byBoYW5kbGUgY2xpY2suXHJcbiAgICAgICAqL1xuICAgICAgU3BsaWRlLm9mZihDTElDS19FVkVOVFMsIHNsaWRlKS5vbihDTElDS19FVkVOVFMsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIC8vIElnbm9yZSBhIG1pZGRsZSBvciByaWdodCBjbGljay5cbiAgICAgICAgaWYgKCFlLmJ1dHRvbiB8fCBlLmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICAgIG1vdmVTaWJsaW5nKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSwgc2xpZGUpO1xuICAgICAgLypcclxuICAgICAgICogU3Vic2NyaWJlIGtleXVwIHRvIGhhbmRsZSBFbnRlciBhbmQgU3BhY2Uga2V5LlxyXG4gICAgICAgKiBOb3RlIHRoYXQgQXJyYXkuaW5jbHVkZXMgaXMgbm90IHN1cHBvcnRlZCBieSBJRS5cclxuICAgICAgICovXG5cbiAgICAgIFNwbGlkZS5vZmYoJ2tleXVwJywgc2xpZGUpLm9uKCdrZXl1cCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChUUklHR0VSX0tFWVMuaW5kZXhPZihlLmtleSkgPiAtMSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBtb3ZlU2libGluZyhpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHNsaWRlLCB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBNb3ZlIHRoZSBzaWJsaW5nIHRvIHRoZSBnaXZlbiBpbmRleC5cclxuICAgKiBOZWVkIHRvIGNoZWNrIFwiSURMRVwiIHN0YXR1cyBiZWNhdXNlIHNsaWRlcyBjYW4gYmUgbW92aW5nIGJ5IERyYWcgY29tcG9uZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGFyZ2V0IGluZGV4LlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gbW92ZVNpYmxpbmcoaW5kZXgpIHtcbiAgICBpZiAoU3BsaWRlLlN0YXRlLmlzKElETEUpKSB7XG4gICAgICBzaWJsaW5nLmdvKGluZGV4KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gU3luYztcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbXBvbmVudHMvYnJlYWtwb2ludHMvaW5kZXguanNcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciB1cGRhdGluZyBvcHRpb25zIGFjY29yZGluZyB0byBhIGN1cnJlbnQgd2luZG93IHdpZHRoLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cblxuLyoqXHJcbiAqIEludGVydmFsIHRpbWUgZm9yIHRocm90dGxlLlxyXG4gKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKi9cblxudmFyIFRIUk9UVExFID0gNTA7XG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgdXBkYXRpbmcgb3B0aW9ucyBhY2NvcmRpbmcgdG8gYSBjdXJyZW50IHdpbmRvdyB3aWR0aC5cclxuICpcclxuICogQHBhcmFtIHtTcGxpZGV9IFNwbGlkZSAtIEEgU3BsaWRlIGluc3RhbmNlLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gVGhlIGNvbXBvbmVudCBvYmplY3QuXHJcbiAqL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGJyZWFrcG9pbnRzID0gKGZ1bmN0aW9uIChTcGxpZGUpIHtcbiAgLyoqXHJcbiAgICogU3RvcmUgYnJlYWtwb2ludHMuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fGJvb2xlYW59XHJcbiAgICovXG4gIHZhciBicmVha3BvaW50cyA9IFNwbGlkZS5vcHRpb25zLmJyZWFrcG9pbnRzO1xuICAvKipcclxuICAgKiBUaGUgY2hlY2sgZnVuY3Rpb24gd2hvc2UgZnJlcXVlbmN5IG9mIGNhbGwgaXMgcmVkdWNlZC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgKi9cblxuICB2YXIgdGhyb3R0bGVkQ2hlY2sgPSB0aHJvdHRsZShjaGVjaywgVEhST1RUTEUpO1xuICAvKipcclxuICAgKiBLZWVwIGluaXRpYWwgb3B0aW9ucy5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cbiAgdmFyIGluaXRpYWxPcHRpb25zO1xuICAvKipcclxuICAgKiBBbiBhcnJheSBjb250YWluaW5nIG9iamVjdHMgb2YgcG9pbnQgYW5kIE1lZGlhUXVlcnlMaXN0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdFtdfVxyXG4gICAqL1xuXG4gIHZhciBtYXAgPSBbXTtcbiAgLyoqXHJcbiAgICogSG9sZCB0aGUgcHJldmlvdXMgYnJlYWtwb2ludC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ8dW5kZWZpbmVkfVxyXG4gICAqL1xuXG4gIHZhciBwcmV2UG9pbnQ7XG4gIC8qKlxyXG4gICAqIEJyZWFrcG9pbnRzIGNvbXBvbmVudCBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG4gIHZhciBCcmVha3BvaW50cyA9IHtcbiAgICAvKipcclxuICAgICAqIFJlcXVpcmVkIG9ubHkgd2hlbiB0aGUgYnJlYWtwb2ludHMgZGVmaW5pdGlvbiBpcyBwcm92aWRlZCBhbmQgYnJvd3NlciBzdXBwb3J0cyBtYXRjaE1lZGlhLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXG4gICAgcmVxdWlyZWQ6IGJyZWFrcG9pbnRzICYmIG1hdGNoTWVkaWEsXG5cbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cclxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIG1hcCA9IE9iamVjdC5rZXlzKGJyZWFrcG9pbnRzKS5zb3J0KGZ1bmN0aW9uIChuLCBtKSB7XG4gICAgICAgIHJldHVybiArbiAtICttO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgICBtcWw6IG1hdGNoTWVkaWEoXCIobWF4LXdpZHRoOlwiICsgcG9pbnQgKyBcInB4KVwiKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICAvKlxyXG4gICAgICAgKiBUbyBrZWVwIG1vbml0b3JpbmcgcmVzaXplIGV2ZW50IGFmdGVyIGRlc3RydWN0aW9uIHdpdGhvdXQgXCJjb21wbGV0ZWx5XCIsXHJcbiAgICAgICAqIHVzZSBuYXRpdmUgYWRkRXZlbnRMaXN0ZW5lciBpbnN0ZWFkIG9mIFNwbGlkZS5vbi5cclxuICAgICAgICovXG5cbiAgICAgIHRoaXMuZGVzdHJveSh0cnVlKTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRocm90dGxlZENoZWNrKTsgLy8gS2VlcCBpbml0aWFsIG9wdGlvbnMgdG8gYXBwbHkgdGhlbSB3aGVuIG5vIGJyZWFrcG9pbnQgbWF0Y2hlcy5cblxuICAgICAgaW5pdGlhbE9wdGlvbnMgPSBTcGxpZGUub3B0aW9ucztcbiAgICAgIGNoZWNrKCk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXBsZXRlbHkgLSBXaGV0aGVyIHRvIGRlc3Ryb3kgU3BsaWRlIGNvbXBsZXRlbHkuXHJcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KGNvbXBsZXRlbHkpIHtcbiAgICAgIGlmIChjb21wbGV0ZWx5KSB7XG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRocm90dGxlZENoZWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIENoZWNrIHRoZSBicmVha3BvaW50LlxyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNoZWNrKCkge1xuICAgIHZhciBwb2ludCA9IGdldFBvaW50KCk7XG5cbiAgICBpZiAocG9pbnQgIT09IHByZXZQb2ludCkge1xuICAgICAgcHJldlBvaW50ID0gcG9pbnQ7XG4gICAgICB2YXIgU3RhdGUgPSBTcGxpZGUuU3RhdGU7XG4gICAgICB2YXIgb3B0aW9ucyA9IGJyZWFrcG9pbnRzW3BvaW50XSB8fCBpbml0aWFsT3B0aW9ucztcbiAgICAgIHZhciBkZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuXG4gICAgICBpZiAoZGVzdHJveSkge1xuICAgICAgICBTcGxpZGUub3B0aW9ucyA9IGluaXRpYWxPcHRpb25zO1xuICAgICAgICBTcGxpZGUuZGVzdHJveShkZXN0cm95ID09PSAnY29tcGxldGVseScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKFN0YXRlLmlzKERFU1RST1lFRCkpIHtcbiAgICAgICAgICBTcGxpZGUubW91bnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFNwbGlkZS5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBicmVha3BvaW50IG1hdGNoaW5nIGN1cnJlbnQgd2luZG93IHdpZHRoLlxyXG4gICAqIE5vdGUgdGhhdCBBcnJheS5wcm90b3R5cGUuZmluZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IElFLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfHN0cmluZ30gLSBBIGJyZWFrcG9pbnQgYXMgbnVtYmVyIG9yIHN0cmluZy4gLTEgaWYgbm8gcG9pbnQgbWF0Y2hlcy5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFBvaW50KCkge1xuICAgIHZhciBpdGVtID0gbWFwLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0ubXFsLm1hdGNoZXM7XG4gICAgfSlbMF07XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLnBvaW50IDogLTE7XG4gIH1cblxuICByZXR1cm4gQnJlYWtwb2ludHM7XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb21wb25lbnRzL2luZGV4LmpzXG4vKipcclxuICogRXhwb3J0IGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgQ09NUExFVEUgPSB7XG4gIE9wdGlvbnM6IG9wdGlvbnMsXG4gIEJyZWFrcG9pbnRzOiBicmVha3BvaW50cyxcbiAgQ29udHJvbGxlcjogY29udHJvbGxlcixcbiAgRWxlbWVudHM6IGNvbXBvbmVudHNfZWxlbWVudHMsXG4gIFRyYWNrOiB0cmFjayxcbiAgQ2xvbmVzOiBjbG9uZXMsXG4gIExheW91dDogbGF5b3V0LFxuICBEcmFnOiBkcmFnLFxuICBDbGljazogY2xpY2ssXG4gIEF1dG9wbGF5OiBhdXRvcGxheSxcbiAgQ292ZXI6IGNvdmVyLFxuICBBcnJvd3M6IGFycm93cyxcbiAgUGFnaW5hdGlvbjogcGFnaW5hdGlvbixcbiAgTGF6eUxvYWQ6IGxhenlsb2FkLFxuICBLZXlib2FyZDoga2V5Ym9hcmQsXG4gIFN5bmM6IHN5bmMsXG4gIEExMXk6IGExMXlcbn07XG52YXIgTElHSFQgPSB7XG4gIE9wdGlvbnM6IG9wdGlvbnMsXG4gIENvbnRyb2xsZXI6IGNvbnRyb2xsZXIsXG4gIEVsZW1lbnRzOiBjb21wb25lbnRzX2VsZW1lbnRzLFxuICBUcmFjazogdHJhY2ssXG4gIENsb25lczogY2xvbmVzLFxuICBMYXlvdXQ6IGxheW91dCxcbiAgRHJhZzogZHJhZyxcbiAgQ2xpY2s6IGNsaWNrLFxuICBBcnJvd3M6IGFycm93cyxcbiAgUGFnaW5hdGlvbjogcGFnaW5hdGlvbixcbiAgQTExeTogYTExeVxufTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL21vZHVsZS9tb2R1bGUuanNcbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcclxuICogRXhwb3J0IFNwbGlkZSBjbGFzcyBmb3IgaW1wb3J0LlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cblxuLyoqXHJcbiAqIEV4cG9ydCBTcGxpZGUgY2xhc3MgZm9yIGltcG9ydCBmcm9tIG90aGVyIHByb2plY3RzLlxyXG4gKi9cblxudmFyIG1vZHVsZV9TcGxpZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db3JlKSB7XG4gIF9pbmhlcml0c0xvb3NlKFNwbGlkZSwgX0NvcmUpO1xuXG4gIGZ1bmN0aW9uIFNwbGlkZShyb290LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9Db3JlLmNhbGwodGhpcywgcm9vdCwgb3B0aW9ucywgQ09NUExFVEUpIHx8IHRoaXM7XG4gIH1cblxuICByZXR1cm4gU3BsaWRlO1xufShTcGxpZGUpO1xuXG5cblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcbi8qKioqKiovIFx0XHRcdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG4vKioqKioqLyBcdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcbi8qKioqKiovIFx0XHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcClcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcbi8qKioqKiovIFx0XHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBtb2R1bGUgZXhwb3J0cyBtdXN0IGJlIHJldHVybmVkIGZyb20gcnVudGltZSBzbyBlbnRyeSBpbmxpbmluZyBpcyBkaXNhYmxlZFxuLyoqKioqKi8gXHQvLyBzdGFydHVwXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygzMTEpO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@splidejs/splide/dist/js/splide.esm.js\n");

/***/ })

/******/ });